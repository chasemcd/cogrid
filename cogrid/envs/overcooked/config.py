"""Overcooked order queue support.

Provides order queue tick logic and table builders. All pot/container
mechanics (interaction branches, tick handler, extra state, static tables)
are now auto-generated by the Container/Recipe declarative system in
``cogrid.core.containers`` and composed by ``cogrid.core.autowire``.

This module contains only order-queue-specific code:

- ``_build_order_tables`` -- build order queue static tables from config
- ``order_queue_tick`` -- advance order timers, handle expiry and spawning
- ``build_order_extra_state`` -- initialize order queue arrays
"""

from cogrid.backend import xp
from cogrid.backend.array_ops import set_at


def build_order_extra_state(order_config):
    """Initialize order queue arrays from config.

    Parameters
    ----------
    order_config : dict
        Must contain ``"max_active"``. Optionally ``"spawn_interval"``
        (default 40).

    Returns:
    -------
    dict
        Order queue arrays keyed with ``overcooked.`` prefix.
    """
    import numpy as _np

    max_active = order_config["max_active"]
    spawn_interval = order_config.get("spawn_interval", 40)
    return {
        "overcooked.order_recipe": _np.full((max_active,), -1, dtype=_np.int32),
        "overcooked.order_timer": _np.zeros((max_active,), dtype=_np.int32),
        "overcooked.order_spawn_counter": _np.int32(spawn_interval),
        "overcooked.order_recipe_counter": _np.int32(0),
        "overcooked.order_n_expired": _np.int32(0),
    }


def order_queue_tick(state, scope_config):
    """Advance order timers: countdown, expiry, and spawning.

    Skips silently if no order arrays are present in extra_state.
    Designed to be composed with the auto-generated container tick::

        def my_tick(state, scope_config):
            state = autowired_tick(state, scope_config)  # pot timers
            state = order_queue_tick(state, scope_config)  # orders
            return state

    Parameters
    ----------
    state : EnvState
        Current state with optional order arrays in extra_state.
    scope_config : dict
        Must contain ``"static_tables"`` with order config arrays.

    Returns:
    -------
    EnvState
        Updated state (unchanged if no order arrays present).
    """
    import dataclasses

    if "overcooked.order_recipe" not in state.extra_state:
        return state

    static_tables = scope_config.get("static_tables", {})
    new_extra = dict(state.extra_state)

    order_recipe = new_extra["overcooked.order_recipe"]
    order_timer = new_extra["overcooked.order_timer"]
    order_spawn_counter = new_extra["overcooked.order_spawn_counter"]
    order_recipe_counter = new_extra["overcooked.order_recipe_counter"]
    order_n_expired = new_extra["overcooked.order_n_expired"]

    order_spawn_interval = static_tables["order_spawn_interval"]
    order_time_limit = static_tables["order_time_limit"]
    order_spawn_cycle = static_tables["order_spawn_cycle"]
    cycle_len = order_spawn_cycle.shape[0]

    # (1) Decrement active order timers
    active = order_recipe != -1
    new_order_timer = xp.where(active, order_timer - 1, order_timer)

    # (2) Clear expired orders (timer reached 0)
    expired = active & (new_order_timer <= 0)
    order_recipe = xp.where(expired, -1, order_recipe)
    new_order_timer = xp.where(expired, 0, new_order_timer)
    order_n_expired = order_n_expired + xp.sum(expired).astype(xp.int32)

    # (3) Spawn: decrement counter, check for spawn
    new_counter = order_spawn_counter - xp.int32(1)
    should_spawn = new_counter <= 0
    empty = order_recipe == -1
    has_empty = xp.any(empty)
    first_empty = xp.argmax(empty)
    spawn_now = should_spawn & has_empty

    new_recipe_idx = order_spawn_cycle[order_recipe_counter % cycle_len]
    order_recipe = xp.where(
        spawn_now,
        set_at(order_recipe, first_empty, new_recipe_idx),
        order_recipe,
    )
    new_order_timer = xp.where(
        spawn_now,
        set_at(new_order_timer, first_empty, order_time_limit),
        new_order_timer,
    )

    # Reset counter on spawn attempt (even if no empty slot)
    new_counter = xp.where(should_spawn, xp.int32(order_spawn_interval), new_counter)
    # Increment recipe counter only when actually spawned
    new_recipe_counter = xp.where(spawn_now, order_recipe_counter + 1, order_recipe_counter)

    new_extra["overcooked.order_recipe"] = order_recipe
    new_extra["overcooked.order_timer"] = new_order_timer
    new_extra["overcooked.order_spawn_counter"] = new_counter
    new_extra["overcooked.order_recipe_counter"] = new_recipe_counter
    new_extra["overcooked.order_n_expired"] = order_n_expired

    return dataclasses.replace(state, extra_state=new_extra)


def _build_order_tables(order_config, n_recipes):
    """Build order queue static tables from config dict.

    Parameters
    ----------
    order_config : dict or None
        If None, orders are disabled. Otherwise contains:
        ``spawn_interval`` (default 40), ``max_active`` (default 3),
        ``time_limit`` (default 200), ``recipe_weights`` (default uniform).
    n_recipes : int
        Number of recipes (for default uniform weights).

    Returns:
    -------
    dict
        Keys: ``order_enabled``, and when enabled also
        ``order_spawn_interval``, ``order_max_active``,
        ``order_time_limit``, ``order_spawn_cycle``.
    """
    import numpy as _np

    if order_config is None:
        return {"order_enabled": False}

    spawn_interval = order_config.get("spawn_interval", 40)
    max_active = order_config.get("max_active", 3)
    time_limit = order_config.get("time_limit", 200)
    recipe_weights = order_config.get("recipe_weights", None)

    if recipe_weights is None:
        recipe_weights = [1.0] * n_recipes

    # Build deterministic spawn cycle from weights.
    # Normalize to integers: [2.0, 1.0] -> [2, 1] -> cycle [0, 0, 1]
    weights = _np.array(recipe_weights, dtype=_np.float32)
    int_weights = _np.round(weights / weights.min()).astype(_np.int32)
    cycle = []
    for i, w in enumerate(int_weights):
        cycle.extend([i] * int(w))
    spawn_cycle = _np.array(cycle, dtype=_np.int32)

    return {
        "order_enabled": True,
        "order_spawn_interval": _np.int32(spawn_interval),
        "order_max_active": _np.int32(max_active),
        "order_time_limit": _np.int32(time_limit),
        "order_spawn_cycle": spawn_cycle,
    }

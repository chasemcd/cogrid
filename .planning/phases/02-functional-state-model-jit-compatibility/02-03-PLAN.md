---
phase: 02-functional-state-model-jit-compatibility
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - cogrid/feature_space/array_features.py
  - cogrid/envs/overcooked/array_rewards.py
autonomous: true

must_haves:
  truths:
    - "jax.jit(get_all_agent_obs_jax)(feature_fn, state_dict, n_agents) executes without ConcretizationTypeError (this is the get_obs function referenced in Phase 2 success criteria #5)"
    - "Per-agent observation generation uses jax.vmap instead of Python loop"
    - "jax.jit(compute_rewards_jax)(prev_state, state, actions, reward_config) executes without error and returns combined (n_agents,) reward array"
    - "compute_rewards_jax composes individual reward functions (delivery, onion_in_pot, soup_in_dish) and sums their outputs"
    - "Reward functions use array-based pot position matching instead of Python _find_pot_index loop"
    - "All int() casts on traced values replaced with jnp array operations in JAX path"
    - "Existing numpy-path feature and reward functions remain unchanged"
  artifacts:
    - path: "cogrid/feature_space/array_features.py"
      provides: "JAX-path observation functions with vmap"
      contains: "get_all_agent_obs_jax"
    - path: "cogrid/envs/overcooked/array_rewards.py"
      provides: "JAX-path reward functions and combined compute_rewards_jax wrapper"
      contains: "compute_rewards_jax"
  key_links:
    - from: "cogrid/feature_space/array_features.py"
      to: "jax.vmap"
      via: "per-agent vectorization"
      pattern: "vmap"
    - from: "cogrid/envs/overcooked/array_rewards.py"
      to: "jnp.where"
      via: "conditional reward computation replacing Python if/else"
      pattern: "jnp.where"
    - from: "cogrid/envs/overcooked/array_rewards.py"
      to: "delivery_reward_jax, onion_in_pot_reward_jax, soup_in_dish_reward_jax"
      via: "compute_rewards_jax calls individual reward functions and sums outputs"
      pattern: "compute_rewards_jax"
---

<objective>
Implement JIT-compatible observation extraction and reward computation functions.

Purpose: Observations and rewards are the remaining two sub-functions from the Phase 2 success criteria. The observation path is straightforward (vmap over agents). Rewards require converting 3 per-agent Python loops to vectorized ops and replacing `_find_pot_index` dict-based lookup with array matching.

Output: `get_all_agent_obs_jax()` with vmap in `array_features.py`, and three JAX-path reward functions in `array_rewards.py`, all JIT-compiling without error.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-functional-state-model-jit-compatibility/02-RESEARCH.md
@.planning/phases/02-functional-state-model-jit-compatibility/02-01-SUMMARY.md
@cogrid/feature_space/array_features.py
@cogrid/envs/overcooked/array_rewards.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JAX-path observation functions with vmap</name>
  <files>cogrid/feature_space/array_features.py</files>
  <action>
Add JAX-path observation functions to `cogrid/feature_space/array_features.py`. All existing numpy-path functions remain completely unchanged.

**New functions to add:**

1. **`agent_pos_feature_jax(agent_pos, agent_idx)`** -- Returns `agent_pos[agent_idx]` without `np.asarray` cast. Trivial but needed for vmap compatibility (must use jnp ops).

2. **`agent_dir_feature_jax(agent_dir, agent_idx)`** -- One-hot without `np.zeros` or `int()`:
```python
def agent_dir_feature_jax(agent_dir, agent_idx):
    return (jnp.arange(4) == agent_dir[agent_idx]).astype(jnp.int32)
```

3. **`full_map_encoding_feature_jax(object_type_map, object_state_map, agent_pos, agent_dir, agent_inv, agent_type_ids, max_map_size=(12,12))`**
   - `agent_type_ids` is a `(4,)` int32 array where `agent_type_ids[dir]` gives the type_id for `agent_{dir_char}` in global scope. This is pre-computed at init time.
   - Build encoding without Python loops over agents. Use scatter ops:
     ```python
     # For each agent, compute type_id and state
     # agent_type = agent_type_ids[agent_dir]  # (n_agents,)
     # agent_state = jnp.where(agent_inv[:, 0] == -1, 0, agent_inv[:, 0])  # (n_agents,)
     # Scatter agents onto encoding
     encoding = encoding.at[agent_pos[:, 0], agent_pos[:, 1], 0].set(agent_type.astype(jnp.int8))
     encoding = encoding.at[agent_pos[:, 0], agent_pos[:, 1], 2].set(agent_state.astype(jnp.int8))
     ```
   - NOTE: If two agents are at the same position (shouldn't happen in valid states), the last-written wins. This matches the Python loop behavior.

4. **`can_move_direction_feature_jax(agent_pos, agent_idx, wall_map, object_type_map, can_overlap_table)`**
   - Replace Python loop over `adjacent_positions` with direct array computation:
   ```python
   # 4 directions: Right(0,1), Left(0,-1), Down(1,0), Up(-1,0)
   deltas = jnp.array([[0, 1], [0, -1], [1, 0], [-1, 0]], dtype=jnp.int32)
   pos = agent_pos[agent_idx]
   neighbors = pos[None, :] + deltas  # (4, 2)
   # Clip and check bounds
   in_bounds = (neighbors[:, 0] >= 0) & (neighbors[:, 0] < H) & (neighbors[:, 1] >= 0) & (neighbors[:, 1] < W)
   clipped = jnp.clip(neighbors, 0, jnp.array([H-1, W-1]))
   type_ids = object_type_map[clipped[:, 0], clipped[:, 1]]
   can_overlap = can_overlap_table[type_ids]
   can_move = (in_bounds & (can_overlap == 1)).astype(jnp.int32)
   ```

5. **`inventory_feature_jax(agent_inv, agent_idx)`** -- No `int()`:
```python
def inventory_feature_jax(agent_inv, agent_idx):
    inv_val = agent_inv[agent_idx, 0]
    feature_val = jnp.where(inv_val == -1, 0, inv_val + 1)
    return jnp.array([feature_val], dtype=jnp.int32)
```

6. **`build_feature_fn_jax(feature_names, scope, **kwargs)`** -- Same as `build_feature_fn` but uses JAX-path features. Returns a function `(state_dict, agent_idx) -> obs_array` using `jnp.concatenate` instead of `np.concatenate`.

7. **`get_all_agent_obs_jax(feature_fn, state_dict, n_agents)`** -- Uses `jax.vmap`:
```python
def get_all_agent_obs_jax(feature_fn, state_dict, n_agents):
    # vmap over agent_idx
    vmapped = jax.vmap(lambda i: feature_fn(state_dict, i))
    return vmapped(jnp.arange(n_agents))
```
NOTE: For vmap to work, `feature_fn(state_dict, agent_idx)` must be JIT-compatible for each agent_idx. The `agent_idx` is the vmapped axis.

**Important: `full_map_encoding_feature_jax` does NOT take `scope` as a string parameter.** Instead it takes `agent_type_ids` (a pre-computed int32 array). String parameters under JIT would need to be static, and the scope is used only to look up agent type IDs, which can be done once at init time.

**Do NOT modify any existing function.** All numpy-path functions must remain exactly as-is.
  </action>
  <verify>
Test that the JAX observation functions JIT-compile:
```python
python -c "
from cogrid.backend import set_backend
set_backend('jax')
import jax
import jax.numpy as jnp
from cogrid.feature_space.array_features import (
    agent_pos_feature_jax, agent_dir_feature_jax,
    can_move_direction_feature_jax, inventory_feature_jax,
    get_all_agent_obs_jax,
)

agent_pos = jnp.array([[1,2],[3,4]], dtype=jnp.int32)
agent_dir = jnp.array([0, 2], dtype=jnp.int32)
agent_inv = jnp.full((2,1), -1, dtype=jnp.int32)
wall_map = jnp.zeros((7,7), dtype=jnp.int32)
obj_map = jnp.zeros((7,7), dtype=jnp.int32)
can_overlap = jnp.ones(10, dtype=jnp.int32)

# Test individual features under JIT
pos = jax.jit(agent_pos_feature_jax)(agent_pos, 0)
assert pos.shape == (2,)

dir_oh = jax.jit(agent_dir_feature_jax)(agent_dir, 0)
assert dir_oh.shape == (4,) and int(dir_oh[0]) == 1

cm = jax.jit(can_move_direction_feature_jax)(agent_pos, 0, wall_map, obj_map, can_overlap)
assert cm.shape == (4,)

inv = jax.jit(inventory_feature_jax)(agent_inv, 0)
assert inv.shape == (1,) and int(inv[0]) == 0

print('Individual JAX features JIT: PASSED')

# Test vmap
def simple_feature(sd, ai):
    return jnp.concatenate([
        agent_pos_feature_jax(sd['agent_pos'], ai),
        agent_dir_feature_jax(sd['agent_dir'], ai),
    ])

sd = {'agent_pos': agent_pos, 'agent_dir': agent_dir}
obs = get_all_agent_obs_jax(simple_feature, sd, 2)
assert obs.shape == (2, 6)
print('JAX vmap obs: PASSED')
"
```
  </verify>
  <done>All 5 individual JAX-path feature functions exist. build_feature_fn_jax produces a JIT-compatible composed function. get_all_agent_obs_jax uses jax.vmap. All existing numpy functions unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Implement JAX-path reward functions with vectorized agent processing</name>
  <files>cogrid/envs/overcooked/array_rewards.py</files>
  <action>
Add JAX-path reward functions to `cogrid/envs/overcooked/array_rewards.py`. All existing numpy-path functions remain completely unchanged.

**New functions:**

1. **`delivery_reward_jax(prev_state, state, actions, type_ids, n_agents, coefficient=1.0, common_reward=True, action_pickup_drop_idx=4)`**

Replace the Python `for i in range(n_agents)` loop with fully vectorized ops:
```python
import jax.numpy as jnp

# Vectorized across all agents simultaneously
is_interact = (actions == action_pickup_drop_idx)  # (n_agents,)
holds_soup = (prev_state['agent_inv'][:, 0] == type_ids['onion_soup'])  # (n_agents,)

# Forward positions for all agents
dir_vec_table = get_dir_vec_table()  # reuse existing
fwd_pos = prev_state['agent_pos'] + dir_vec_table[prev_state['agent_dir']]  # (n_agents, 2)
H, W = prev_state['object_type_map'].shape
fwd_r = jnp.clip(fwd_pos[:, 0], 0, H - 1)
fwd_c = jnp.clip(fwd_pos[:, 1], 0, W - 1)
in_bounds = (fwd_pos[:, 0] >= 0) & (fwd_pos[:, 0] < H) & (fwd_pos[:, 1] >= 0) & (fwd_pos[:, 1] < W)

fwd_types = prev_state['object_type_map'][fwd_r, fwd_c]  # (n_agents,)
faces_delivery = (fwd_types == type_ids['delivery_zone'])  # (n_agents,)

earns_reward = is_interact & holds_soup & faces_delivery & in_bounds  # (n_agents,)

# Apply reward
if common_reward is a static bool (Python level):
rewards = jnp.where(jnp.any(earns_reward), coefficient, 0.0) * jnp.ones(n_agents, dtype=jnp.float32)
# But common_reward is a Python bool, so:
if common_reward:
    total = jnp.sum(earns_reward.astype(jnp.float32)) * coefficient
    rewards = jnp.full(n_agents, total, dtype=jnp.float32)
else:
    rewards = earns_reward.astype(jnp.float32) * coefficient
```

NOTE: `common_reward` and `coefficient` are Python-level values, not traced. This is fine because they are function parameters that don't come from arrays. They can be used in Python `if/else` at trace time (JAX recompiles for each distinct value if they are marked static or remain constant).

**However**, to make these functions safe for JIT without needing to mark `common_reward` as static, use `jnp.where` instead of Python `if`:
```python
total_earned = jnp.sum(earns_reward.astype(jnp.float32)) * coefficient
individual_rewards = earns_reward.astype(jnp.float32) * coefficient
# common_reward is a Python bool, so this if/else happens at trace time -- OK
if common_reward:
    rewards = jnp.full(n_agents, total_earned / jnp.maximum(jnp.sum(earns_reward), 1), dtype=jnp.float32) * total_earned
    # Simpler: if ANY agent earns, ALL get coefficient per earning agent
    rewards = jnp.where(jnp.any(earns_reward), 1.0, 0.0) * coefficient * jnp.ones(n_agents, dtype=jnp.float32)
    # Actually match numpy version: rewards = rewards + coefficient when earns (adds per-earning-agent)
    n_earners = jnp.sum(earns_reward.astype(jnp.float32))
    rewards = jnp.full(n_agents, n_earners * coefficient, dtype=jnp.float32)
else:
    rewards = earns_reward.astype(jnp.float32) * coefficient
```

Study the numpy version carefully to match the exact semantics. The numpy version does `rewards = rewards + coefficient` when common_reward, which means each earning agent adds `coefficient` to ALL agents. So: `rewards = n_earners * coefficient * ones(n_agents)` for common, `rewards = earns * coefficient` for individual.

2. **`onion_in_pot_reward_jax(...)`** -- Same vectorization pattern. Replace `_find_pot_index` with array-based pot position matching:
```python
# For each agent, find if they face a pot and which pot index
# fwd_pos already computed
# pot_positions: (n_pots, 2) int32
matches = jnp.all(prev_state['pot_positions'][:, None, :] == fwd_pos[None, :, :].transpose(1, 0, 2), ...)
```
Actually simpler per-agent: compute for each agent whether their forward position matches any pot:
```python
# (n_agents, n_pots) -- does agent i face pot j?
pos_match = jnp.all(
    prev_state['pot_positions'][None, :, :] == fwd_pos[:, None, :],
    axis=2
)  # (n_agents, n_pots)
facing_any_pot = jnp.any(pos_match, axis=1)  # (n_agents,)
pot_idx = jnp.argmax(pos_match, axis=1)  # (n_agents,) -- index of matched pot
```
Then check pot capacity and type compatibility using `pot_contents[pot_idx]` (vectorized over agents):
```python
pot_row = prev_state['pot_contents'][pot_idx]  # (n_agents, 3)
n_filled = jnp.sum(pot_row != -1, axis=1)  # (n_agents,)
has_capacity = n_filled < 3

# Same-type check: all non-sentinel slots match onion
is_onion_or_empty = (pot_row == -1) | (pot_row == type_ids['onion'])
compatible = jnp.all(is_onion_or_empty, axis=1)  # (n_agents,)
```

3. **`soup_in_dish_reward_jax(...)`** -- Same pattern but simpler (only check pot timer == 0).

4. **`_find_pot_index_jax(pot_positions, fwd_pos)` -- not needed as a separate function.** The vectorized approach above computes pot indices inline for all agents. But if useful as a utility:
```python
def _find_pot_index_jax(pot_positions, row, col):
    matches = jnp.all(pot_positions == jnp.array([row, col]), axis=1)
    return jnp.argmax(matches), jnp.any(matches)
```

**pot_positions handling:** The JAX reward functions expect `pot_positions` as a `(n_pots, 2)` jnp.array, NOT a Python list of tuples. This is consistent with the EnvState design (Plan 02-01) where `pot_positions` is already a fixed-shape array. The numpy-path functions continue using the Python list format.

5. **`compute_rewards_jax(prev_state, state, actions, reward_config)`** -- Combined reward composition wrapper that calls individual reward functions and sums their outputs. This is the `compute_rewards` function referenced in Phase 2 success criteria #5.

```python
def compute_rewards_jax(prev_state, state, actions, reward_config):
    """Compute combined rewards from all configured reward functions.

    Args:
        prev_state: dict of state arrays before step
        state: dict of state arrays after step
        actions: (n_agents,) int32 action indices
        reward_config: dict with keys:
            - "type_ids": dict mapping type names to int IDs
            - "n_agents": int (static)
            - "rewards": list of dicts, each with:
                - "fn": str name ("delivery", "onion_in_pot", "soup_in_dish")
                - "coefficient": float
                - "common_reward": bool
            - "action_pickup_drop_idx": int (static)

    Returns:
        (n_agents,) float32 array of combined rewards
    """
    n_agents = reward_config["n_agents"]
    type_ids = reward_config["type_ids"]
    action_idx = reward_config["action_pickup_drop_idx"]

    # Map function name strings to JAX reward functions
    fn_map = {
        "delivery": delivery_reward_jax,
        "onion_in_pot": onion_in_pot_reward_jax,
        "soup_in_dish": soup_in_dish_reward_jax,
    }

    total_rewards = jnp.zeros(n_agents, dtype=jnp.float32)
    for reward_spec in reward_config["rewards"]:
        fn = fn_map[reward_spec["fn"]]
        r = fn(
            prev_state, state, actions, type_ids, n_agents,
            coefficient=reward_spec["coefficient"],
            common_reward=reward_spec["common_reward"],
            action_pickup_drop_idx=action_idx,
        )
        total_rewards = total_rewards + r

    return total_rewards
```

NOTE: The Python `for` loop over `reward_config["rewards"]` is fine because `reward_config` is a static Python dict (not traced). Each iteration adds a traced computation to the graph. JAX traces through the loop at compile time and fuses the individual reward computations. The number and type of reward functions is fixed per configuration, so this loop unrolls at trace time.

**Do NOT modify any existing numpy-path function.**
  </action>
  <verify>
Test that the JAX reward functions JIT-compile:
```python
python -c "
from cogrid.backend import set_backend
set_backend('jax')
import jax
import jax.numpy as jnp
from cogrid.envs.overcooked.array_rewards import (
    delivery_reward_jax, onion_in_pot_reward_jax, soup_in_dish_reward_jax,
    compute_rewards_jax,
)
from cogrid.core.agent import get_dir_vec_table

type_ids = {'onion_soup': 10, 'delivery_zone': 11, 'pot': 5, 'onion': 3, 'plate': 6}
prev_state = {
    'agent_pos': jnp.array([[1,2],[3,4]], dtype=jnp.int32),
    'agent_dir': jnp.array([0, 2], dtype=jnp.int32),
    'agent_inv': jnp.full((2,1), -1, dtype=jnp.int32),
    'object_type_map': jnp.zeros((7,7), dtype=jnp.int32),
    'pot_contents': jnp.full((1,3), -1, dtype=jnp.int32),
    'pot_timer': jnp.zeros(1, dtype=jnp.int32),
    'pot_positions': jnp.array([[2,3]], dtype=jnp.int32),
}
state = prev_state  # same for test
actions = jnp.array([4, 6], dtype=jnp.int32)

# Test delivery reward
fn1 = jax.jit(delivery_reward_jax, static_argnames=['n_agents', 'coefficient', 'common_reward', 'action_pickup_drop_idx'])
r1 = fn1(prev_state, state, actions, type_ids, 2, coefficient=1.0, common_reward=True, action_pickup_drop_idx=4)
assert r1.shape == (2,)
print(f'delivery reward: {r1}')

# Test onion_in_pot reward
fn2 = jax.jit(onion_in_pot_reward_jax, static_argnames=['n_agents', 'coefficient', 'common_reward', 'action_pickup_drop_idx'])
r2 = fn2(prev_state, state, actions, type_ids, 2, coefficient=0.1, common_reward=False, action_pickup_drop_idx=4)
assert r2.shape == (2,)
print(f'onion_in_pot reward: {r2}')

# Test soup_in_dish reward
fn3 = jax.jit(soup_in_dish_reward_jax, static_argnames=['n_agents', 'coefficient', 'common_reward', 'action_pickup_drop_idx'])
r3 = fn3(prev_state, state, actions, type_ids, 2, coefficient=0.3, common_reward=False, action_pickup_drop_idx=4)
assert r3.shape == (2,)
print(f'soup_in_dish reward: {r3}')

# Test combined compute_rewards_jax
reward_config = {
    'type_ids': type_ids,
    'n_agents': 2,
    'action_pickup_drop_idx': 4,
    'rewards': [
        {'fn': 'delivery', 'coefficient': 1.0, 'common_reward': True},
        {'fn': 'onion_in_pot', 'coefficient': 0.1, 'common_reward': False},
        {'fn': 'soup_in_dish', 'coefficient': 0.3, 'common_reward': False},
    ],
}
fn_combined = jax.jit(compute_rewards_jax)
r_combined = fn_combined(prev_state, state, actions, reward_config)
assert r_combined.shape == (2,)
print(f'combined reward: {r_combined}')

print('JAX rewards JIT: ALL PASSED')
"
```
  </verify>
  <done>Three JAX-path reward functions exist plus a combined compute_rewards_jax wrapper that composes them. All use vectorized ops across agents instead of Python loops. Pot position lookup uses array matching. jax.jit(compute_rewards_jax)(prev_state, state, actions, reward_config) executes without error. Existing numpy functions unchanged.</done>
</task>

</tasks>

<verification>
1. All 5 individual JAX feature functions JIT-compile
2. `get_all_agent_obs_jax` (the `get_obs` from Phase 2 success criteria #5) uses vmap and produces correct `(n_agents, obs_dim)` shape
3. All 3 individual JAX reward functions JIT-compile
4. `compute_rewards_jax` (the `compute_rewards` from Phase 2 success criteria #5) composes individual rewards and JIT-compiles as a single unit
5. No `int()` casts on traced values in JAX path
6. No Python loops over agents in JAX path
7. `_find_pot_index` Python loop replaced with array matching in JAX path
8. All existing numpy-path functions completely unchanged
</verification>

<success_criteria>
- `jax.jit(get_all_agent_obs_jax)(feature_fn, state_dict, n_agents)` executes without error -- this is the `get_obs` function from Phase 2 success criteria #5
- `jax.jit(compute_rewards_jax)(prev_state, state, actions, reward_config)` executes without error -- this is the `compute_rewards` function from Phase 2 success criteria #5
- `jax.jit(delivery_reward_jax)(...)`, `jax.jit(onion_in_pot_reward_jax)(...)`, `jax.jit(soup_in_dish_reward_jax)(...)` all execute without error individually
- Combined with Plans 02-01 and 02-02, all 5 success criteria from the Phase 2 ROADMAP are met
- No PHASE2 markers remain unaddressed in JAX-path code
</success_criteria>

<output>
After completion, create `.planning/phases/02-functional-state-model-jit-compatibility/02-03-SUMMARY.md`
</output>

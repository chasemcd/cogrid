---
phase: 02-functional-state-model-jit-compatibility
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - cogrid/core/interactions.py
  - cogrid/envs/overcooked/array_config.py
autonomous: true

must_haves:
  truths:
    - "process_interactions_jax uses lax.fori_loop for sequential agent processing instead of Python for loop"
    - "All array mutations in the JAX interaction path use .at[].set() and jnp.where instead of direct assignment"
    - "Scope-specific interaction logic (pot, delivery zone, stacks) is embedded via table-driven jnp.where masking, not Python callbacks"
    - "pot_pos_to_idx dict lookup replaced with array-based position matching under JIT"
    - "Toggle action dispatches to type-specific behavior via jax.lax.switch on object type ID -- no Python isinstance or virtual dispatch on traced values"
    - "jax.jit(process_interactions_jax)(...) executes without ConcretizationTypeError"
    - "Existing numpy-path process_interactions_array and _overcooked_interaction_handler remain unchanged"
  artifacts:
    - path: "cogrid/core/interactions.py"
      provides: "JAX-path interaction function"
      contains: "process_interactions_jax"
    - path: "cogrid/envs/overcooked/array_config.py"
      provides: "JAX-compatible Overcooked interaction and tick logic"
      contains: "overcooked_interaction_body_jax"
  key_links:
    - from: "cogrid/core/interactions.py"
      to: "jax.lax.fori_loop"
      via: "sequential agent processing"
      pattern: "lax.fori_loop"
    - from: "cogrid/envs/overcooked/array_config.py"
      to: "cogrid/core/interactions.py"
      via: "JAX interaction body callable passed from scope config"
      pattern: "interaction_body_jax"
    - from: "cogrid/core/interactions.py"
      to: "jax.lax.switch"
      via: "toggle action dispatch on object type ID"
      pattern: "lax.switch"
---

<objective>
Implement JIT-compatible interaction processing for both core generic logic and Overcooked-specific handlers.

Purpose: Interactions are the most complex sub-function (16 PHASE2 markers across 2 files). This plan converts all Python control flow on traced values to `jnp.where` masking and `lax.fori_loop`, and replaces Python dict lookups with array-based lookups. The scope config callback pattern is replaced with a table-driven approach where the core JIT function embeds all logic parameterized by static tables.

Output: `process_interactions_jax()` in `cogrid/core/interactions.py` and a JAX-compatible Overcooked interaction body in `cogrid/envs/overcooked/array_config.py`, both JIT-compiling without error.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-functional-state-model-jit-compatibility/02-RESEARCH.md
@.planning/phases/02-functional-state-model-jit-compatibility/02-01-SUMMARY.md
@cogrid/core/interactions.py
@cogrid/envs/overcooked/array_config.py
@cogrid/core/scope_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JAX-compatible Overcooked interaction and tick functions</name>
  <files>cogrid/envs/overcooked/array_config.py</files>
  <action>
Add JAX-path functions to `cogrid/envs/overcooked/array_config.py`. The existing numpy-path functions (`_overcooked_interaction_handler`, `_overcooked_tick_handler`, `_place_on_pot`, `_place_on_delivery_zone`) remain completely unchanged.

**New function 1: `overcooked_interaction_body_jax(i, carry, *, static_tables)`**

This is the loop body for `lax.fori_loop` that handles a single agent's interaction. It replaces the Python callback pattern with inline table-driven logic.

Signature:
```python
def overcooked_interaction_body_jax(i, carry, *, actions, agent_pos, agent_dir, dir_vec_table, action_pickup_drop_idx, static_tables):
```

Where `static_tables` is a dict (closed over, not traced) containing:
- `CAN_PICKUP`: int32 array
- `CAN_PICKUP_FROM`: int32 array
- `CAN_PLACE_ON`: int32 array
- `pickup_from_produces`: int32 array
- `legal_pot_ingredients`: int32 array
- `pot_id`, `plate_id`, `tomato_id`, `onion_soup_id`, `tomato_soup_id`, `delivery_zone_id`: int constants
- `cooking_time`: int constant

The carry is a tuple: `(agent_inv, object_type_map, object_state_map, pot_contents, pot_timer, pot_positions)`

**Implementation approach -- ALL branches computed, selected by `jnp.where`:**

The core pattern for each agent `i`:
1. Check `is_interact = (actions[i] == action_pickup_drop_idx)` -- mask all results with this
2. Compute forward position: `fwd_pos = agent_pos[i] + dir_vec_table[agent_dir[i]]`, clip to bounds
3. Check agent_ahead: `agent_ahead = jnp.any(jnp.all(agent_pos == fwd_pos[None, :], axis=1) & (jnp.arange(n_agents) != i))` -- note: `n_agents` can be derived from `agent_pos.shape[0]` which is static
4. Get `fwd_type = object_type_map[fwd_r, fwd_c]` and `inv_item = agent_inv[i, 0]`

For each priority branch, compute the "would-happen" result and its condition mask, then apply cumulatively:

**Branch 1 (can_pickup):**
```python
b1_cond = is_interact & ~agent_ahead & (fwd_type > 0) & (CAN_PICKUP[fwd_type] == 1) & (inv_item == -1)
# Result: agent_inv[i] = fwd_type, obj_type_map[r,c] = 0, obj_state_map[r,c] = 0
```

**Branch 2 (can_pickup_from -- Overcooked-specific):**
Compute sub-conditions:
- `is_pot = (fwd_type == pot_id)`
- Pot index via array matching: `matches = jnp.all(pot_positions == jnp.array([fwd_r, fwd_c]), axis=1); pot_idx = jnp.argmax(matches); has_pot_match = jnp.any(matches)`
- Pot ready: `has_contents = jnp.sum(pot_contents[pot_idx] != -1) > 0; is_ready = pot_timer[pot_idx] == 0`
- Soup type: `all_tomato = jnp.all((pot_contents[pot_idx] == -1) | (pot_contents[pot_idx] == tomato_id)); soup_type = jnp.where(all_tomato, tomato_soup_id, onion_soup_id)`
- `b2_pot_cond = is_interact & ~agent_ahead & ~b1_cond & is_pot & has_pot_match & has_contents & is_ready & (inv_item == plate_id)`
  - Result: `agent_inv[i] = soup_type, pot_contents[pot_idx,:] = -1, pot_timer[pot_idx] = cooking_time`
- `is_stack = (fwd_type != pot_id) & (CAN_PICKUP_FROM[fwd_type] == 1)`
- `produced = pickup_from_produces[fwd_type]`
- `b2_stack_cond = is_interact & ~agent_ahead & ~b1_cond & is_stack & (inv_item == -1) & (produced > 0)`
  - Result: `agent_inv[i] = produced`

**Branch 3 (drop on empty):**
```python
b3_cond = is_interact & ~agent_ahead & ~b1_cond & ~b2_pot_cond & ~b2_stack_cond & (fwd_type == 0) & (inv_item != -1)
# Result: obj_type_map[r,c] = inv_item, obj_state_map[r,c] = 0, agent_inv[i] = -1
```

**Branch 4 (place_on):**
Sub-cases for pot, delivery zone, generic counter:
- Pot place_on: check `legal_pot_ingredients[inv_item]`, capacity (`jnp.sum(pot_contents[pot_idx] != -1) < 3`), same-type constraint, find first empty slot
- Delivery zone: check `inv_item == onion_soup_id | inv_item == tomato_soup_id`, clear inv
- Generic counter: check `object_state_map[fwd_r, fwd_c] == 0`, store inv_item

All computed with `jnp.where` masking. The `pot_idx` from branch 2 is reused.

**Apply all updates with `.at[].set()` and `jnp.where`:**
Each array update is conditional: `agent_inv = jnp.where(b1_cond, ..., jnp.where(b2_pot_cond, ..., ...))`
Or equivalently, compute each branch's new value and select with cascading `jnp.where`.

Return updated carry.

**New function 2: `overcooked_tick_jax(pot_contents, pot_timer, capacity=3, cooking_time=30)`**

JAX-compatible version of `_overcooked_tick_handler`. Same logic but:
- No `.copy()` (JAX arrays immutable)
- Uses `jnp.where` (already done in numpy version, just remove `.copy()`)
- Returns `(pot_contents, pot_timer, pot_state)` -- same as numpy version

This function is simple since the numpy version is already nearly JAX-compatible.

**Update `build_overcooked_scope_config()`:**
Add new keys to the returned config dict:
- `"interaction_body_jax"`: reference to `overcooked_interaction_body_jax`
- `"tick_handler_jax"`: reference to `overcooked_tick_jax`
- `"static_tables"`: a dict built at config time containing all the int constants and array tables needed by `overcooked_interaction_body_jax`

**Do NOT modify any existing numpy-path functions.** All existing functions must remain exactly as-is.
  </action>
  <verify>
Test that the JAX tick function JIT-compiles:
```python
python -c "
from cogrid.backend import set_backend
set_backend('jax')
import jax
import jax.numpy as jnp
from cogrid.envs.overcooked.array_config import overcooked_tick_jax

pot_contents = jnp.array([[3, 3, 3]], dtype=jnp.int32)
pot_timer = jnp.array([5], dtype=jnp.int32)
fn = jax.jit(overcooked_tick_jax, static_argnames=['capacity', 'cooking_time'])
pc, pt, ps = fn(pot_contents, pot_timer, capacity=3, cooking_time=30)
print(f'pot_timer after tick: {pt}')
assert int(pt[0]) == 4
print('JAX tick JIT: PASSED')
"
```
  </verify>
  <done>overcooked_interaction_body_jax and overcooked_tick_jax exist. Tick function JIT-compiles. Interaction body uses jnp.where masking and .at[].set() for all state mutations. No Python callbacks used in JAX path. All existing numpy-path functions unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Implement core process_interactions_jax with lax.fori_loop</name>
  <files>cogrid/core/interactions.py</files>
  <action>
Add `process_interactions_jax()` to `cogrid/core/interactions.py`, alongside the existing `process_interactions_array()` which remains completely unchanged.

**Function signature:**
```python
def process_interactions_jax(
    agent_pos,          # (n_agents, 2) int32
    agent_dir,          # (n_agents,) int32
    agent_inv,          # (n_agents, 1) int32
    actions,            # (n_agents,) int32
    object_type_map,    # (H, W) int32
    object_state_map,   # (H, W) int32
    lookup_tables,      # dict -- static, closed over
    scope_config,       # dict -- static, closed over
    dir_vec_table,      # (4, 2) int32
    action_pickup_drop_idx,  # int -- static
    action_toggle_idx,       # int -- static
    pot_contents=None,  # (n_pots, 3) int32 or None
    pot_timer=None,     # (n_pots,) int32 or None
    pot_positions=None, # (n_pots, 2) int32 or None
):
```

NOTE: The `**extra_state` kwargs pattern from the numpy path is replaced with explicit keyword arguments for JAX compatibility (JAX needs to trace all array arguments explicitly).

**Returns:** `(agent_inv, object_type_map, object_state_map, pot_contents, pot_timer)`

**Implementation:**

1. Get the JAX interaction body from scope_config:
```python
interaction_body_jax = scope_config.get("interaction_body_jax") if scope_config else None
```

2. If `interaction_body_jax` is not None (Overcooked scope), use it as the `lax.fori_loop` body. The scope-specific body handles all 4 priority branches with Overcooked-specific sub-cases.

3. If `interaction_body_jax` is None (generic scope), create a generic loop body that only handles branches 1 (can_pickup), 3 (drop on empty), and 4 (generic place_on) using `jnp.where` and `.at[].set()`. This generic body ignores branch 2 (can_pickup_from) since there is no scope-specific handler.

4. **Toggle action dispatch via `jax.lax.switch`** (requirement INTR-03):

After the pickup/drop `lax.fori_loop`, process toggle actions. For each agent whose `actions[i] == action_toggle_idx`, dispatch to a type-specific handler based on the object type ID at the agent's forward cell using `jax.lax.switch`.

Implementation:
```python
# Toggle branch functions -- each takes (carry_state, agent_idx) and returns carry_state
# All branches must have identical signatures and return types.
def toggle_noop(carry, agent_idx):
    return carry  # no-op for types without toggle behavior

def toggle_door(carry, agent_idx):
    # Flip object_state_map at forward position (0 <-> 1)
    obj_state = carry[2]
    fwd_r, fwd_c = ...  # computed from agent_pos[agent_idx] + dir_vec
    current = obj_state[fwd_r, fwd_c]
    new_state = 1 - current  # toggle between 0 (closed) and 1 (open)
    obj_state = obj_state.at[fwd_r, fwd_c].set(new_state)
    return (carry[0], carry[1], obj_state, carry[3], carry[4])

# Build branches list at trace time, indexed by type ID.
# Scope config provides "toggle_branches_jax": a list of (type_id, handler_fn) pairs,
# or None if no toggle types exist. The core code builds a branches list
# of length max_type_id+1, defaulting to toggle_noop, then inserts
# scope-provided handlers at their type_id indices.
toggle_branches = [toggle_noop] * (max_type_id + 1)
if scope_config and "toggle_branches_jax" in scope_config:
    for type_id, handler_fn in scope_config["toggle_branches_jax"]:
        toggle_branches[type_id] = handler_fn

# Inside the fori_loop body (or a second fori_loop for toggle):
is_toggle = (actions[i] == action_toggle_idx)
fwd_type = object_type_map[fwd_r, fwd_c]
# Dispatch via lax.switch -- all branches are traced, runtime selects by index
toggle_carry = jax.lax.switch(fwd_type, toggle_branches, carry, i)
# Apply only if this agent is actually toggling
carry = jax.tree.map(
    lambda old, new: jnp.where(is_toggle, new, old),
    carry, toggle_carry
)
```

The toggle dispatch is a second pass in the same `lax.fori_loop` body (after the pickup/drop branches), or a separate `lax.fori_loop` after the pickup/drop loop. Either approach works; a single loop body with both pickup/drop and toggle sections is preferred to avoid the overhead of two separate loops.

**Update `build_overcooked_scope_config()`** to include `"toggle_branches_jax"` in the scope config. For Overcooked, this may be an empty list (no toggle types) or contain pot-related toggle handlers if applicable. The key must be present so the core code can check for it.

5. Set up the carry tuple and call `lax.fori_loop(0, n_agents, body_fn, init_carry)`.

6. Unpack carry and return results.

**Key implementation detail for the interaction body closure:**
The `lax.fori_loop` body function signature must be `body(i, carry)`. The body needs access to `actions`, `agent_pos`, `agent_dir`, `dir_vec_table`, `action_pickup_drop_idx`, and `static_tables`. These are closed over from the enclosing scope. The carry contains only the mutable state: `(agent_inv, object_type_map, object_state_map, pot_contents, pot_timer)`.

For the generic case (no Overcooked), `pot_contents` and `pot_timer` can be dummy arrays (e.g., `jnp.zeros((0, 3))`) since they won't be used.

**For the Overcooked case:**
Call the scope config's `interaction_body_jax` with all needed static tables via functools.partial or a lambda that closes over the static tables:
```python
static_tables = scope_config.get("static_tables", {})
body = functools.partial(
    interaction_body_jax,
    actions=actions, agent_pos=agent_pos, agent_dir=agent_dir,
    dir_vec_table=dir_vec_table, action_pickup_drop_idx=action_pickup_drop_idx,
    static_tables=static_tables,
)
```

**Do NOT modify `process_interactions_array` in any way.**
  </action>
  <verify>
Test that the JAX interaction function JIT-compiles with Overcooked scope:
```python
python -c "
from cogrid.backend import set_backend
set_backend('jax')
import jax
import jax.numpy as jnp
import cogrid.envs  # trigger scope registration
from cogrid.core.interactions import process_interactions_jax
from cogrid.core.scope_config import get_scope_config
from cogrid.core.grid_object import build_lookup_tables
from cogrid.core.agent import get_dir_vec_table

scope_config = get_scope_config('overcooked')
tables = build_lookup_tables(scope='overcooked')
dir_vec = get_dir_vec_table()

agent_pos = jnp.array([[1,2],[3,4]], dtype=jnp.int32)
agent_dir = jnp.array([0, 2], dtype=jnp.int32)
agent_inv = jnp.full((2,1), -1, dtype=jnp.int32)
actions = jnp.array([4, 6], dtype=jnp.int32)  # PickupDrop, Noop
obj_type = jnp.zeros((7,7), dtype=jnp.int32)
obj_state = jnp.zeros((7,7), dtype=jnp.int32)
pot_contents = jnp.full((1,3), -1, dtype=jnp.int32)
pot_timer = jnp.zeros(1, dtype=jnp.int32)
pot_positions = jnp.array([[2,3]], dtype=jnp.int32)

fn = jax.jit(process_interactions_jax, static_argnames=['action_pickup_drop_idx', 'action_toggle_idx'])
result = fn(
    agent_pos, agent_dir, agent_inv, actions,
    obj_type, obj_state, tables, scope_config,
    dir_vec, 4, 5,
    pot_contents=pot_contents, pot_timer=pot_timer, pot_positions=pot_positions,
)
print(f'result shapes: inv={result[0].shape}, otm={result[1].shape}')
print('JAX interactions JIT: PASSED')
"
```
  </verify>
  <done>process_interactions_jax() exists alongside process_interactions_array(). Uses lax.fori_loop for agent processing. Toggle action dispatches via jax.lax.switch on object type ID. All mutations use .at[].set() and jnp.where. Pot position lookup uses array matching. JIT-compiles without error for both Overcooked and generic scopes.</done>
</task>

</tasks>

<verification>
1. `overcooked_tick_jax` JIT-compiles and produces correct timer decrement
2. `process_interactions_jax` JIT-compiles without ConcretizationTypeError
3. Toggle action dispatches via `jax.lax.switch` on `fwd_type` -- no Python isinstance or if/elif chain on traced type IDs
4. All array mutations in JAX path use `.at[].set()` (no direct assignment)
5. No `int()` calls on traced values in JAX path
6. No Python dict lookups with traced keys in JAX path
7. All existing numpy-path functions completely unchanged
8. Scope config provides JAX-specific entries (`interaction_body_jax`, `tick_handler_jax`, `static_tables`, `toggle_branches_jax`)
</verification>

<success_criteria>
- `jax.jit(process_interactions_jax)(...)` executes without error for Overcooked scope
- Toggle action dispatches via `jax.lax.switch` on object type ID (requirement INTR-03)
- All 16 PHASE2 markers from interactions.py and array_config.py have JAX-path equivalents
- No Python callbacks used in JIT-compiled code
- Pot position lookup uses array-based matching instead of dict
- Existing numpy code completely unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/02-functional-state-model-jit-compatibility/02-02-SUMMARY.md`
</output>

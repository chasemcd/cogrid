---
phase: 02-functional-state-model-jit-compatibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cogrid/backend/env_state.py
  - cogrid/core/movement.py
autonomous: true

must_haves:
  truths:
    - "EnvState dataclass exists as a frozen dataclass with all fields as fixed-shape arrays and is registered as a JAX pytree"
    - "jax.jit(lambda s: s) round-trips an EnvState without error or shape change"
    - "move_agents_jax uses jax.random.split for PRNG instead of numpy.random.Generator"
    - "jax.jit(move_agents_jax)(state, actions) executes without ConcretizationTypeError"
    - "Collision resolution uses lax.fori_loop instead of Python for loop"
    - "Swap detection uses vectorized array comparison instead of nested Python loops"
    - "Existing numpy-path move_agents_array remains unchanged and passes existing tests"
  artifacts:
    - path: "cogrid/backend/env_state.py"
      provides: "EnvState frozen dataclass with pytree registration"
      contains: "class EnvState"
    - path: "cogrid/core/movement.py"
      provides: "JAX-path movement function alongside existing numpy path"
      contains: "move_agents_jax"
  key_links:
    - from: "cogrid/backend/env_state.py"
      to: "jax.tree_util.register_dataclass"
      via: "conditional registration when jax backend active"
      pattern: "register_dataclass"
    - from: "cogrid/core/movement.py"
      to: "cogrid/backend/env_state.py"
      via: "imports EnvState for type hints"
      pattern: "from cogrid.backend.env_state import EnvState"
---

<objective>
Define the EnvState immutable pytree dataclass and implement a JIT-compatible JAX-path movement function.

Purpose: EnvState is the foundation for all Phase 2 work -- every subsequent plan depends on it. Movement is the simplest sub-function to convert (only 2 PHASE2 markers) and provides immediate verification that EnvState + JIT works end-to-end.

Output: `cogrid/backend/env_state.py` with the EnvState class, and `move_agents_jax()` in `cogrid/core/movement.py` that JIT-compiles without error.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-functional-state-model-jit-compatibility/02-RESEARCH.md
@cogrid/backend/__init__.py
@cogrid/backend/_dispatch.py
@cogrid/core/movement.py
@cogrid/core/agent.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define EnvState frozen dataclass with conditional JAX pytree registration</name>
  <files>cogrid/backend/env_state.py</files>
  <action>
Create `cogrid/backend/env_state.py` with an immutable `EnvState` frozen dataclass.

**Fields (all dynamic -- JAX arrays when on jax backend, numpy arrays on numpy backend):**
- `agent_pos`: shape `(n_agents, 2)` int32
- `agent_dir`: shape `(n_agents,)` int32
- `agent_inv`: shape `(n_agents, 1)` int32, -1 sentinel for empty
- `wall_map`: shape `(H, W)` int32
- `object_type_map`: shape `(H, W)` int32
- `object_state_map`: shape `(H, W)` int32
- `pot_contents`: shape `(n_pots, 3)` int32, -1 sentinel
- `pot_timer`: shape `(n_pots,)` int32
- `pot_positions`: shape `(n_pots, 2)` int32 (NOTE: converting from Python list of tuples per research Pitfall 5)
- `rng_key`: shape `(2,)` uint32 -- JAX PRNG key (or None on numpy backend)
- `time`: shape `()` int32 -- scalar timestep

**Static fields (compile-time constants, not traced):**
- `n_agents`: int, `field(metadata=dict(static=True))`
- `height`: int, `field(metadata=dict(static=True))`
- `width`: int, `field(metadata=dict(static=True))`
- `n_pots`: int, `field(metadata=dict(static=True))`
- `action_set`: str, `field(metadata=dict(static=True))` -- "cardinal" or "rotation"

**Implementation details:**
1. Use `@dataclass(frozen=True)` from stdlib `dataclasses`
2. Do NOT import JAX at module level. The class definition must work without JAX installed.
3. Provide a module-level function `register_envstate_pytree()` that imports `jax.tree_util.register_dataclass` and calls it on `EnvState`. This function should be idempotent (safe to call multiple times).
4. Provide a convenience function `create_env_state(**kwargs) -> EnvState` that creates an EnvState from keyword arguments, calling `register_envstate_pytree()` first if the backend is 'jax'.
5. The class must work as a plain data container on numpy backend (no JAX dependency).
6. Add a `replace(**kwargs) -> EnvState` convenience method or use `dataclasses.replace()` -- document which to use.

**Test at the bottom of the file (guarded by `if __name__ == "__main__"`):**
```python
# Quick smoke test
import numpy as np
state = EnvState(
    agent_pos=np.zeros((2, 2), dtype=np.int32),
    agent_dir=np.zeros(2, dtype=np.int32),
    agent_inv=np.full((2, 1), -1, dtype=np.int32),
    wall_map=np.zeros((7, 7), dtype=np.int32),
    object_type_map=np.zeros((7, 7), dtype=np.int32),
    object_state_map=np.zeros((7, 7), dtype=np.int32),
    pot_contents=np.full((1, 3), -1, dtype=np.int32),
    pot_timer=np.zeros(1, dtype=np.int32),
    pot_positions=np.zeros((1, 2), dtype=np.int32),
    rng_key=None,
    time=np.int32(0),
    n_agents=2, height=7, width=7, n_pots=1, action_set="cardinal",
)
print(f"EnvState created: {state.n_agents} agents, {state.height}x{state.width} grid")
```
  </action>
  <verify>
Run `python cogrid/backend/env_state.py` -- smoke test prints without error.
Then test JAX pytree registration:
```python
python -c "
from cogrid.backend import set_backend
set_backend('jax')
import jax
import jax.numpy as jnp
from cogrid.backend.env_state import EnvState, register_envstate_pytree
register_envstate_pytree()
state = EnvState(
    agent_pos=jnp.zeros((2,2), dtype=jnp.int32),
    agent_dir=jnp.zeros(2, dtype=jnp.int32),
    agent_inv=jnp.full((2,1), -1, dtype=jnp.int32),
    wall_map=jnp.zeros((7,7), dtype=jnp.int32),
    object_type_map=jnp.zeros((7,7), dtype=jnp.int32),
    object_state_map=jnp.zeros((7,7), dtype=jnp.int32),
    pot_contents=jnp.full((1,3), -1, dtype=jnp.int32),
    pot_timer=jnp.zeros(1, dtype=jnp.int32),
    pot_positions=jnp.zeros((1,2), dtype=jnp.int32),
    rng_key=jax.random.key(42),
    time=jnp.int32(0),
    n_agents=2, height=7, width=7, n_pots=1, action_set='cardinal',
)
out = jax.jit(lambda s: s)(state)
assert jnp.array_equal(state.agent_pos, out.agent_pos)
assert state.n_agents == out.n_agents
print('JAX pytree round-trip: PASSED')
"
```
  </verify>
  <done>EnvState frozen dataclass exists. Works as plain container on numpy. Registers as JAX pytree and round-trips through jax.jit without error.</done>
</task>

<task type="auto">
  <name>Task 2: Implement JAX-path movement function with lax.fori_loop collision and vectorized swap</name>
  <files>cogrid/core/movement.py</files>
  <action>
Add a new function `move_agents_jax()` to `cogrid/core/movement.py`, alongside the existing `move_agents_array()` which remains completely unchanged.

**Function signature:**
```python
def move_agents_jax(
    agent_pos,        # (n_agents, 2) int32
    agent_dir,        # (n_agents,) int32
    actions,          # (n_agents,) int32
    wall_map,         # (H, W) int32
    object_type_map,  # (H, W) int32
    can_overlap,      # (n_types,) int32
    rng_key,          # JAX PRNG key
    action_set,       # str -- "cardinal" or "rotation" (static, not traced)
):
```

**Returns:** `(new_pos, new_dir, new_rng_key)` -- the new PRNG key is returned because the function consumes a subkey for the priority permutation.

**Implementation (follow research patterns exactly):**

1. **Action-to-direction mapping (steps 1-5 from existing):** Same array logic as `move_agents_array` but using `jnp` ops. The `action_set` parameter is a Python string checked at trace time (it is a static compile-time constant), so a normal Python `if action_set == "cardinal":` is fine (JAX recompiles per distinct static value).

2. **Proposed positions, bounds clipping, wall check, overlap check:** Same vectorized ops as existing, but no `.copy()` (JAX arrays are immutable). Use `jnp.clip`, `jnp.where`.

3. **PRNG key split for priority:**
```python
key, subkey = jax.random.split(rng_key)
priority = jax.random.permutation(subkey, n_agents)
```

4. **Collision resolution via `lax.fori_loop`** (replaces Python for loop at lines 147-175):
Follow research Pattern 3 exactly. The carry state is `(final_pos, resolved)`. The loop body:
- Gets `idx = priority[i]`
- Checks conflicts with resolved positions via vectorized `jnp.any(jnp.all(final_pos == attempted[None, :], axis=1) & resolved)`
- Checks conflicts with unresolved current positions via `jnp.any(jnp.all(agent_pos == attempted[None, :], axis=1) & is_other & ~resolved)`
- Uses `jnp.where(blocked, agent_pos[idx], attempted)` to compute new position
- Updates `final_pos = final_pos.at[idx].set(new_pos)` and `resolved = resolved.at[idx].set(True)`
NOTE: `priority` and `agent_pos` and `proposed` must be accessible inside the body. Since `lax.fori_loop` only allows `(lower, upper, body_fn, init_carry)`, these are accessed via closure over the enclosing scope (this is fine -- JAX traces closures correctly as long as the closed-over values are arrays, not Python containers).

5. **Vectorized swap detection** (replaces nested loop at lines 181-188):
Follow research Pattern 4:
```python
moved_to_old = jnp.all(final_pos[:, None, :] == agent_pos[None, :, :], axis=2)
swapped = moved_to_old & moved_to_old.T
swapped = swapped & ~jnp.eye(n_agents, dtype=jnp.bool_)
any_swap = jnp.any(swapped, axis=1)
final_pos = jnp.where(any_swap[:, None], agent_pos, final_pos)
```

6. **Return:** `(final_pos, new_dir, key)`

**Critical: Do NOT modify `move_agents_array` in any way.** The numpy path must remain exactly as-is.

**Verification test at the bottom (append to existing `test_movement_parity`):**
Add a new function `test_movement_jax()` that:
1. Sets backend to 'jax'
2. Creates a small test case with 2 agents
3. Calls `jax.jit(move_agents_jax)` with known inputs
4. Verifies the output shapes and that no ConcretizationTypeError occurs
5. Tests that the PRNG key was consumed (new key differs from input)
  </action>
  <verify>
Run the JAX movement JIT test:
```python
python -c "
from cogrid.backend import set_backend
set_backend('jax')
import jax
import jax.numpy as jnp
from cogrid.core.movement import move_agents_jax

key = jax.random.key(42)
agent_pos = jnp.array([[1,1],[3,3]], dtype=jnp.int32)
agent_dir = jnp.array([0, 2], dtype=jnp.int32)
actions = jnp.array([3, 2], dtype=jnp.int32)  # MoveRight, MoveLeft
wall_map = jnp.zeros((5,5), dtype=jnp.int32)
obj_map = jnp.zeros((5,5), dtype=jnp.int32)
can_overlap = jnp.ones(10, dtype=jnp.int32)

jitted = jax.jit(move_agents_jax, static_argnames=['action_set'])
new_pos, new_dir, new_key = jitted(agent_pos, agent_dir, actions, wall_map, obj_map, can_overlap, key, 'cardinal')
print(f'new_pos: {new_pos}')
print(f'new_dir: {new_dir}')
assert new_pos.shape == (2, 2)
assert new_dir.shape == (2,)
print('JAX movement JIT: PASSED')
"
```
Also verify existing numpy tests still pass by running any existing test suite.
  </verify>
  <done>move_agents_jax() exists alongside move_agents_array(). It JIT-compiles without error. Uses lax.fori_loop for collision resolution, vectorized swap detection, and jax.random.split for PRNG. Existing numpy path is completely unchanged.</done>
</task>

</tasks>

<verification>
1. `python cogrid/backend/env_state.py` runs without error (numpy smoke test)
2. JAX pytree round-trip test passes (EnvState through jax.jit)
3. `jax.jit(move_agents_jax)` executes without ConcretizationTypeError
4. Collision resolution uses `lax.fori_loop` (no Python for loop in JAX path)
5. Swap detection is vectorized (no Python nested loop in JAX path)
6. PRNG key threading works (input key consumed, new key returned)
7. Existing `move_agents_array` is completely untouched
</verification>

<success_criteria>
- EnvState frozen dataclass exists in `cogrid/backend/env_state.py` with all required fields
- `jax.jit(lambda s: s)(state)` round-trips an EnvState without error
- `jax.jit(move_agents_jax)(state, actions)` executes without ConcretizationTypeError
- No PHASE2 markers remain in the JAX path of movement.py
- Existing numpy code unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/02-functional-state-model-jit-compatibility/02-01-SUMMARY.md`
</output>

---
phase: 01-framework-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - cogrid/core/grid_object.py
autonomous: true

must_haves:
  truths:
    - "Developer can read docstring and understand when to implement get_extra_state"
    - "Developer can see example implementations referenced in docstring"
    - "Documentation explains recursive serialization for nested objects"
  artifacts:
    - path: "cogrid/core/grid_object.py"
      provides: "Enhanced docstrings for serialization pattern"
      contains: "When to implement"
  key_links:
    - from: "GridObj.get_extra_state docstring"
      to: "Counter.get_extra_state"
      via: "see also reference"
      pattern: "See.*Counter"
---

<objective>
Document the serialization pattern for future object authors in the GridObj base class docstrings.

Purpose: Enable developers to correctly implement serialization for new object types (FRAM-03 requirement).
Output: Enhanced docstrings in grid_object.py explaining when and how to implement get_extra_state/set_extra_state.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-framework-foundation/01-RESEARCH.md

# Summaries from prior plans (needed for examples to reference)
@.planning/phases/01-framework-foundation/01-01-SUMMARY.md
@.planning/phases/01-framework-foundation/01-02-SUMMARY.md

# Files to modify
@cogrid/core/grid_object.py (lines 236-275 for base class methods)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance get_extra_state docstring</name>
  <files>cogrid/core/grid_object.py</files>
  <action>
Locate the `get_extra_state` method in the base `GridObj` class (around line 236).

Replace/enhance the docstring to include comprehensive documentation:

```python
def get_extra_state(self, scope: str = "global") -> dict | None:
    """Serialize any internal state beyond the basic `state` integer.

    Override this method when your GridObj subclass has internal state that:
    1. Cannot be reconstructed from the `state` integer alone
    2. Changes during environment execution (not just class constants)
    3. Affects object behavior (not just rendering)

    When to implement:
    - Object holds other objects (like Counter.obj_placed_on, Pot.objects_in_pot)
    - Object has counters/timers (like RedVictim.toggle_countdown)
    - Object has dynamic flags not encoded in `state` int

    When NOT to implement:
    - Object has only class-level constants (color, char, object_id)
    - Object's state is fully captured by `self.state` integer
    - Object's attributes are derived from `state` in __init__ (like Door.is_open)

    For nested objects, serialize recursively::

        def get_extra_state(self, scope: str = "global") -> dict | None:
            if self.held_object is None:
                return None
            return {
                "held_object": {
                    "object_id": self.held_object.object_id,
                    "state": self.held_object.state,
                    "extra_state": self.held_object.get_extra_state(scope),
                }
            }

    :param scope: The object registry scope for serialization (e.g., "global",
                  "overcooked", "search_rescue"). Pass through to nested objects.
    :type scope: str
    :return: Dictionary of extra state, or None if no extra state exists.
    :rtype: dict | None

    Example implementations:
        - Counter: Serializes obj_placed_on with full recursive state
        - Pot: Serializes objects_in_pot list and cooking_timer
        - RedVictim: Serializes toggle_countdown and first_toggle_agent_id

    See Also:
        - :meth:`set_extra_state`: Restore state from this dict
        - :meth:`Counter.get_extra_state`: Example with nested object
        - :meth:`Pot.get_extra_state`: Example with object list
    """
    return None
```

Preserve the existing method body (`return None`).
  </action>
  <verify>
Read the modified docstring and verify it includes:
1. "When to implement" section with examples
2. "When NOT to implement" section
3. Code example for nested objects
4. References to Counter and Pot implementations
  </verify>
  <done>
get_extra_state has comprehensive docstring explaining when and how to implement serialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance set_extra_state docstring</name>
  <files>cogrid/core/grid_object.py</files>
  <action>
Locate the `set_extra_state` method in the base `GridObj` class (around line 256).

Replace/enhance the docstring:

```python
def set_extra_state(self, state_dict: dict, scope: str = "global") -> None:
    """Restore internal state from a dictionary produced by get_extra_state().

    Override this method alongside get_extra_state() to restore any internal
    state that was serialized. The state_dict will be exactly what get_extra_state()
    returned.

    Implementation checklist:
    1. Check if state_dict is not None/empty before accessing
    2. Use .get() with defaults for optional fields
    3. For nested objects, use make_object() to reconstruct::

        from cogrid.core.grid_object import make_object

        def set_extra_state(self, state_dict: dict, scope: str = "global") -> None:
            if state_dict and "held_object" in state_dict:
                obj_data = state_dict["held_object"]
                self.held_object = make_object(
                    obj_data["object_id"],
                    state=obj_data["state"],
                    scope=scope
                )
                if obj_data["extra_state"]:
                    self.held_object.set_extra_state(obj_data["extra_state"], scope)

    Important:
    - Always pass `scope` through recursive calls to maintain registry context
    - Import make_object locally to avoid circular imports
    - Handle None values gracefully for optional state fields

    :param state_dict: The dictionary returned by get_extra_state(). May be None.
    :type state_dict: dict
    :param scope: The object registry scope for deserialization.
    :type scope: str

    Example implementations:
        - Counter: Reconstructs obj_placed_on from nested state
        - Pot: Reconstructs objects_in_pot list and restores cooking_timer
        - RedVictim: Restores toggle_countdown and first_toggle_agent_id

    See Also:
        - :meth:`get_extra_state`: Produces the dict this method consumes
        - :func:`make_object`: Factory function for object reconstruction
    """
    pass
```

Preserve the existing method body (`pass`).
  </action>
  <verify>
Read the modified docstring and verify it includes:
1. Implementation checklist
2. Code example for nested object reconstruction
3. Important notes about scope and circular imports
4. References to make_object and example implementations
  </verify>
  <done>
set_extra_state has comprehensive docstring explaining how to restore serialized state.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add module-level serialization documentation</name>
  <files>cogrid/core/grid_object.py</files>
  <action>
At the top of grid_object.py, after the imports but before the first class/function definition, add a module-level docstring section or comment block about serialization.

If there's already a module docstring, add a "Serialization" section to it. If not, add documentation in a way that fits the existing style.

Content to add:

```python
# Serialization Pattern
# ====================
# GridObj supports state serialization via get_extra_state()/set_extra_state().
#
# The base GridObj.state integer is automatically serialized by the Grid class.
# Subclasses with additional internal state should override these methods.
#
# Quick reference:
#   - Stateless objects (Wall, Floor, Onion): No override needed
#   - State-from-integer objects (Door): No override needed if __init__ derives all state
#   - Objects with extra attributes: Override both methods
#   - Objects containing other objects: Use recursive serialization pattern
#
# Run `python -m cogrid.scripts.audit_serialization` to see which objects need work.
```

Place this documentation where it will be visible to developers browsing the file.
  </action>
  <verify>
Read the top of grid_object.py and verify the serialization documentation is present and readable.
  </verify>
  <done>
Module-level documentation exists explaining the serialization pattern and referencing the audit script.
  </done>
</task>

</tasks>

<verification>
1. get_extra_state docstring includes "When to implement" and examples
2. set_extra_state docstring includes implementation checklist and code example
3. Module-level documentation mentions audit script
4. Documentation references concrete implementations (Counter, Pot, RedVictim)
</verification>

<success_criteria>
- Developer reading grid_object.py can understand:
  - When they need to implement serialization (vs when not needed)
  - How to implement recursive serialization for nested objects
  - Where to find example implementations
- Documentation references the audit script for discovering missing implementations
</success_criteria>

<output>
After completion, create `.planning/phases/01-framework-foundation/01-03-SUMMARY.md`
</output>

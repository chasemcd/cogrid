---
phase: 05-foundation-state-model-backend-helpers
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - cogrid/core/scope_config.py
  - cogrid/core/layout_parser.py
  - cogrid/envs/overcooked/__init__.py
  - cogrid/envs/overcooked/array_config.py
autonomous: true

must_haves:
  truths:
    - "scope_config supports extra_state_schema and extra_state_builder keys"
    - "Overcooked scope config declares extra_state schema with overcooked.pot_contents, overcooked.pot_timer, overcooked.pot_positions"
    - "Layout parser converts ASCII layout directly into arrays without creating Grid or Agent objects"
    - "Overcooked layout (cramped_room) parses into fully populated EnvState with correct extra_state"
    - "Parser uses scope-registered symbol table for character-to-meaning mappings"
  artifacts:
    - path: "cogrid/core/layout_parser.py"
      provides: "Array-based layout parser with symbol registry"
      exports: ["register_symbols", "get_symbols", "parse_layout"]
    - path: "cogrid/core/scope_config.py"
      provides: "Updated scope config with extra_state_schema and extra_state_builder support"
    - path: "cogrid/envs/overcooked/__init__.py"
      provides: "Overcooked symbol registration and extra_state schema/builder in scope config"
    - path: "cogrid/envs/overcooked/array_config.py"
      provides: "build_overcooked_extra_state function and updated scope config builder"
  key_links:
    - from: "cogrid/core/layout_parser.py"
      to: "cogrid/core/scope_config.py"
      via: "parse_layout reads symbol_table and extra_state_builder from scope_config"
      pattern: "scope_config\\[.symbol_table.\\]|scope_config\\.get\\(.extra_state_builder.\\)"
    - from: "cogrid/envs/overcooked/__init__.py"
      to: "cogrid/core/layout_parser.py"
      via: "Overcooked registers symbols via register_symbols or scope_config symbol_table"
      pattern: "symbol_table|register_symbols"
    - from: "cogrid/core/layout_parser.py"
      to: "cogrid/backend/env_state.py"
      via: "parse_layout creates and returns EnvState with extra_state"
      pattern: "create_env_state|EnvState"
---

<objective>
Build the layout parser and scope config extensions so that Overcooked layouts parse from ASCII directly into array-based EnvState with populated extra_state -- no Grid or Agent objects involved.

Purpose: This completes success criteria 1 (Overcooked extra_state populated at init) and 4 (layout parses without Grid/Agent objects). Together with Plan 01, the entire Phase 5 data layer is functional.
Output: layout_parser.py (NEW), scope_config.py (MODIFIED), overcooked __init__.py and array_config.py (MODIFIED with symbol table + extra_state builder)
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-foundation-state-model-backend-helpers/05-RESEARCH.md
@.planning/phases/05-foundation-state-model-backend-helpers/05-01-SUMMARY.md

@cogrid/core/scope_config.py
@cogrid/core/grid_object.py
@cogrid/core/layouts.py
@cogrid/backend/env_state.py
@cogrid/backend/array_ops.py
@cogrid/envs/overcooked/__init__.py
@cogrid/envs/overcooked/array_config.py
@cogrid/envs/overcooked/overcooked_grid_objects.py
@cogrid/envs/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend scope_config and create layout_parser.py</name>
  <files>cogrid/core/scope_config.py, cogrid/core/layout_parser.py</files>
  <action>
**A) Update `cogrid/core/scope_config.py`:**

Add `extra_state_schema`, `extra_state_builder`, and `symbol_table` to `default_scope_config()`:

```python
def default_scope_config() -> dict:
    return {
        "interaction_tables": None,
        "type_ids": {},
        "state_extractor": None,
        "interaction_handler": None,
        "tick_handler": None,
        "place_on_handlers": {},
        # v1.1 additions
        "symbol_table": {},           # char -> {"object_id": str, "is_wall": bool, "is_spawn": bool, ...}
        "extra_state_schema": {},     # key -> {"shape": tuple, "dtype": str}
        "extra_state_builder": None,  # callable(parsed_arrays, scope) -> dict
    }
```

No other changes to scope_config.py. The symbol_table key follows the research recommendation of folding symbol mappings into scope_config rather than a separate registry module.

**B) Create `cogrid/core/layout_parser.py`:**

This module provides the array-based layout parser. Per user decision: "Parser is a module with a registry where environments register their symbol mappings" and "Parser outputs a fully initialized EnvState". Per research recommendation: "Parse with numpy always (layouts are small, init-time only), then convert to JAX arrays when building EnvState on JAX backend."

Implement:

1. `SYMBOL_REGISTRY: dict[str, dict[str, dict]]` -- module-level registry mapping scope -> char -> properties dict.

2. `register_symbols(scope, symbols)` -- registers symbol mappings for a scope. Each symbol maps a char to a dict like `{"object_id": "wall", "is_wall": True, "is_spawn": False}`.

3. `get_symbols(scope)` -- returns symbol mappings for a scope (also checks scope_config's symbol_table as fallback).

4. `parse_layout(layout_strings, scope, scope_config, n_agents=2, action_set="cardinal")`:
   - Parse using numpy ALWAYS (init-time only). Import numpy directly, not `xp`.
   - Iterate over layout_strings (list of strings, each string is a row).
   - For each char, look up in symbols: map to object_type_map, wall_map, and collect spawn_positions for '+' chars.
   - Use `cogrid.core.grid_object.object_to_idx(object_id, scope=scope)` to get integer type IDs.
   - After grid parsing, call `extra_state_builder(parsed_arrays, scope)` from scope_config if present, else set extra_state to empty dict.
   - Validate extra_state against schema via `validate_extra_state()` from env_state.py.
   - Convert all arrays to backend arrays if JAX backend is active: `if get_backend() == "jax": import jax.numpy as jnp; arr = jnp.array(arr)`.
   - Build and return a fully initialized EnvState via `create_env_state()`.
   - Assign agent positions from spawn_positions (first n_agents spawn points).
   - Initialize agent_dir to zeros, agent_inv to -1 sentinel, time to 0.
   - Set rng_key to None for numpy, or caller provides one for JAX.

Key design details:
- IMPORTANT: `+` chars represent spawn positions. They are NOT placed in object_type_map (cell stays 0/empty). They are collected into spawn_positions list.
- ` ` (space) chars represent free space -- cell stays 0 in object_type_map.
- `#` is wall: set object_type_map to wall type_id AND wall_map to 1.
- All other chars: look up in symbol table, set object_type_map to corresponding type_id.
- The function does NOT create any Grid, GridObj, or Agent objects. This is the whole point.
- Layout parsing uses Python loops over the ASCII grid -- this is fine because it only runs once at init time, not during stepping.
  </action>
  <verify>
Run: `python -c "from cogrid.core.layout_parser import register_symbols, get_symbols, parse_layout; print('layout_parser imports OK')"` -- should succeed.
Run: `python -c "from cogrid.core.scope_config import default_scope_config; cfg = default_scope_config(); assert 'symbol_table' in cfg; assert 'extra_state_schema' in cfg; assert 'extra_state_builder' in cfg; print('scope_config OK')"` -- should succeed.
  </verify>
  <done>layout_parser.py exists with register_symbols, get_symbols, and parse_layout. scope_config.py default includes symbol_table, extra_state_schema, extra_state_builder keys. parse_layout returns EnvState without creating Grid/Agent objects.</done>
</task>

<task type="auto">
  <name>Task 2: Register Overcooked symbols, schema, and extra_state builder</name>
  <files>cogrid/envs/overcooked/array_config.py, cogrid/envs/overcooked/__init__.py</files>
  <action>
**A) Add extra_state builder to `cogrid/envs/overcooked/array_config.py`:**

Add a new function `build_overcooked_extra_state(parsed_arrays, scope="overcooked")`:

```python
def build_overcooked_extra_state(parsed_arrays, scope="overcooked"):
    """Build extra_state dict for Overcooked from parsed layout arrays.

    Called by layout parser when scope='overcooked'. Finds pot positions
    from object_type_map and creates the pot state arrays.

    Args:
        parsed_arrays: Dict with "object_type_map" and other grid arrays.
        scope: Scope name for type ID lookups.

    Returns:
        Dict with scope-prefixed keys: overcooked.pot_contents,
        overcooked.pot_timer, overcooked.pot_positions.
    """
    import numpy as _np
    from cogrid.core.grid_object import object_to_idx

    pot_type_id = object_to_idx("pot", scope=scope)
    otm = parsed_arrays["object_type_map"]

    # Find pot positions from object_type_map
    pot_mask = (otm == pot_type_id)
    pot_positions_list = list(zip(*_np.where(pot_mask)))  # list of (row, col)
    n_pots = len(pot_positions_list)

    if n_pots > 0:
        pot_positions = _np.array(pot_positions_list, dtype=_np.int32)
        pot_contents = _np.full((n_pots, 3), -1, dtype=_np.int32)
        pot_timer = _np.full((n_pots,), 30, dtype=_np.int32)
    else:
        pot_positions = _np.zeros((0, 2), dtype=_np.int32)
        pot_contents = _np.full((0, 3), -1, dtype=_np.int32)
        pot_timer = _np.zeros((0,), dtype=_np.int32)

    return {
        "overcooked.pot_contents": pot_contents,
        "overcooked.pot_timer": pot_timer,
        "overcooked.pot_positions": pot_positions,
    }
```

Always use numpy here (init-time only). The layout parser handles JAX conversion after.

**B) Update `build_overcooked_scope_config()` in array_config.py:**

Add the new v1.1 keys to the returned dict:

```python
# In build_overcooked_scope_config(), add to the return dict:
"symbol_table": {
    "#": {"object_id": "wall", "is_wall": True},
    "C": {"object_id": "counter"},
    "U": {"object_id": "pot"},
    "O": {"object_id": "onion_stack"},
    "=": {"object_id": "plate_stack"},
    "@": {"object_id": "delivery_zone"},
    "+": {"object_id": None, "is_spawn": True},
    " ": {"object_id": None},
},
"extra_state_schema": {
    "overcooked.pot_contents": {"shape": ("n_pots", 3), "dtype": "int32"},
    "overcooked.pot_timer": {"shape": ("n_pots",), "dtype": "int32"},
    "overcooked.pot_positions": {"shape": ("n_pots", 2), "dtype": "int32"},
},
"extra_state_builder": build_overcooked_extra_state,
```

The symbol chars match the existing Overcooked grid objects: `#`=wall, `C`=counter, `U`=pot (char from overcooked_grid_objects.py), `O`=onion_stack, `=`=plate_stack, `@`=delivery_zone, `+`=spawn, ` `=free space.

**C) Update `cogrid/envs/overcooked/__init__.py`:**

After the existing `register_scope_config` call, optionally also call `register_symbols` from layout_parser if the symbol registry approach is used. However, since the symbol_table is now inside scope_config, and parse_layout reads it from scope_config, no additional registration is strictly needed. The __init__.py can stay minimal.

If the layout_parser's `get_symbols()` function checks the scope_config's symbol_table key, then no changes to __init__.py are needed beyond the existing `register_scope_config` call. Verify this is the case.

If `register_symbols` from layout_parser is also used as a separate registry (for cases where scope_config may not be loaded yet), add:

```python
from cogrid.core.layout_parser import register_symbols

register_symbols("overcooked", {
    "#": {"object_id": "wall", "is_wall": True},
    "C": {"object_id": "counter"},
    "U": {"object_id": "pot"},
    "O": {"object_id": "onion_stack"},
    "=": {"object_id": "plate_stack"},
    "@": {"object_id": "delivery_zone"},
    "+": {"object_id": None, "is_spawn": True},
    " ": {"object_id": None},
})
```

Use your judgment on whether both registrations are needed or just the scope_config approach suffices.
  </action>
  <verify>
Run an end-to-end parse test:

```bash
python -c "
import cogrid.envs.overcooked.overcooked_grid_objects  # register object types
import cogrid.envs.overcooked  # register scope config

from cogrid.core.scope_config import get_scope_config
from cogrid.core.layout_parser import parse_layout
from cogrid.backend.env_state import get_extra

# cramped_room layout
layout = [
    '#######',
    '#CCUCC#',
    '#O   O#',
    '#C   C#',
    '#C=C@C#',
    '######',
]

# Fix: cramped_room is 7 wide, 6 tall
layout = [
    '#######',
    '#CCUCC#',
    '#O   O#',
    '#C   C#',
    '#C=C@C#',
    '#######',
]

scope_config = get_scope_config('overcooked')
state = parse_layout(layout, 'overcooked', scope_config)

# Verify EnvState fields
assert state.wall_map.shape == (6, 7), f'wall_map shape: {state.wall_map.shape}'
assert state.object_type_map.shape == (6, 7)
assert state.extra_state is not None

# Verify extra_state has pot arrays
pot_pos = get_extra(state, 'pot_positions', scope='overcooked')
pot_contents = get_extra(state, 'pot_contents', scope='overcooked')
pot_timer = get_extra(state, 'pot_timer', scope='overcooked')
assert pot_pos.shape[0] == 1, f'Expected 1 pot, got {pot_pos.shape[0]}'  # cramped_room has 1 pot (U)
assert pot_contents.shape == (1, 3)
assert pot_timer.shape == (1,)

# Verify no Grid/Agent objects were created (we never imported Grid/Agent)
print('Layout parser end-to-end OK')
print(f'  Grid: {state.height}x{state.width}')
print(f'  Pots: {pot_pos.shape[0]} at positions {pot_pos}')
print(f'  Agent pos: {state.agent_pos}')
"
```

This should succeed with correct grid dimensions and pot detection.
  </verify>
  <done>Overcooked symbol table registered in scope config. Extra_state_schema and extra_state_builder added to Overcooked scope config. parse_layout successfully converts cramped_room ASCII layout into EnvState with extra_state containing overcooked.pot_contents, overcooked.pot_timer, overcooked.pot_positions -- no Grid or Agent objects created.</done>
</task>

</tasks>

<verification>
1. `parse_layout()` returns an EnvState with correct grid dimensions for cramped_room (6x7)
2. `get_extra(state, 'pot_contents', scope='overcooked')` returns correct shape (n_pots, 3)
3. Wall positions in wall_map match '#' characters in layout
4. Pot positions in extra_state match 'U' characters in layout
5. Spawn positions match '+' characters (none in cramped_room, so agents get default positions)
6. No GridObj, Grid, or Agent class instantiation occurs during parse_layout execution
</verification>

<success_criteria>
- layout_parser.py exists with parse_layout that returns EnvState directly from ASCII strings
- Overcooked scope config includes symbol_table, extra_state_schema, extra_state_builder
- cramped_room layout parses correctly with 1 pot detected, correct wall_map, and populated extra_state
- No Grid, GridObj, or Agent objects are created during parsing
</success_criteria>

<output>
After completion, create `.planning/phases/05-foundation-state-model-backend-helpers/05-02-SUMMARY.md`
</output>

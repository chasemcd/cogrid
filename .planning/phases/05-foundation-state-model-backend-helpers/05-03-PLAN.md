---
phase: 05-foundation-state-model-backend-helpers
plan: 03
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - cogrid/core/jax_step.py
autonomous: true

must_haves:
  truths:
    - "envstate_to_dict() includes extra_state dict in output"
    - "jax_step() reads pot state from extra_state via get_extra instead of direct state.pot_contents"
    - "jax_reset() builds EnvState with extra_state instead of pot_contents/pot_timer/pot_positions fields"
    - "EnvState with extra_state round-trips through jax.jit(lambda s: s) without error or shape change"
    - "jax_reset + jax_step compile and execute on JAX backend with the new EnvState"
  artifacts:
    - path: "cogrid/core/jax_step.py"
      provides: "Updated jax_step/jax_reset using extra_state instead of pot_* fields"
  key_links:
    - from: "cogrid/core/jax_step.py"
      to: "cogrid/backend/env_state.py"
      via: "imports get_extra, replace_extra, create_env_state"
      pattern: "from cogrid\\.backend\\.env_state import.*get_extra|replace_extra"
    - from: "cogrid/core/jax_step.py"
      to: "EnvState.extra_state"
      via: "dataclasses.replace uses extra_state dict"
      pattern: "extra_state"
---

<objective>
Update jax_step.py to use the new EnvState with extra_state dict, and verify that the full EnvState (including extra_state) round-trips through jax.jit without error. This satisfies success criteria 2 (set_at works on JAX) and 3 (JIT round-trip).

Purpose: The JAX execution path must work with the new data model. This is the integration proof that the Phase 5 data layer is complete and JIT-compatible.
Output: jax_step.py (MODIFIED), passing JIT round-trip test
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-foundation-state-model-backend-helpers/05-RESEARCH.md
@.planning/phases/05-foundation-state-model-backend-helpers/05-01-SUMMARY.md
@.planning/phases/05-foundation-state-model-backend-helpers/05-02-SUMMARY.md

@cogrid/core/jax_step.py
@cogrid/backend/env_state.py
@cogrid/backend/array_ops.py
@cogrid/core/layout_parser.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update jax_step.py for extra_state</name>
  <files>cogrid/core/jax_step.py</files>
  <action>
Update `cogrid/core/jax_step.py` to use the new EnvState with extra_state dict instead of direct pot_* fields. The changes are mechanical -- every reference to `state.pot_contents`, `state.pot_timer`, `state.pot_positions`, `state.n_pots` must be replaced.

**A) Update `envstate_to_dict()`:**

Replace the manual field mapping with one that includes extra_state:

```python
def envstate_to_dict(state) -> dict:
    """Convert an EnvState to the dict format used by sub-functions."""
    result = {
        "agent_pos": state.agent_pos,
        "agent_dir": state.agent_dir,
        "agent_inv": state.agent_inv,
        "wall_map": state.wall_map,
        "object_type_map": state.object_type_map,
        "object_state_map": state.object_state_map,
    }
    # Merge extra_state into the dict for backward compatibility
    # with sub-functions that expect pot_contents, pot_timer, pot_positions
    # as top-level keys. Strip the scope prefix for now.
    for key, val in state.extra_state.items():
        # "overcooked.pot_contents" -> "pot_contents"
        short_key = key.split(".", 1)[-1] if "." in key else key
        result[short_key] = val
    return result
```

This approach maintains backward compatibility: sub-functions in movement.py, interactions.py, array_rewards.py still expect `state_dict["pot_contents"]` etc. The scope prefix is stripped when flattening into the dict. This is a transitional pattern -- Phases 6-7 will unify these functions to use `get_extra()` directly.

**B) Update `jax_step()`:**

1. Replace `state.pot_contents` with `state.extra_state["overcooked.pot_contents"]` (or use get_extra from env_state). Since jax_step is traced, and dict key lookup is a Python-level operation (not traced), this works fine.

2. In the tick section (lines ~130-148): replace `state.pot_contents`, `state.pot_timer` references with extra_state lookups. Replace `state.n_pots` in the `lax.fori_loop` bound with `state.extra_state["overcooked.pot_positions"].shape[0]` (this is a compile-time constant since shape is fixed at init).

3. In the `dataclasses.replace` call after tick: replace `pot_contents=pot_contents, pot_timer=pot_timer` with building a new extra_state dict:
   ```python
   new_extra = {
       **state.extra_state,
       "overcooked.pot_contents": pot_contents,
       "overcooked.pot_timer": pot_timer,
   }
   state = dataclasses.replace(state, object_state_map=osm, extra_state=new_extra)
   ```

4. In the interactions section (lines ~166-193): replace `pot_contents=state.pot_contents, pot_timer=state.pot_timer, pot_positions=state.pot_positions` with extra_state lookups. After interactions, build new extra_state with updated pot_contents and pot_timer:
   ```python
   new_extra = {
       **state.extra_state,
       "overcooked.pot_contents": pc,
       "overcooked.pot_timer": pt,
   }
   state = dataclasses.replace(
       state,
       agent_inv=agent_inv,
       object_type_map=otm,
       object_state_map=osm,
       extra_state=new_extra,
       time=state.time + 1,
   )
   ```

**C) Update `jax_reset()`:**

1. Replace the extraction of `pot_contents`, `pot_timer`, `pot_positions` from `layout_arrays` with building an extra_state dict:
   ```python
   extra_state = {
       "overcooked.pot_contents": layout_arrays["pot_contents"],
       "overcooked.pot_timer": layout_arrays["pot_timer"],
       "overcooked.pot_positions": layout_arrays["pot_positions"],
   }
   ```

2. In `create_env_state()` call: remove `pot_contents`, `pot_timer`, `pot_positions`, `n_pots` kwargs. Add `extra_state=extra_state`.

**D) Update `make_jitted_step` and `make_jitted_reset`:**

No changes needed -- they just forward args to jax_step/jax_reset.

**E) Update the `if __name__ == "__main__"` smoke test:**

Update `layout_arrays` dict construction to match what the new code expects. The existing smoke test extracts pot arrays from `env._array_state` -- this will still work since the arrays themselves haven't changed, just where they live in EnvState. Make sure the layout_arrays dict still includes pot_contents, pot_timer, pot_positions as top-level keys (jax_reset reads them and puts them into extra_state).

IMPORTANT: This plan updates jax_step.py to work with the new EnvState. The sub-functions it calls (move_agents_jax, process_interactions_jax, compute_rewards_jax, overcooked_tick_jax, overcooked_interaction_body_jax) still expect pot arrays as direct arguments -- and jax_step extracts them from extra_state before passing. This is intentional: those functions get unified in Phases 6-7.
  </action>
  <verify>
Run the JIT round-trip test (success criterion 3):

```bash
python -c "
import jax
import jax.numpy as jnp
from cogrid.backend.env_state import register_envstate_pytree, create_env_state, get_extra
from cogrid.backend import set_backend
set_backend('jax')
register_envstate_pytree()

# Create EnvState with extra_state
state = create_env_state(
    agent_pos=jnp.zeros((2, 2), dtype=jnp.int32),
    agent_dir=jnp.zeros(2, dtype=jnp.int32),
    agent_inv=jnp.full((2, 1), -1, dtype=jnp.int32),
    wall_map=jnp.zeros((5, 5), dtype=jnp.int32),
    object_type_map=jnp.zeros((5, 5), dtype=jnp.int32),
    object_state_map=jnp.zeros((5, 5), dtype=jnp.int32),
    extra_state={
        'overcooked.pot_contents': jnp.full((1, 3), -1, dtype=jnp.int32),
        'overcooked.pot_timer': jnp.full((1,), 30, dtype=jnp.int32),
        'overcooked.pot_positions': jnp.zeros((1, 2), dtype=jnp.int32),
    },
    rng_key=jax.random.key(0),
    time=jnp.int32(0),
    n_agents=2,
    height=5,
    width=5,
    action_set='cardinal',
)

# Round-trip through jit
@jax.jit
def identity(s):
    return s

state2 = identity(state)

# Verify shapes match
assert state2.agent_pos.shape == state.agent_pos.shape
assert state2.wall_map.shape == state.wall_map.shape
pot_c = get_extra(state2, 'pot_contents', scope='overcooked')
assert pot_c.shape == (1, 3), f'pot_contents shape mismatch: {pot_c.shape}'
pot_t = get_extra(state2, 'pot_timer', scope='overcooked')
assert pot_t.shape == (1,), f'pot_timer shape mismatch: {pot_t.shape}'
print('JIT round-trip OK')
"
```

Also verify array_ops.set_at works on JAX (success criterion 2):

```bash
python -c "
from cogrid.backend import set_backend
set_backend('jax')
import jax.numpy as jnp
from cogrid.backend.array_ops import set_at, set_at_2d

a = jnp.zeros(5, dtype=jnp.int32)
b = set_at(a, 2, 99)
assert int(b[2]) == 99 and int(a[2]) == 0
m = jnp.zeros((3,3), dtype=jnp.int32)
n = set_at_2d(m, 1, 2, 42)
assert int(n[1,2]) == 42 and int(m[1,2]) == 0
print('JAX array_ops OK')
"
```
  </verify>
  <done>jax_step.py updated: envstate_to_dict flattens extra_state, jax_step reads/writes pot arrays via extra_state, jax_reset builds extra_state from layout_arrays. EnvState with extra_state round-trips through jax.jit without error. set_at/set_at_2d work on JAX backend.</done>
</task>

<task type="auto">
  <name>Task 2: End-to-end JAX integration smoke test</name>
  <files>cogrid/core/jax_step.py</files>
  <action>
Update the `if __name__ == "__main__"` block at the bottom of `cogrid/core/jax_step.py` to work with the new EnvState. The smoke test should:

1. Create the env using numpy backend (existing pattern).
2. Extract layout arrays from the numpy env's `_array_state`.
3. Build `layout_arrays` dict that includes pot arrays at top level (jax_reset reads them from there and places into extra_state).
4. Convert all arrays to JAX.
5. Run `jitted_reset` and `jitted_step`.
6. Verify shapes and that no errors occur.

Key changes from the existing smoke test:
- The `layout_arrays` dict format stays the same (pot_contents, pot_timer, pot_positions as keys) -- jax_reset handles putting them into extra_state.
- Assertions should check `state.extra_state` instead of `state.pot_contents`.
- Add an explicit JIT round-trip assertion after reset.

Run the updated smoke test to verify end-to-end JIT compilation works:

```bash
python cogrid/core/jax_step.py
```

This validates that jax_reset creates an EnvState with extra_state, jax_step reads/updates extra_state correctly, and the full step pipeline JIT-compiles end-to-end.

IMPORTANT: If the smoke test fails due to other modules (movement, interactions, rewards) that still reference old pot_* fields directly from state dicts, those failures are EXPECTED and should be noted. The jax_step.py code itself correctly uses extra_state -- the sub-functions it calls may need updates in Phases 6-7. Document any such failures in the SUMMARY.
  </action>
  <verify>
Run: `python cogrid/core/jax_step.py` -- should either pass completely or fail only in sub-functions that still expect old state format (document which ones).

Run the JIT round-trip test independently (does not depend on sub-functions):

```bash
python -c "
import jax
import jax.numpy as jnp
from cogrid.backend import set_backend
set_backend('jax')
from cogrid.backend.env_state import register_envstate_pytree, create_env_state, get_extra

register_envstate_pytree()

state = create_env_state(
    agent_pos=jnp.zeros((2, 2), dtype=jnp.int32),
    agent_dir=jnp.zeros(2, dtype=jnp.int32),
    agent_inv=jnp.full((2, 1), -1, dtype=jnp.int32),
    wall_map=jnp.zeros((7, 7), dtype=jnp.int32),
    object_type_map=jnp.zeros((7, 7), dtype=jnp.int32),
    object_state_map=jnp.zeros((7, 7), dtype=jnp.int32),
    extra_state={
        'overcooked.pot_contents': jnp.full((1, 3), -1, dtype=jnp.int32),
        'overcooked.pot_timer': jnp.full((1,), 30, dtype=jnp.int32),
        'overcooked.pot_positions': jnp.array([[1, 3]], dtype=jnp.int32),
    },
    rng_key=jax.random.key(42),
    time=jnp.int32(0),
    n_agents=2, height=7, width=7, action_set='cardinal',
)

# JIT round-trip
state2 = jax.jit(lambda s: s)(state)
assert state2.agent_pos.shape == (2, 2)
assert state2.wall_map.shape == (7, 7)
pc = get_extra(state2, 'pot_contents', scope='overcooked')
assert pc.shape == (1, 3)
pt = get_extra(state2, 'pot_timer', scope='overcooked')
assert int(pt[0]) == 30

# vmap round-trip (batch of 4)
batched_fn = jax.vmap(lambda s: s)
import jax.tree_util as jtu
batch = jtu.tree_map(lambda x: jnp.stack([x]*4), state)
batch_out = batched_fn(batch)
assert batch_out.agent_pos.shape == (4, 2, 2)
bpc = get_extra(batch_out, 'pot_contents', scope='overcooked')
assert bpc.shape == (4, 1, 3)

print('JIT + vmap round-trip PASSED')
"
```

This test MUST pass -- it is success criterion 3.
  </verify>
  <done>jax_step.py smoke test updated for extra_state. JIT round-trip test passes: EnvState with extra_state dict survives jax.jit and jax.vmap without error or shape change. vmap batching at batch_size=4 produces correct batched shapes for extra_state arrays.</done>
</task>

</tasks>

<verification>
1. `python -c "..."` JIT round-trip test: EnvState with extra_state passes through jax.jit(lambda s: s) preserving all shapes
2. `python -c "..."` vmap round-trip test: batched EnvState has correct shapes (batch_dim, ...)
3. `python -c "..."` JAX array_ops test: set_at and set_at_2d work on JAX arrays
4. envstate_to_dict correctly flattens extra_state keys (stripping scope prefix)
5. jax_step and jax_reset reference extra_state, not pot_contents/pot_timer/pot_positions directly on state
</verification>

<success_criteria>
- EnvState with extra_state round-trips through jax.jit without error or shape change (success criterion 3)
- EnvState with extra_state round-trips through jax.vmap without error
- set_at and set_at_2d work correctly on JAX backend (success criterion 2)
- jax_step.py references extra_state instead of direct pot_* fields
- envstate_to_dict merges extra_state into output dict for backward compatibility
</success_criteria>

<output>
After completion, create `.planning/phases/05-foundation-state-model-backend-helpers/05-03-SUMMARY.md`
</output>

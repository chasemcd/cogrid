---
phase: 05-foundation-state-model-backend-helpers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cogrid/backend/array_ops.py
  - cogrid/backend/env_state.py
  - cogrid/core/grid_object.py
  - cogrid/envs/overcooked/array_config.py
autonomous: true

must_haves:
  truths:
    - "set_at() and set_at_2d() correctly mutate arrays on both numpy and JAX backends"
    - "No hasattr(arr, 'at') checks exist anywhere in the codebase outside array_ops.py"
    - "EnvState has an extra_state dict field instead of pot_contents, pot_timer, pot_positions, n_pots"
    - "get_extra() and replace_extra() helpers provide clean access to scope-prefixed extra_state keys"
  artifacts:
    - path: "cogrid/backend/array_ops.py"
      provides: "Backend-aware array mutation helpers"
      exports: ["set_at", "set_at_2d"]
    - path: "cogrid/backend/env_state.py"
      provides: "Rewritten EnvState with extra_state dict field and access helpers"
      exports: ["EnvState", "create_env_state", "register_envstate_pytree", "get_extra", "replace_extra", "validate_extra_state"]
    - path: "cogrid/core/grid_object.py"
      provides: "build_lookup_tables using array_ops.set_at instead of hasattr checks"
    - path: "cogrid/envs/overcooked/array_config.py"
      provides: "_build_interaction_tables using array_ops.set_at instead of hasattr checks"
  key_links:
    - from: "cogrid/backend/array_ops.py"
      to: "cogrid/backend/_dispatch.get_backend"
      via: "import from _dispatch"
      pattern: "from cogrid\\.backend\\._dispatch import get_backend"
    - from: "cogrid/core/grid_object.py"
      to: "cogrid/backend/array_ops.py"
      via: "build_lookup_tables calls set_at"
      pattern: "from cogrid\\.backend\\.array_ops import set_at"
    - from: "cogrid/envs/overcooked/array_config.py"
      to: "cogrid/backend/array_ops.py"
      via: "_build_interaction_tables calls set_at"
      pattern: "from cogrid\\.backend\\.array_ops import set_at"
---

<objective>
Create the foundational data layer for unified functional code: the array mutation abstraction (array_ops.py), the rewritten EnvState with generic extra_state dict, and cleanup of all hasattr(arr, 'at') checks across the codebase.

Purpose: This is the base layer that all subsequent Phase 5 plans and Phases 6-9 build upon. Without array_ops.py and the new EnvState, no other work can proceed.
Output: array_ops.py (NEW), env_state.py (REWRITTEN), grid_object.py and array_config.py (hasattr cleanup)
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-foundation-state-model-backend-helpers/05-RESEARCH.md

@cogrid/backend/_dispatch.py
@cogrid/backend/__init__.py
@cogrid/backend/env_state.py
@cogrid/core/grid_object.py
@cogrid/envs/overcooked/array_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create array_ops.py and rewrite EnvState with extra_state</name>
  <files>cogrid/backend/array_ops.py, cogrid/backend/env_state.py</files>
  <action>
**A) Create `cogrid/backend/array_ops.py`** -- the ONLY module that branches on backend for mutation:

```python
"""Backend-aware array mutation helpers.

This is the ONLY module that branches on numpy vs JAX for mutation.
All other code uses `xp` for operations that work identically.
"""
from cogrid.backend._dispatch import get_backend


def set_at(arr, idx, value):
    """Return new array with arr[idx] = value.
    numpy: copies then assigns. JAX: uses .at[idx].set(value).
    """
    if get_backend() == "jax":
        return arr.at[idx].set(value)
    out = arr.copy()
    out[idx] = value
    return out


def set_at_2d(arr, row, col, value):
    """Return new array with arr[row, col] = value.
    numpy: copies then assigns. JAX: uses .at[row, col].set(value).
    """
    if get_backend() == "jax":
        return arr.at[row, col].set(value)
    out = arr.copy()
    out[row, col] = value
    return out
```

Use `get_backend()` string check per research recommendation (not `hasattr`). Import from `cogrid.backend._dispatch` (NOT `cogrid.backend`) to avoid circular imports.

**B) Rewrite `cogrid/backend/env_state.py`**:

1. Remove the 3 pot-specific dynamic fields: `pot_contents`, `pot_timer`, `pot_positions`
2. Remove the `n_pots` static field
3. Add `extra_state: object` dynamic field (dict[str, array], scope-specific)
4. Keep all other fields unchanged: agent_pos, agent_dir, agent_inv, wall_map, object_type_map, object_state_map, rng_key, time, n_agents, height, width, action_set
5. Keep `_pytree_registered` guard and `register_envstate_pytree()` unchanged (JAX pytree registration handles dict data fields natively)
6. Update `create_env_state()` -- no changes needed beyond the field removal (kwargs forwarded)
7. Update the module docstring to document extra_state semantics
8. Update the `if __name__ == "__main__"` smoke test to use extra_state dict instead of pot fields

Add helper functions for extra_state access (place these in env_state.py since they operate on EnvState):

```python
def get_extra(state, key, scope=None):
    """Get a value from state.extra_state with optional scope prefixing."""
    full_key = f"{scope}.{key}" if scope else key
    if full_key not in state.extra_state:
        raise KeyError(
            f"extra_state key '{full_key}' not found. "
            f"Available: {list(state.extra_state.keys())}"
        )
    return state.extra_state[full_key]


def replace_extra(state, key, value, scope=None):
    """Return new EnvState with one extra_state value replaced."""
    import dataclasses
    full_key = f"{scope}.{key}" if scope else key
    new_extra = {**state.extra_state, full_key: value}
    return dataclasses.replace(state, extra_state=new_extra)


def validate_extra_state(extra_state, schema):
    """Validate extra_state dict against a schema.

    Schema is a dict mapping key -> {"shape": tuple, "dtype": str}.
    Shape tuples may contain symbolic dims (strings) which are checked
    for dimensional consistency only (not exact value).

    Raises ValueError if validation fails.
    """
    for key, spec in schema.items():
        if key not in extra_state:
            raise ValueError(f"Missing required extra_state key: '{key}'")
        arr = extra_state[key]
        expected_ndim = len(spec["shape"])
        if len(arr.shape) != expected_ndim:
            raise ValueError(
                f"extra_state['{key}'] has {len(arr.shape)} dims, "
                f"expected {expected_ndim}"
            )
```

Per user decisions: keys are scope-prefixed ('overcooked.pot_contents'), helper function provides clean access, strict validation at init time.
  </action>
  <verify>
Run: `python -c "from cogrid.backend.array_ops import set_at, set_at_2d; print('array_ops OK')"` -- should succeed.
Run: `python -c "from cogrid.backend.env_state import EnvState, get_extra, replace_extra, validate_extra_state; print('env_state OK')"` -- should succeed.
Run: `python -c "
import numpy as np
from cogrid.backend.env_state import EnvState, get_extra, replace_extra
state = EnvState(
    agent_pos=np.zeros((2,2), dtype=np.int32),
    agent_dir=np.zeros(2, dtype=np.int32),
    agent_inv=np.full((2,1), -1, dtype=np.int32),
    wall_map=np.zeros((5,5), dtype=np.int32),
    object_type_map=np.zeros((5,5), dtype=np.int32),
    object_state_map=np.zeros((5,5), dtype=np.int32),
    extra_state={'overcooked.pot_timer': np.zeros(2, dtype=np.int32)},
    rng_key=None,
    time=np.int32(0),
)
v = get_extra(state, 'pot_timer', scope='overcooked')
assert v.shape == (2,), f'got {v.shape}'
state2 = replace_extra(state, 'pot_timer', np.ones(2, dtype=np.int32), scope='overcooked')
assert get_extra(state2, 'pot_timer', scope='overcooked')[0] == 1
print('helpers OK')
"` -- should print 'helpers OK'.
Run: `python -c "
from cogrid.backend.array_ops import set_at, set_at_2d
import numpy as np
a = np.zeros(5, dtype=np.int32)
b = set_at(a, 2, 99)
assert b[2] == 99 and a[2] == 0, 'set_at failed on numpy'
m = np.zeros((3,3), dtype=np.int32)
n = set_at_2d(m, 1, 2, 42)
assert n[1,2] == 42 and m[1,2] == 0, 'set_at_2d failed on numpy'
print('numpy array_ops OK')
"` -- should print 'numpy array_ops OK'.
  </verify>
  <done>array_ops.py exists with set_at and set_at_2d using get_backend() check. EnvState has extra_state field, no pot_contents/pot_timer/pot_positions/n_pots fields. get_extra, replace_extra, validate_extra_state functions work correctly on numpy backend.</done>
</task>

<task type="auto">
  <name>Task 2: Replace all hasattr(arr, 'at') checks with array_ops calls</name>
  <files>cogrid/core/grid_object.py, cogrid/envs/overcooked/array_config.py</files>
  <action>
**A) Update `cogrid/core/grid_object.py` -- `build_lookup_tables()`:**

Replace the 3 `hasattr` check blocks (lines 178, 183, 217) with `array_ops.set_at`:

1. Add import at top of `build_lookup_tables()`: `from cogrid.backend.array_ops import set_at`
2. Lines 178 (None/empty cell) and 183 (free_space): replace the ternary `tables["CAN_OVERLAP"] = tables["CAN_OVERLAP"].at[idx].set(1) if hasattr(...) else _np_set(...)` with `tables["CAN_OVERLAP"] = set_at(tables["CAN_OVERLAP"], idx, 1)`
3. Lines 215-222 (property loop): replace the `if hasattr(tables[table_key], 'at')` / else block with a single `tables[table_key] = set_at(tables[table_key], idx, 1)`
4. Remove the `_np_set()` helper function (lines 227-230) -- it is no longer needed

**B) Update `cogrid/envs/overcooked/array_config.py` -- `_build_interaction_tables()`:**

Replace the 2 `hasattr` check blocks (lines 99-106, 109-114):

1. Add import: `from cogrid.backend.array_ops import set_at`
2. Lines 99-106 (pickup_from_produces): replace `if hasattr(pickup_from_produces, 'at')` / else block with:
   ```python
   pickup_from_produces = set_at(pickup_from_produces, onion_stack_id, onion_id)
   pickup_from_produces = set_at(pickup_from_produces, tomato_stack_id, tomato_id)
   pickup_from_produces = set_at(pickup_from_produces, plate_stack_id, plate_id)
   ```
3. Lines 109-114 (legal_pot_ingredients): replace `if hasattr(legal_pot_ingredients, 'at')` / else block with:
   ```python
   legal_pot_ingredients = set_at(legal_pot_ingredients, onion_id, 1)
   legal_pot_ingredients = set_at(legal_pot_ingredients, tomato_id, 1)
   ```

After these changes, verify NO `hasattr(` ... `'at')` remains in the codebase by running a grep search. The ONLY backend branching should be inside `array_ops.py`.
  </action>
  <verify>
Run: `grep -rn "hasattr.*'at'" cogrid/ --include="*.py"` -- should return ZERO results (no hasattr checks remain in any Python file).
Run: `python -c "
from cogrid.backend import set_backend
import cogrid.envs.overcooked.overcooked_grid_objects  # register objects
from cogrid.core.grid_object import build_lookup_tables
tables = build_lookup_tables(scope='overcooked')
assert tables['CAN_OVERLAP'][0] == 1, 'None cell should be overlappable'
assert tables['CAN_OVERLAP'][1] == 1, 'free_space should be overlappable'
assert tables['IS_WALL'][2] == 1 or any(tables['IS_WALL'] == 1), 'wall should exist'
print('lookup tables OK')
"` -- should print 'lookup tables OK'.
Run: `python -c "
import cogrid.envs.overcooked.overcooked_grid_objects
from cogrid.envs.overcooked.array_config import _build_interaction_tables
itables = _build_interaction_tables('overcooked')
pfp = itables['pickup_from_produces']
lpi = itables['legal_pot_ingredients']
assert pfp.sum() > 0, 'pickup_from_produces should have non-zero entries'
assert lpi.sum() > 0, 'legal_pot_ingredients should have non-zero entries'
print('interaction tables OK')
"` -- should print 'interaction tables OK'.
  </verify>
  <done>All 5 hasattr(arr, 'at') checks replaced with array_ops.set_at calls. _np_set helper deleted from grid_object.py. grep confirms zero hasattr 'at' checks remain in the codebase. build_lookup_tables and _build_interaction_tables produce correct arrays on numpy backend.</done>
</task>

</tasks>

<verification>
1. `python -c "from cogrid.backend.array_ops import set_at, set_at_2d"` succeeds
2. `python -c "from cogrid.backend.env_state import EnvState; print([f.name for f in __import__('dataclasses').fields(EnvState)])"` shows extra_state and does NOT show pot_contents, pot_timer, pot_positions, n_pots
3. `grep -rn "hasattr.*'at'" cogrid/ --include="*.py"` returns zero results
4. `python cogrid/backend/env_state.py` smoke test passes with extra_state usage
</verification>

<success_criteria>
- array_ops.py exists at cogrid/backend/array_ops.py with set_at and set_at_2d
- EnvState dataclass has extra_state field, NO pot_contents/pot_timer/pot_positions/n_pots fields
- get_extra(), replace_extra(), validate_extra_state() exist in env_state.py
- Zero hasattr(arr, 'at') checks remain in any .py file under cogrid/
- All verification commands pass without errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-foundation-state-model-backend-helpers/05-01-SUMMARY.md`
</output>

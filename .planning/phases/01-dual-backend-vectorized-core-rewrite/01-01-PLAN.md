---
phase: 01-dual-backend-vectorized-core-rewrite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cogrid/backend/__init__.py
  - cogrid/backend/_dispatch.py
  - cogrid/core/grid_object.py
  - cogrid/envs/overcooked/overcooked_grid_objects.py
  - cogrid/core/constants.py
autonomous: true

must_haves:
  truths:
    - "`from cogrid.backend import xp` resolves to numpy by default"
    - "`set_backend('jax')` switches xp to jax.numpy when JAX is installed"
    - "`set_backend('jax')` raises ImportError with clear message when JAX not installed"
    - "Calling `set_backend()` a second time with a different backend raises RuntimeError"
    - "Object property lookup tables (CAN_PICKUP, CAN_OVERLAP, CAN_PLACE_ON, CAN_PICKUP_FROM, IS_WALL) are integer-indexed arrays built from the registry"
    - "Lookup table integer indices match existing `object_to_idx()` encoding exactly"
  artifacts:
    - path: "cogrid/backend/__init__.py"
      provides: "Public API: xp, set_backend, get_backend"
      exports: ["xp", "set_backend", "get_backend"]
    - path: "cogrid/backend/_dispatch.py"
      provides: "Backend dispatch logic and global state"
      contains: "def set_backend"
    - path: "cogrid/core/grid_object.py"
      provides: "@register_object_type decorator and build_lookup_tables function"
      contains: "def build_lookup_tables"
  key_links:
    - from: "cogrid/backend/_dispatch.py"
      to: "numpy or jax.numpy"
      via: "dynamic import and module alias"
      pattern: "xp = "
    - from: "cogrid/core/grid_object.py"
      to: "cogrid/backend"
      via: "xp import for array creation in build_lookup_tables"
      pattern: "from cogrid.backend import xp"
    - from: "cogrid/envs/overcooked/overcooked_grid_objects.py"
      to: "cogrid/core/grid_object.py"
      via: "@register_object_type decorator on each GridObj subclass"
      pattern: "@register_object_type"
---

<objective>
Create the backend dispatch module (`cogrid.backend`) and the object type registry with property lookup tables. These are the two foundational pieces that every subsequent plan depends on.

Purpose: The backend module enables `from cogrid.backend import xp` so all simulation code uses a single array API that resolves to numpy or jax.numpy. The type registry replaces runtime `isinstance()` checks with integer-indexed property lookup tables for vectorized operations.

Output: `cogrid/backend/` package with `xp`, `set_backend`, `get_backend`. Enhanced `grid_object.py` with `@register_object_type` decorator and `build_lookup_tables()`. All Overcooked GridObj subclasses annotated with the decorator.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-RESEARCH.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-CONTEXT.md
@cogrid/core/grid_object.py
@cogrid/envs/overcooked/overcooked_grid_objects.py
@cogrid/core/constants.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backend dispatch module</name>
  <files>cogrid/backend/__init__.py, cogrid/backend/_dispatch.py</files>
  <action>
Create the `cogrid/backend/` package with two files:

**`_dispatch.py`:**
- Module-level globals: `_backend_name: str = "numpy"`, `_backend_set: bool = False`, `xp` initialized to `numpy`
- `set_backend(name: str) -> None`:
  - If `_backend_set` is True and `name != _backend_name`, raise `RuntimeError` with message: `f"Backend already set to '{_backend_name}'. Cannot change backend after first environment creation."`
  - If `name == "numpy"`: `import numpy; xp = numpy`
  - If `name == "jax"`: try `import jax.numpy as jnp`, set `xp = jnp`. On ImportError, raise `ImportError("Backend 'jax' requested but JAX is not installed.\nInstall JAX with: pip install jax jaxlib\nOr use the numpy backend (default): CoGridEnv(config)")`
  - Else: raise `ValueError(f"Unknown backend: {name}. Use 'numpy' or 'jax'.")`
  - Set `_backend_set = True`, `_backend_name = name`
  - Use `global` keyword for all module-level mutations
- `get_backend() -> str`: return `_backend_name`

**`__init__.py`:**
- `from cogrid.backend._dispatch import xp, set_backend, get_backend`

Per research recommendation (Claude's Discretion): the backend module stays purely as array module swap -- no JAX utility helpers, no RNG management, no JIT wrapping. Phase 1 uses numpy-style mutation throughout.

IMPORTANT: `xp` is a module reference, not a function. Importing modules import the reference at import time, so mutations to `xp` in `_dispatch.py` propagate to importers because they import the name from the module, not a copy. Verify this behavior works correctly: after `set_backend('numpy')`, code doing `from cogrid.backend import xp; xp.zeros(3)` must work.

CRITICAL SUBTLETY: Python `from X import Y` binds `Y` to the local namespace at import time. Subsequent mutations to `X.Y` do NOT propagate to already-imported names. This means `from cogrid.backend import xp` will capture the initial value. To handle this, `_dispatch.py` must NOT rebind `xp` as a new module reference. Instead, use a proxy pattern OR document that `set_backend()` must be called BEFORE any other cogrid imports. The simplest correct approach: make `set_backend()` mutate `_dispatch.xp` and `cogrid.backend.xp` simultaneously, and require that simulation code accesses `xp` via `cogrid.backend.xp` attribute access (not via `from cogrid.backend import xp` at module level). Actually, the cleanest pattern: use `sys.modules` or a module-level `__getattr__` to make `xp` a lazy accessor. But the simplest working approach that matches the user's locked decision (`from cogrid.backend import xp`): ensure `set_backend()` is called before ANY other module imports `xp`. Since `CoGridEnv.__init__` calls `set_backend()` and the default is numpy, this works: numpy is the initial value, and `set_backend('numpy')` is a no-op. If `set_backend('jax')` is called, it must happen before simulation code imports. Add this constraint to the docstring.

ALTERNATIVE (RECOMMENDED): Use a module with `__getattr__` on `cogrid/backend/__init__.py` so that `from cogrid.backend import xp` always gets the current value. Implement `xp` as a property of a wrapper module or use `importlib` to update `sys.modules`. The simplest approach: store the backend module in `_dispatch._xp_module` and have `cogrid.backend.__init__.py` define `xp` as a lazy reference. Actually the simplest correct implementation:

In `_dispatch.py`, store backend in a mutable container (module attribute). In `__init__.py`, re-export using `__getattr__`:
```python
# __init__.py
from cogrid.backend._dispatch import set_backend, get_backend

def __getattr__(name):
    if name == "xp":
        from cogrid.backend import _dispatch
        return _dispatch.xp
    raise AttributeError(f"module 'cogrid.backend' has no attribute {name}")
```

This way `from cogrid.backend import xp` calls `__getattr__('xp')` which returns the current `_dispatch.xp`. But NOTE: `from X import Y` only calls `__getattr__` if `Y` is not already defined in the module. So do NOT define `xp` directly in `__init__.py` -- let `__getattr__` handle it.

Test that the import-rebind issue is handled: write a quick test in the verify step.
  </action>
  <verify>
Run: `python -c "from cogrid.backend import xp; assert xp.zeros(3).shape == (3,); print('OK: xp defaults to numpy')"` succeeds.
Run: `python -c "from cogrid.backend import set_backend; set_backend('jax')"` raises ImportError if JAX not installed, or succeeds if installed.
Run: `python -c "from cogrid.backend import set_backend, get_backend; set_backend('numpy'); assert get_backend() == 'numpy'; print('OK')"` succeeds.
Run: `python -c "
from cogrid.backend import set_backend
set_backend('numpy')
try:
    set_backend('jax')
    print('FAIL: should have raised')
except RuntimeError as e:
    print(f'OK: {e}')
"` prints RuntimeError message.
Run: `python -c "
from cogrid.backend import set_backend, xp
set_backend('numpy')
# Now re-import to check binding
from cogrid.backend import xp as xp2
assert xp2.zeros(3).shape == (3,)
print('OK: xp re-import works')
"` succeeds.
  </verify>
  <done>
`cogrid.backend` package exists. `from cogrid.backend import xp` returns numpy by default. `set_backend('jax')` switches to jax.numpy or raises ImportError. `set_backend()` called twice with different backend raises RuntimeError. `get_backend()` returns current backend name.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add @register_object_type decorator and build_lookup_tables</name>
  <files>cogrid/core/grid_object.py, cogrid/envs/overcooked/overcooked_grid_objects.py, cogrid/core/constants.py</files>
  <action>
Modify `cogrid/core/grid_object.py` to add:

1. **`_OBJECT_TYPE_PROPERTIES` dict** at module level (alongside existing `OBJECT_REGISTRY`):
   ```python
   _OBJECT_TYPE_PROPERTIES: dict[tuple[str, str], dict[str, bool]] = {}
   ```
   Keyed by `(scope, object_id)` tuples, values are property dicts.

2. **`register_object_type()` decorator function:**
   ```python
   def register_object_type(
       object_id: str,
       scope: str = "global",
       can_pickup: bool = False,
       can_overlap: bool = False,
       can_place_on: bool = False,
       can_pickup_from: bool = False,
       is_wall: bool = False,
   ):
   ```
   - Store properties in `_OBJECT_TYPE_PROPERTIES[(scope, object_id)]`
   - Also call the existing `register_object(object_id, cls, scope=scope)` so backward compatibility is maintained
   - Set `cls.object_id = object_id` on the class
   - Return the class unmodified (except object_id assignment)
   - IMPORTANT: This decorator REPLACES the manual `register_object()` call, so do NOT call `register_object()` separately when using the decorator

3. **`build_lookup_tables(scope: str) -> dict` function:**
   - Use the existing `get_object_names(scope=scope)` to get the ordered type list (this is CRITICAL for matching existing encoding)
   - `n_types = len(type_names)`
   - Create separate 1D arrays per property (per research recommendation for Claude's Discretion): `CAN_PICKUP`, `CAN_OVERLAP`, `CAN_PLACE_ON`, `CAN_PICKUP_FROM`, `IS_WALL`, each of shape `(n_types,)` with dtype `int32`
   - For each `(idx, name)` in enumerate of type_names:
     - If name is None: set `CAN_OVERLAP[idx] = 1` (empty cells are overlappable), all others 0
     - If name starts with "agent_": skip (agent directions are not objects with properties)
     - Otherwise: look up `_OBJECT_TYPE_PROPERTIES` for `(scope, name)` or `("global", name)`. If found, populate arrays from properties. If NOT found (object registered via old `register_object()` without decorator), try to get properties from the class's instance methods as fallback: instantiate the class and check `obj.can_pickup()`, `obj.can_overlap()`, etc. with a dummy agent. Actually this is fragile -- instead, just default to all-False for undecorated objects and log a warning.
   - CRITICAL: Index 0 is `None` (empty cell), index 1 is `"free_space"`. `free_space` should have `CAN_OVERLAP = 1`.
   - Import `xp` from `cogrid.backend` at function call time (not at module level) to avoid circular import issues. Use `from cogrid.backend import xp` inside the function body.
   - Return dict with keys `"CAN_PICKUP"`, `"CAN_OVERLAP"`, `"CAN_PLACE_ON"`, `"CAN_PICKUP_FROM"`, `"IS_WALL"`.

4. **Annotate existing GridObj subclasses in `grid_object.py`** with `@register_object_type`:
   - `FreeSpace`: `@register_object_type("free_space", can_overlap=True)`
   - `Wall`: `@register_object_type("wall", is_wall=True)`
   - `Counter`: `@register_object_type("counter", can_place_on=True)` -- NOTE: Counter.can_place_on is dynamic (depends on whether something is already placed), but the static lookup says "this type supports placement". Runtime logic handles the dynamic check.
   - `Floor`: `@register_object_type("floor", can_overlap=True)`
   - `Door`: `@register_object_type("door")` -- door overlap depends on state (open/closed), handle dynamically
   - `Key`: `@register_object_type("key", can_pickup=True)`
   - Remove the corresponding `register_object(ID, Class)` calls that currently follow each class definition, since the decorator now handles registration.

5. **Annotate Overcooked GridObj subclasses in `overcooked_grid_objects.py`** with `@register_object_type`:
   - `Onion`: `@register_object_type("onion", scope="overcooked", can_pickup=True)`
   - `Tomato`: `@register_object_type("tomato", scope="overcooked", can_pickup=True)`
   - `OnionStack`: `@register_object_type("onion_stack", scope="overcooked", can_pickup_from=True)`
   - `TomatoStack`: `@register_object_type("tomato_stack", scope="overcooked", can_pickup_from=True)`
   - `Pot`: `@register_object_type("pot", scope="overcooked", can_place_on=True, can_pickup_from=True)`
   - `Plate`: `@register_object_type("plate", scope="overcooked", can_pickup=True)`
   - `PlateStack`: `@register_object_type("plate_stack", scope="overcooked", can_pickup_from=True)`
   - `OnionSoup`: `@register_object_type("onion_soup", scope="overcooked", can_pickup=True)`
   - `TomatoSoup`: `@register_object_type("tomato_soup", scope="overcooked", can_pickup=True)`
   - `DeliveryZone`: `@register_object_type("delivery_zone", scope="overcooked", can_place_on=True)`
   - Remove all manual `register_object(ID, Class, scope="overcooked")` calls.

IMPORTANT: The decorator must be compatible with the existing `register_object()` function. It should call `register_object()` internally so all existing code that queries `OBJECT_REGISTRY` continues to work. Verify that `get_object_names()` still returns the same ordered list after the refactor.

IMPORTANT: Check if there are other GridObj subclasses in `cogrid/core/grid_object.py` beyond the ones listed above (e.g., `Goal`, `Lava`, etc.) and annotate them too. Read the full file to find all subclasses.
  </action>
  <verify>
Run existing tests: `python -m pytest cogrid/test_gridworld_env.py cogrid/test_overcooked_env.py -x -q` -- all pass (no regression from decorator refactor).
Run: `python -c "
from cogrid.core.grid_object import get_object_names, build_lookup_tables
import cogrid.envs.overcooked  # trigger registration
names = get_object_names(scope='overcooked')
print('Type names:', names)
tables = build_lookup_tables(scope='overcooked')
print('CAN_PICKUP:', tables['CAN_PICKUP'])
print('CAN_OVERLAP:', tables['CAN_OVERLAP'])
print('n_types:', len(names))
# Verify onion is pickupable
onion_idx = names.index('onion')
assert tables['CAN_PICKUP'][onion_idx] == 1, f'Onion should be pickupable, idx={onion_idx}'
# Verify wall is a wall
wall_idx = names.index('wall')
assert tables['IS_WALL'][wall_idx] == 1, f'Wall should be IS_WALL, idx={wall_idx}'
# Verify None (idx 0) is overlappable
assert tables['CAN_OVERLAP'][0] == 1, 'None/empty should be overlappable'
print('ALL CHECKS PASSED')
"` succeeds.
  </verify>
  <done>
`@register_object_type` decorator exists and is applied to all GridObj subclasses in `grid_object.py` and `overcooked_grid_objects.py`. `build_lookup_tables(scope)` returns dict of integer-indexed property arrays matching existing `object_to_idx()` encoding. All existing tests pass without modification. Manual `register_object()` calls removed (decorator handles registration).
  </done>
</task>

</tasks>

<verification>
1. `from cogrid.backend import xp` resolves to numpy by default
2. `set_backend('jax')` raises ImportError if JAX not installed
3. `set_backend()` called twice with different backend raises RuntimeError
4. `build_lookup_tables('overcooked')` returns correct property arrays
5. Type ID ordering from `get_object_names()` is unchanged from before the refactor
6. All existing tests pass: `python -m pytest cogrid/ -x -q`
</verification>

<success_criteria>
- Backend dispatch module exists at `cogrid/backend/` with `xp`, `set_backend`, `get_backend`
- `@register_object_type` decorator replaces manual `register_object()` calls
- `build_lookup_tables()` produces integer-indexed property arrays
- Lookup table indices match `object_to_idx()` encoding exactly
- All existing tests pass unchanged on numpy backend
</success_criteria>

<output>
After completion, create `.planning/phases/01-dual-backend-vectorized-core-rewrite/01-01-SUMMARY.md`
</output>

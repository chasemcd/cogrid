---
phase: 01-dual-backend-vectorized-core-rewrite
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - cogrid/core/movement.py
autonomous: true

must_haves:
  truths:
    - "All agent attempted positions are computed simultaneously via array operations, not Python loops over agents"
    - "Conflict detection identifies agents targeting the same cell without per-agent Python loops"
    - "Priority-based resolution uses random permutation for fairness"
    - "Swap detection reverts agents that passed through each other"
    - "Wall and bounds checking operates on arrays"
    - "Agents staying in place get priority over movers (matching existing behavior)"
  artifacts:
    - path: "cogrid/core/movement.py"
      provides: "move_agents_array() vectorized movement resolution function"
      contains: "def move_agents_array"
      min_lines: 80
  key_links:
    - from: "cogrid/core/movement.py"
      to: "cogrid/backend"
      via: "xp import for all array operations"
      pattern: "from cogrid.backend import xp"
    - from: "cogrid/core/movement.py"
      to: "cogrid/core/agent.py"
      via: "get_dir_vec_table for direction vectors"
      pattern: "get_dir_vec_table"
---

<objective>
Create a vectorized movement resolution function that computes all agent positions simultaneously via array operations, replacing the Python loop in `cogrid_env.py:move_agents()`.

Purpose: Movement resolution is one of the core simulation loop operations. The existing implementation iterates over agents one-by-one with Python dicts and lists. The vectorized version computes all proposed positions, detects conflicts, resolves by priority, and reverts swaps -- all using array operations that will be compatible with JAX JIT in Phase 2.

Output: New file `cogrid/core/movement.py` with `move_agents_array()` function.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-RESEARCH.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-CONTEXT.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-01-SUMMARY.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-02-SUMMARY.md
@cogrid/cogrid_env.py (lines 437-529 for existing move_agents)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement vectorized movement resolution</name>
  <files>cogrid/core/movement.py</files>
  <action>
Create a NEW file `cogrid/core/movement.py` with the vectorized movement resolution function.

**Function signature:**
```python
def move_agents_array(
    agent_pos,       # (n_agents, 2) int32 -- current positions
    agent_dir,       # (n_agents,) int32 -- current directions
    actions,         # (n_agents,) int32 -- action indices
    wall_map,        # (H, W) int32 -- 1 where walls exist
    object_type_map, # (H, W) int32 -- type IDs at each cell
    can_overlap,     # (n_types,) int32 -- lookup table for overlappable types
    rng,             # numpy.random.Generator -- for priority shuffle
    action_set,      # str -- "cardinal" or "rotation"
) -> tuple:          # Returns (new_pos, new_dir)
```

**Implementation must match the existing behavior in `cogrid_env.py:437-529` exactly:**

1. **Action-to-direction mapping (cardinal mode, lines 461-475):**
   - For cardinal action set: actions 0-3 map to directions (Up=0, Down=1, Left=2, Right=3 -- check the exact mapping in `cogrid/core/actions.py` ActionSets.CardinalActions order)
   - CRITICAL: Check the exact mapping. `CardinalActions = (MoveUp, MoveDown, MoveLeft, MoveRight, PickupDrop, Toggle, Noop)`. So action index 0=MoveUp, 1=MoveDown, 2=MoveLeft, 3=MoveRight. These map to directions: MoveUp->Directions.Up(3), MoveDown->Directions.Down(1), MoveLeft->Directions.Left(2), MoveRight->Directions.Right(0).
   - Create a mapping array: `ACTION_TO_DIR = xp.array([3, 1, 2, 0, -1, -1, -1])` (indices 0-3 are cardinal moves mapped to direction enums, 4-6 are non-movement actions marked with -1)
   - For cardinal actions (index 0-3): update direction to the mapped direction AND convert action to "forward" (i.e., mark as a mover)
   - For rotation action set: Forward=0 is the only move action. Handle RotateLeft/RotateRight in interactions, not here.

2. **Compute proposed positions (lines 478-482):**
   - `is_mover`: boolean array -- True for agents taking a movement action
   - Use `get_dir_vec_table()` from `cogrid/core/agent.py` for direction vectors
   - `dir_vecs = DIR_VEC_TABLE[new_dir]` -- shape `(n_agents, 2)`
   - `proposed = agent_pos + dir_vecs * is_mover[:, None]` -- non-movers stay in place

3. **Bounds clipping:**
   - `proposed = xp.clip(proposed, xp.array([0, 0]), xp.array([H-1, W-1]))`

4. **Wall check (line 547 in determine_attempted_pos):**
   - `hits_wall = wall_map[proposed[:, 0], proposed[:, 1]]`
   - `proposed = xp.where(hits_wall[:, None], agent_pos, proposed)` -- revert to current pos if wall

5. **Overlap check (line 547 in determine_attempted_pos):**
   - `fwd_type = object_type_map[proposed[:, 0], proposed[:, 1]]`
   - `can_overlap_fwd = can_overlap[fwd_type]` -- 1 if overlappable, 0 if not
   - For cells with no object (type 0 / None), `can_overlap[0]` should be 1 (empty cells are walkable)
   - `blocked_by_object = (fwd_type > 0) & (can_overlap_fwd == 0)` -- has object AND can't overlap
   - `proposed = xp.where(blocked_by_object[:, None], agent_pos, proposed)`

6. **Priority to agents staying in place (lines 484-490):**
   - `staying = xp.all(proposed == agent_pos, axis=1)` -- agents whose proposed == current
   - These agents are "resolved" first -- their positions are final

7. **Random priority collision resolution (lines 492-510):**
   - This is the part that MUST use a Python loop in Phase 1 (Phase 2 converts to `lax.fori_loop`)
   - `priority = rng.permutation(n_agents)` -- random priority order
   - Process agents in priority order. For staying agents, their position is already final.
   - For each moving agent (in priority order):
     - Check if proposed position conflicts with any already-resolved position
     - Check if proposed position is currently occupied by an unresolved agent (matching lines 499-505)
     - If blocked: revert to current position
     - If clear: accept proposed position
   - Mark `# PHASE2: convert to lax.fori_loop or lax.scan` on this loop

8. **Swap detection (lines 512-519):**
   - For all pairs (i, j): if `final_pos[i] == agent_pos[j]` AND `final_pos[j] == agent_pos[i]`, revert both
   - Phase 1: nested Python loop over agent pairs. For small n_agents (2-4), this is fine.
   - Mark `# PHASE2: convert to vectorized swap detection` on this loop

9. **Return `(new_pos, new_dir)`**

**CRITICAL behavioral matches to verify:**
- Agents taking non-movement actions (PickupDrop, Toggle, Noop) stay in place
- Cardinal actions both CHANGE DIRECTION and MOVE in one step
- An agent blocked by a wall stays at current position (does NOT change direction -- wait, the existing code DOES change direction before checking walls. Re-read lines 468-475: direction is changed first, then `determine_attempted_pos` checks if forward cell is passable. So direction changes even if the agent can't move. This MUST be preserved.)
- Two agents targeting the same cell: one gets it (random priority), the other stays
- Swap detection prevents agents passing through each other
  </action>
  <verify>
Run: `python -c "
import numpy as np
from cogrid.core.movement import move_agents_array
from cogrid.core.agent import get_dir_vec_table

# Test 1: Basic movement in empty grid
agent_pos = np.array([[2, 2], [4, 4]], dtype=np.int32)
agent_dir = np.array([0, 0], dtype=np.int32)  # Both facing Right
actions = np.array([3, 2], dtype=np.int32)     # MoveRight=3, MoveLeft=2 (cardinal)
wall_map = np.zeros((7, 7), dtype=np.int32)
object_type_map = np.zeros((7, 7), dtype=np.int32)
can_overlap = np.array([1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=np.int32)
rng = np.random.default_rng(42)

new_pos, new_dir = move_agents_array(
    agent_pos, agent_dir, actions, wall_map, object_type_map, can_overlap, rng, 'cardinal'
)
print('Test 1 - Basic movement:')
print('  new_pos:', new_pos)
print('  new_dir:', new_dir)
# Agent 0: MoveRight -> dir=Right(0), move to (2, 3)
# Agent 1: MoveLeft -> dir=Left(2), move to (4, 3)
assert np.array_equal(new_pos[0], [2, 3]), f'Agent 0 should move right: {new_pos[0]}'
assert np.array_equal(new_pos[1], [4, 3]), f'Agent 1 should move left: {new_pos[1]}'

# Test 2: Wall blocking
wall_map2 = np.zeros((7, 7), dtype=np.int32)
wall_map2[2, 3] = 1  # Wall to the right of agent 0
new_pos2, new_dir2 = move_agents_array(
    agent_pos.copy(), agent_dir.copy(), actions.copy(), wall_map2, object_type_map, can_overlap, rng, 'cardinal'
)
print('Test 2 - Wall blocking:')
print('  new_pos:', new_pos2)
assert np.array_equal(new_pos2[0], [2, 2]), f'Agent 0 should be blocked by wall: {new_pos2[0]}'

# Test 3: Collision
agent_pos3 = np.array([[2, 2], [2, 4]], dtype=np.int32)
actions3 = np.array([3, 2], dtype=np.int32)  # Both moving toward (2, 3)
new_pos3, _ = move_agents_array(
    agent_pos3, np.array([0, 2], dtype=np.int32), actions3, np.zeros((7, 7), dtype=np.int32),
    object_type_map, can_overlap, rng, 'cardinal'
)
print('Test 3 - Collision:')
print('  new_pos:', new_pos3)
# One should get (2, 3), the other stays
assert not (np.array_equal(new_pos3[0], [2, 3]) and np.array_equal(new_pos3[1], [2, 3])), 'Both agents should not be at same position'

# Test 4: Non-movement action (PickupDrop=4) stays in place
actions4 = np.array([4, 4], dtype=np.int32)  # PickupDrop for both
new_pos4, new_dir4 = move_agents_array(
    agent_pos.copy(), agent_dir.copy(), actions4, wall_map, object_type_map, can_overlap, rng, 'cardinal'
)
print('Test 4 - Non-movement:')
assert np.array_equal(new_pos4, agent_pos), 'Non-movement actions should not change position'
assert np.array_equal(new_dir4, agent_dir), 'Non-movement actions should not change direction'

print('ALL MOVEMENT TESTS PASSED')
"` succeeds.

Additionally run: `python -m pytest cogrid/test_gridworld_env.py cogrid/test_overcooked_env.py -x -q` -- all pass (no regression, this is a new file).
  </verify>
  <done>
`cogrid/core/movement.py` exists with `move_agents_array()` that:
- Computes all proposed positions simultaneously via array operations
- Detects conflicts without per-agent Python loops (collision resolution loop is minimal, marked for Phase 2 conversion)
- Uses random permutation for priority
- Detects and reverts swaps
- Handles wall/bounds/overlap checking via arrays
- Matches existing `move_agents()` behavior for all test cases
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate movement parity against existing implementation</name>
  <files>cogrid/core/movement.py</files>
  <action>
Add a parity test function at the bottom of `cogrid/core/movement.py` (or as a standalone test) that runs both the old `CoGridEnv.move_agents()` and the new `move_agents_array()` on the same inputs and verifies identical outputs.

**Approach:**
1. Create a small test that instantiates an Overcooked environment (cramped_room)
2. Run `reset()` to get initial state
3. For N random action sequences (N=50 steps), at each step:
   a. Capture the current Grid/Agent state
   b. Convert to array state using `layout_to_array_state()` and `create_agent_arrays()`
   c. Run `move_agents_array()` with the same actions and same RNG seed
   d. Compare `new_pos` from `move_agents_array()` against the positions after `env.move_agents()`
   e. Assert positions match exactly
4. This validates that the vectorized movement produces identical results to the existing implementation

IMPORTANT: The RNG seed must be identical for both paths. The existing code uses `self.np_random.shuffle(agents_to_move)` while the new code uses `rng.permutation(n_agents)`. Make sure the same RNG state is used.

This test should be written as a standalone function `test_movement_parity()` that can be called manually. It is NOT a formal pytest test yet (that comes in Plan 07). The purpose is to validate behavioral equivalence during development.

Add the parity test as a function in `movement.py`:
```python
def test_movement_parity():
    """Development-time parity test. Validates vectorized movement matches existing."""
    ...
```
  </action>
  <verify>
Run: `python -c "from cogrid.core.movement import test_movement_parity; test_movement_parity()"` -- prints success message after comparing 50+ steps.
  </verify>
  <done>
Parity test confirms that `move_agents_array()` produces identical agent positions to the existing `CoGridEnv.move_agents()` for 50+ random steps on the cramped_room layout. Behavioral equivalence validated.
  </done>
</task>

</tasks>

<verification>
1. `move_agents_array()` produces correct positions for basic movement, wall blocking, collisions, non-movement actions
2. Swap detection works correctly
3. Parity test passes: vectorized movement matches existing implementation for 50+ steps
4. No Python loops over agents for position computation (only for collision resolution, marked for Phase 2)
5. All existing tests pass unchanged
</verification>

<success_criteria>
- Vectorized movement function exists with array-based collision resolution
- All agent positions computed simultaneously via array operations
- Conflict detection, priority resolution, and swap detection all operational
- Parity test confirms identical behavior to existing implementation
- No regression in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/01-dual-backend-vectorized-core-rewrite/01-03-SUMMARY.md`
</output>

---
phase: 01-dual-backend-vectorized-core-rewrite
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - cogrid/core/grid_utils.py
  - cogrid/core/layouts.py
  - cogrid/core/agent.py
autonomous: true

must_haves:
  truths:
    - "An ASCII layout (e.g., Overcooked cramped_room) can be parsed into array-based state with correct wall_map, object positions, and agent positions"
    - "Agent state is represented as separate arrays: agent_pos[n_agents, 2], agent_dir[n_agents], agent_inv[n_agents, 1]"
    - "Grid state is represented as separate 2D arrays: object_type_map[h, w], object_state_map[h, w], wall_map[h, w]"
    - "Inventory arrays use -1 sentinel for empty slots"
    - "Pot contents are represented as pot_contents[n_pots, 3] with -1 sentinel, pot_timer[n_pots] arrays"
    - "Grid object_type_map uses 0 for empty cells (matching existing object_to_idx(None) == 0)"
  artifacts:
    - path: "cogrid/core/grid_utils.py"
      provides: "layout_to_array_state() function converting ASCII layouts to array representation"
      contains: "def layout_to_array_state"
    - path: "cogrid/core/agent.py"
      provides: "create_agent_arrays() function creating array-based agent state"
      contains: "def create_agent_arrays"
  key_links:
    - from: "cogrid/core/grid_utils.py"
      to: "cogrid/core/grid_object.py"
      via: "get_object_names/object_to_idx for type ID assignment"
      pattern: "object_to_idx|get_object_id_from_char"
    - from: "cogrid/core/grid_utils.py"
      to: "cogrid/backend"
      via: "xp import for array creation"
      pattern: "from cogrid.backend import xp"
---

<objective>
Create functions to convert ASCII grid layouts and agent state into the array-based representation that all subsequent vectorized operations will operate on.

Purpose: Every downstream plan (movement, interactions, observations, rewards) needs array-based state. This plan creates the conversion layer from the existing Grid/Agent/GridObj objects to the array representation defined in the user's locked decisions.

Output: `layout_to_array_state()` in `grid_utils.py` that produces `object_type_map`, `object_state_map`, `wall_map`, `pot_contents`, `pot_timer`. `create_agent_arrays()` in `agent.py` that produces `agent_pos`, `agent_dir`, `agent_inv`.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-RESEARCH.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-CONTEXT.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-01-SUMMARY.md
@cogrid/core/grid_utils.py
@cogrid/core/agent.py
@cogrid/core/grid.py
@cogrid/core/layouts.py
@cogrid/envs/overcooked/overcooked_grid_objects.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create layout_to_array_state function</name>
  <files>cogrid/core/grid_utils.py</files>
  <action>
Add `layout_to_array_state()` function to `cogrid/core/grid_utils.py`. This function converts an existing Grid object (already populated from an ASCII layout) into the array-based state representation.

**Function signature:**
```python
def layout_to_array_state(grid, scope: str = "global") -> dict:
```

**Parameters:**
- `grid`: A `Grid` instance (already created from an ASCII layout via existing `_gen_grid()` path)
- `scope`: Object registry scope for type ID lookups

**Returns a dict with:**
- `"object_type_map"`: `xp.ndarray` of shape `(height, width)`, dtype `int32`. Each cell contains the integer type ID from `object_to_idx()`. Empty cells = 0 (matching `object_to_idx(None) == 0`). NOTE: use 0 for empty grid cells, NOT -1 (per research Pitfall 4).
- `"object_state_map"`: `xp.ndarray` of shape `(height, width)`, dtype `int32`. Each cell contains the object's `.state` attribute. 0 for empty cells.
- `"wall_map"`: `xp.ndarray` of shape `(height, width)`, dtype `int32` (0 or 1). 1 where the object is a Wall (check `IS_WALL` lookup table or check `object_id == "wall"`).
- `"pot_positions"`: list of `(row, col)` tuples for all pots in the grid (needed for pot array indexing)
- `"pot_contents"`: `xp.ndarray` of shape `(n_pots, 3)`, dtype `int32`. Initialized to -1 (sentinel). If pots have objects in them (from layout state), populate with ingredient type IDs.
- `"pot_timer"`: `xp.ndarray` of shape `(n_pots,)`, dtype `int32`. Initialized to `cooking_time` (30) for empty/partially-full pots, or the current timer value for cooking pots.
- `"spawn_points"`: list of `(row, col)` tuples where spawn markers exist

**Implementation approach:**
1. Import `from cogrid.backend import xp` inside function body
2. Import `from cogrid.core.grid_object import object_to_idx, get_object_id_from_char, get_object_names`
3. Iterate over `grid.grid` (the internal list), using `grid.get(i, j)` for each cell
4. For each cell: if None, type_id = 0. Otherwise, type_id = `object_to_idx(cell.object_id, scope=scope)` (or `object_to_idx(cell, scope=scope)` which handles GridObj instances)
5. For walls: check `isinstance(cell, Wall)` OR check if `cell.object_id == "wall"`. Set `wall_map[i, j] = 1`.
6. For pots: track position index. Populate `pot_contents` from `pot.objects_in_pot` list, converting each ingredient to its type ID. Populate `pot_timer` from `pot.cooking_timer`.
7. For spawn points: check if cell matches `GridConstants.Spawn` character (check existing spawn point detection logic in `cogrid_env.py`)

CRITICAL: The type IDs assigned here MUST match what `get_object_names(scope)` returns. Use `object_to_idx()` directly -- do not create a separate mapping.

Also add a helper function:
```python
def grid_to_array_state(grid, env_agents, scope: str = "global") -> dict:
```
This is a convenience wrapper that calls `layout_to_array_state()` for the grid AND `create_agent_arrays()` for the agents (from Task 2), returning a combined dict.

IMPORTANT: This function works with the EXISTING Grid object. It does NOT replace the Grid. In Phase 1, the Grid still exists and is the source of truth. These array functions create a parallel array representation that will be used by vectorized operations. In later plans, the array state will be updated alongside the Grid during step().

Add `# PHASE2: This function will operate on EnvState pytree instead of Grid object` comment.
  </action>
  <verify>
Run: `python -c "
import cogrid.envs  # register environments
from cogrid.core.layouts import get_layout
from cogrid.core.grid import Grid
from cogrid.core.grid_utils import layout_to_array_state
from cogrid.core.grid_object import get_object_names, object_to_idx

# Load cramped_room layout
name, layout, state = get_layout('cramped_room')
grid = Grid(len(layout), len(layout[0]))
grid.decode(layout, state, scope='overcooked')

result = layout_to_array_state(grid, scope='overcooked')
print('object_type_map shape:', result['object_type_map'].shape)
print('wall_map shape:', result['wall_map'].shape)
print('pot_contents shape:', result['pot_contents'].shape)
print('pot_timer shape:', result['pot_timer'].shape)
print('n_pots:', len(result['pot_positions']))

# Verify wall_map has walls
assert result['wall_map'].sum() > 0, 'Should have walls'
# Verify object_type_map has pot
pot_idx = object_to_idx('pot', scope='overcooked')
assert (result['object_type_map'] == pot_idx).sum() > 0, 'Should have pots'
# Verify pot_contents uses -1 sentinel
assert (result['pot_contents'] == -1).all(), 'Empty pots should have -1 sentinel'
print('ALL CHECKS PASSED')
"` succeeds.
  </verify>
  <done>
`layout_to_array_state()` converts a Grid object into array-based state matching the locked encoding conventions. `object_type_map` uses 0 for empty cells, `pot_contents` uses -1 sentinel, `wall_map` is boolean. Type IDs match `object_to_idx()` exactly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create agent array state functions</name>
  <files>cogrid/core/agent.py</files>
  <action>
Add functions to `cogrid/core/agent.py` for creating and updating array-based agent state:

**`create_agent_arrays(env_agents: dict, scope: str = "global") -> dict`:**
- Takes the existing `env_agents` dict (mapping `AgentID -> Agent`) and creates array representations
- Returns dict with:
  - `"agent_pos"`: `xp.ndarray` of shape `(n_agents, 2)`, dtype `int32`. Each row is `[row, col]` from `agent.pos`.
  - `"agent_dir"`: `xp.ndarray` of shape `(n_agents,)`, dtype `int32`. Direction integer from `agent.dir` (0=Right, 1=Down, 2=Left, 3=Up per existing `Directions` enum).
  - `"agent_inv"`: `xp.ndarray` of shape `(n_agents, 1)`, dtype `int32`. Contains the type ID of the held item via `object_to_idx(item.object_id, scope)`, or -1 if inventory empty (per locked decision: -1 sentinel for empty inventory).
  - `"agent_ids"`: list of AgentID strings in the order corresponding to array indices (so we can map back from array index to agent ID)
  - `"n_agents"`: integer count
- Import `from cogrid.backend import xp` inside function body
- Import `from cogrid.core.grid_object import object_to_idx`
- Iterate over `env_agents.items()` in sorted order (by agent_id) for deterministic array ordering
- For inventory: each agent has a list `agent.inventory`. If empty, set `agent_inv[i, 0] = -1`. If non-empty, set `agent_inv[i, 0] = object_to_idx(agent.inventory[0].object_id, scope=scope)`.

**`sync_arrays_to_agents(agent_arrays: dict, env_agents: dict) -> None`:**
- Inverse operation: updates Agent objects from array state (needed during Phase 1 transition period)
- For each agent in sorted order:
  - `agent.pos = tuple(agent_arrays["agent_pos"][i])`
  - `agent.dir = int(agent_arrays["agent_dir"][i])`
  - Inventory sync is more complex (type ID back to object) -- defer this to the interaction plan (Plan 04). For now, just update pos and dir.
- Add comment `# PHASE2: This function will be removed when Grid/Agent objects are replaced by EnvState`

**Direction vector lookup table constant:**
```python
# Direction vectors as a numpy array for vectorized lookups
# Indexed by direction enum: Right=0, Down=1, Left=2, Up=3
# Each row is [delta_row, delta_col]
DIR_VEC_TABLE = None  # Initialized lazily after backend is set

def get_dir_vec_table():
    global DIR_VEC_TABLE
    if DIR_VEC_TABLE is None:
        from cogrid.backend import xp
        DIR_VEC_TABLE = xp.array([
            [0, 1],    # Right (0) -- increase col
            [1, 0],    # Down  (1) -- increase row
            [0, -1],   # Left  (2) -- decrease col
            [-1, 0],   # Up    (3) -- decrease row
        ], dtype=xp.int32)
    return DIR_VEC_TABLE
```

This matches the existing direction encoding in `cogrid/core/directions.py` (Right=0, Down=1, Left=2, Up=3) and the existing `Agent.dir_vec` property which returns the same vectors.

Add comment `# PHASE2: DIR_VEC_TABLE will be a constant in the EnvState module` on the table definition.
  </action>
  <verify>
Run: `python -c "
from cogrid.core.agent import Agent, create_agent_arrays, get_dir_vec_table
from cogrid.core.directions import Directions
import numpy as np

# Create test agents
agents = {}
a1 = Agent(agent_id='agent_0', start_position=(1, 2), start_direction=Directions.Right)
a2 = Agent(agent_id='agent_1', start_position=(3, 4), start_direction=Directions.Up)
agents['agent_0'] = a1
agents['agent_1'] = a2

arrays = create_agent_arrays(agents, scope='global')
print('agent_pos:', arrays['agent_pos'])
print('agent_dir:', arrays['agent_dir'])
print('agent_inv:', arrays['agent_inv'])
assert arrays['agent_pos'].shape == (2, 2), f'Wrong shape: {arrays[\"agent_pos\"].shape}'
assert arrays['agent_dir'].shape == (2,), f'Wrong shape: {arrays[\"agent_dir\"].shape}'
assert arrays['agent_inv'].shape == (2, 1), f'Wrong shape: {arrays[\"agent_inv\"].shape}'
assert np.array_equal(arrays['agent_pos'][0], [1, 2])
assert arrays['agent_dir'][0] == 0  # Right
assert arrays['agent_dir'][1] == 3  # Up
assert (arrays['agent_inv'] == -1).all(), 'Empty inventory should be -1'

# Test DIR_VEC_TABLE
dvt = get_dir_vec_table()
assert dvt.shape == (4, 2)
assert np.array_equal(dvt[0], [0, 1])   # Right
assert np.array_equal(dvt[3], [-1, 0])  # Up
print('ALL CHECKS PASSED')
"` succeeds.
Run existing tests: `python -m pytest cogrid/test_gridworld_env.py cogrid/test_overcooked_env.py -x -q` -- all pass.
  </verify>
  <done>
`create_agent_arrays()` converts Agent objects to array representation. `agent_pos` is `(n_agents, 2)`, `agent_dir` is `(n_agents,)`, `agent_inv` is `(n_agents, 1)` with -1 sentinel. `get_dir_vec_table()` returns `(4, 2)` direction vector lookup table matching existing direction encoding. `sync_arrays_to_agents()` updates Agent objects from arrays. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `layout_to_array_state()` produces correct arrays for cramped_room layout
2. Array type IDs match `object_to_idx()` encoding exactly
3. `create_agent_arrays()` produces correct shapes and values
4. Empty inventory uses -1 sentinel, empty grid cells use 0
5. `pot_contents` uses -1 sentinel, `pot_timer` initialized correctly
6. Direction vector table matches existing `Agent.dir_vec` property
7. All existing tests pass unchanged
</verification>

<success_criteria>
- ASCII layout can be converted to array-based state representation
- Agent state converted to array representation with correct shapes
- Sentinel values match locked decisions (-1 for inventory/pot, 0 for empty grid cells)
- Direction vector lookup table exists and is correct
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-dual-backend-vectorized-core-rewrite/01-02-SUMMARY.md`
</output>

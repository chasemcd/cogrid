---
phase: 01-dual-backend-vectorized-core-rewrite
plan: 04
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - cogrid/core/interactions.py
autonomous: true

must_haves:
  truths:
    - "Pickup action uses CAN_PICKUP lookup table and updates inventory array"
    - "Pickup-from action uses CAN_PICKUP_FROM lookup table for stacks and ready pots"
    - "Drop action updates grid state arrays (clears inventory, sets object on grid)"
    - "Place-on action uses CAN_PLACE_ON lookup table for counters and pots"
    - "Pot interaction: adding ingredient updates pot_contents array, respects capacity and same-type constraint"
    - "Pot pickup-from: requires plate in inventory, returns soup type based on contents, clears pot"
    - "Pot tick: decrements timer when full, timer reaches 0 means ready"
    - "All property checks use integer lookup tables, not isinstance()"
    - "Interaction priority order matches existing code: can_pickup > can_pickup_from > drop_empty > place_on"
  artifacts:
    - path: "cogrid/core/interactions.py"
      provides: "process_interactions_array() and tick_objects_array() functions"
      contains: "def process_interactions_array"
      min_lines: 100
  key_links:
    - from: "cogrid/core/interactions.py"
      to: "cogrid/core/grid_object.py"
      via: "build_lookup_tables for property arrays"
      pattern: "CAN_PICKUP|CAN_OVERLAP|CAN_PLACE_ON|CAN_PICKUP_FROM"
    - from: "cogrid/core/interactions.py"
      to: "cogrid/backend"
      via: "xp for array operations"
      pattern: "from cogrid.backend import xp"
---

<objective>
Create vectorized interaction processing that replaces isinstance()-based dispatch with integer lookup table operations for pickup, drop, place-on, and pot interactions.

Purpose: The existing `interact()` method in `cogrid_env.py:564-645` uses `isinstance()` checks and Python object manipulation for every interaction. The vectorized version uses integer type codes and property lookup tables, operating on array state directly. This is the most complex single plan in the phase due to the pot cooking state machine and the 5-branch interaction priority.

Output: New file `cogrid/core/interactions.py` with `process_interactions_array()` and `tick_objects_array()`.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-RESEARCH.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-CONTEXT.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-01-SUMMARY.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-02-SUMMARY.md
@cogrid/cogrid_env.py (lines 564-645 for existing interact())
@cogrid/envs/overcooked/overcooked_grid_objects.py (Pot class for cooking logic)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement interaction processing with lookup tables</name>
  <files>cogrid/core/interactions.py</files>
  <action>
Create NEW file `cogrid/core/interactions.py` with the following functions:

**`process_interactions_array()` function:**

```python
def process_interactions_array(
    agent_pos,         # (n_agents, 2) int32
    agent_dir,         # (n_agents,) int32
    agent_inv,         # (n_agents, 1) int32, -1 = empty
    actions,           # (n_agents,) int32
    object_type_map,   # (H, W) int32
    object_state_map,  # (H, W) int32
    pot_contents,      # (n_pots, 3) int32, -1 = empty slot
    pot_timer,         # (n_pots,) int32
    pot_positions,     # list of (row, col) or (n_pots, 2) int32
    lookup_tables,     # dict with CAN_PICKUP, CAN_OVERLAP, CAN_PLACE_ON, CAN_PICKUP_FROM
    type_registry,     # dict mapping type_id -> object_id string (for determining soup type)
    scope,             # str -- for object_to_idx lookups
    dir_vec_table,     # (4, 2) int32 -- direction vectors
    action_pickup_drop_idx, # int -- index of PickupDrop action
    action_toggle_idx,      # int -- index of Toggle action
) -> tuple:  # Returns (new_agent_inv, new_object_type_map, new_object_state_map, new_pot_contents, new_pot_timer)
```

**Implementation MUST match the exact priority order from `cogrid_env.py:573-643`:**

For each agent (Phase 1: loop over agents since interactions can affect shared grid state; mark `# PHASE2: vectorize with careful ordering`):

1. **Skip non-interaction actions:** If `action != action_pickup_drop_idx`, skip (rotate/toggle handled elsewhere)

2. **Compute forward position:** `fwd_pos = agent_pos[i] + dir_vec_table[agent_dir[i]]`

3. **Check agent ahead:** If any other agent is at `fwd_pos`, skip this agent's interaction (matching line 593-594). Check `xp.any(xp.all(agent_pos == fwd_pos[None, :], axis=1) & (xp.arange(n_agents) != i))`

4. **Get forward cell type:** `fwd_type = object_type_map[fwd_pos[0], fwd_pos[1]]`

5. **Priority branch 1 -- can_pickup (lines 598-606):**
   - Condition: `fwd_type > 0 AND CAN_PICKUP[fwd_type] == 1 AND agent_inv[i, 0] == -1` (has object, it's pickupable, agent has empty inventory)
   - Action: `agent_inv[i, 0] = fwd_type`, `object_type_map[fwd_pos] = 0`, `object_state_map[fwd_pos] = 0`
   - NOTE: The existing code also checks `agent.can_pickup(grid_object=fwd_cell)` which for OvercookedAgent always returns True for pickupable items. For generality, assume the lookup table CAN_PICKUP is sufficient.

6. **Priority branch 2 -- can_pickup_from (lines 607-615):**
   - Condition: `fwd_type > 0 AND CAN_PICKUP_FROM[fwd_type] == 1 AND agent_inv[i, 0] == -1`
   - This handles stacks (OnionStack, TomatoStack, PlateStack) and ready Pots
   - For stacks: determine what item the stack dispenses. Need a lookup: `PICKUP_FROM_PRODUCES[fwd_type]` -> type_id of produced item. E.g., OnionStack produces Onion, PlateStack produces Plate.
   - Build this as a separate array at init time: `PICKUP_FROM_PRODUCES = xp.zeros(n_types, dtype=int32)` with `PICKUP_FROM_PRODUCES[onion_stack_id] = onion_id`, etc.
   - For pots: special case. `CAN_PICKUP_FROM` is True for pots, but the pot also requires: timer == 0 (dish_ready) AND agent holds Plate. Check:
     - Is this a pot? (fwd_type == pot_type_id)
     - If pot: find pot index from `pot_positions`. Check `pot_timer[pot_idx] == 0`. Check `agent_inv[i, 0] == plate_type_id`.
     - If all conditions met: determine soup type from pot_contents (all tomato -> tomato_soup, else onion_soup per existing code). Set `agent_inv[i, 0] = soup_type_id`. Clear `pot_contents[pot_idx] = -1`. Reset `pot_timer[pot_idx] = cooking_time`. (The plate is consumed -- it was already in inventory and gets replaced by soup.)
   - For non-pot pickupable-from: `agent_inv[i, 0] = PICKUP_FROM_PRODUCES[fwd_type]`

7. **Priority branch 3 -- drop on empty (lines 616-619):**
   - Condition: `fwd_type == 0 AND agent_inv[i, 0] != -1` (empty cell AND agent has item)
   - Action: `object_type_map[fwd_pos] = agent_inv[i, 0]`, `agent_inv[i, 0] = -1`

8. **Priority branch 4 -- place_on (lines 620-631):**
   - Condition: `fwd_type > 0 AND CAN_PLACE_ON[fwd_type] == 1 AND agent_inv[i, 0] != -1`
   - For counters: check if counter already has an object placed (this is tracked via `object_state_map` or a separate placed_type field). SIMPLIFICATION for Phase 1: For counters, the existing code checks `self.obj_placed_on is None`. In the array world, we need to track "what's placed on this counter". One approach: use `object_state_map[r, c]` to store the placed object's type ID (0 = nothing placed). Check `object_state_map[fwd_pos] == 0` for empty counter.
   - Actually, re-reading the existing code more carefully: when you `place_on` a counter, the object is placed ON the counter but the counter itself remains. The grid cell still shows the counter. The `fwd_cell.place_on(cell=drop_cell, agent=agent)` stores the item internally. For the array representation: we need an additional array `placed_on_map[h, w]` to track what's placed on each cell, OR encode it in `object_state_map`. For simplicity: use `object_state_map[r, c]` as the "placed item type ID" for objects that support `can_place_on`. When `object_state_map > 0`, something is placed there.
   - For pots: the `can_place_on` check also requires: ingredient is legal, same type as existing contents, pot not full. Check:
     - Is this a pot? (fwd_type == pot_type_id)
     - Pot has capacity: count non-sentinel entries in `pot_contents[pot_idx]` < 3
     - Ingredient matches: if pot has items, the item type must match existing items. Check first non-sentinel entry: if all existing entries == agent_inv[i, 0] or all are -1, it's valid. Per research Pitfall 2.
     - Ingredient is legal: check against a `LEGAL_POT_INGREDIENTS` array (onion_id and tomato_id)
     - If valid: find first -1 slot in `pot_contents[pot_idx]`, set it to `agent_inv[i, 0]`. Set `agent_inv[i, 0] = -1`.
   - For non-pot place_on (e.g., counter, delivery_zone): `object_state_map[fwd_pos] = agent_inv[i, 0]`, `agent_inv[i, 0] = -1`

**Special type IDs needed:** The function needs to know specific type IDs (pot_type_id, plate_type_id, onion_soup_id, tomato_soup_id, tomato_id, onion_id). Pass these via a `type_ids` dict parameter or compute from `object_to_idx(name, scope)`.

**Rotation handling:** Also handle RotateLeft/RotateRight actions in this function for completeness:
- If action == rotate_left_idx: `agent_dir[i] = (agent_dir[i] - 1) % 4` (but wait -- check existing code. `rotate_left()` in agent.py uses `(self.dir - 1) % 4`? Actually check: Directions are Right=0, Down=1, Left=2, Up=3. RotateRight goes clockwise: Right->Down->Left->Up = (dir + 1) % 4. RotateLeft goes counter-clockwise: Right->Up->Left->Down = (dir - 1) % 4. Verify against existing code.)
- These can be vectorized: `is_rotate_left = actions == rotate_left_idx; new_dir = xp.where(is_rotate_left, (agent_dir - 1) % 4, agent_dir)`. Same for rotate_right.

**`tick_objects_array()` function:**

```python
def tick_objects_array(
    pot_contents,   # (n_pots, 3) int32
    pot_timer,      # (n_pots,) int32
    capacity=3,     # max items per pot
    cooking_time=30,# initial timer value
) -> tuple:        # Returns (new_pot_contents, new_pot_timer, new_object_state_map updates)
```

Matches existing `Pot.tick()` behavior (lines 211-220 of overcooked_grid_objects.py):
- For each pot: count non-sentinel items: `n_items = xp.sum(pot_contents[p] != -1)`
- If `n_items == capacity AND pot_timer[p] > 0`: `pot_timer[p] -= 1` (cooking)
- Update state: `state = n_items + n_items * pot_timer[p]` (matching existing encoding)
- This CAN be vectorized across pots:
  ```python
  n_items = xp.sum(pot_contents != -1, axis=1)  # (n_pots,)
  is_cooking = (n_items == capacity) & (pot_timer > 0)
  pot_timer = xp.where(is_cooking, pot_timer - 1, pot_timer)  # PHASE2: use .at[].set()
  pot_state = n_items + n_items * pot_timer
  ```
- Return updated pot_timer and pot_state values (to write back into object_state_map at pot positions)

Mark all mutation sites with `# PHASE2: convert to .at[].set()` comments.

IMPORTANT: This plan creates the interaction functions but does NOT wire them into CoGridEnv.step() yet. That wiring happens in Plan 07 (integration). These are standalone functions that take array state and return updated array state.
  </action>
  <verify>
Run: `python -c "
import numpy as np
from cogrid.core.interactions import process_interactions_array, tick_objects_array
from cogrid.core.grid_object import build_lookup_tables, object_to_idx, get_object_names
from cogrid.core.agent import get_dir_vec_table
import cogrid.envs  # trigger registration

scope = 'overcooked'
names = get_object_names(scope=scope)
tables = build_lookup_tables(scope=scope)

# Get type IDs
pot_id = object_to_idx('pot', scope=scope)
onion_id = object_to_idx('onion', scope=scope)
plate_id = object_to_idx('plate', scope=scope)
counter_id = object_to_idx('counter', scope=scope)

# Test tick_objects_array
pot_contents = np.array([[-1, -1, -1], [onion_id, onion_id, onion_id]], dtype=np.int32)
pot_timer = np.array([30, 30], dtype=np.int32)

# First tick: pot 0 empty (no change), pot 1 full (timer decrements)
new_contents, new_timer, _ = tick_objects_array(pot_contents, pot_timer)
assert new_timer[0] == 30, f'Empty pot timer should stay 30: {new_timer[0]}'
assert new_timer[1] == 29, f'Full pot timer should decrement: {new_timer[1]}'
print('tick_objects_array: PASSED')

# Test basic pickup
agent_pos = np.array([[1, 1]], dtype=np.int32)
agent_dir = np.array([0], dtype=np.int32)  # Facing Right
agent_inv = np.array([[-1]], dtype=np.int32)  # Empty inventory
actions = np.array([4], dtype=np.int32)  # PickupDrop (index 4 in CardinalActions)

object_type_map = np.zeros((5, 5), dtype=np.int32)
object_state_map = np.zeros((5, 5), dtype=np.int32)
object_type_map[1, 2] = onion_id  # Onion in front of agent

dir_vec_table = get_dir_vec_table()

# Build type_ids dict
type_ids = {
    'pot': pot_id,
    'onion': onion_id,
    'plate': plate_id,
    'onion_soup': object_to_idx('onion_soup', scope=scope),
    'tomato_soup': object_to_idx('tomato_soup', scope=scope),
    'tomato': object_to_idx('tomato', scope=scope),
}

# Build PICKUP_FROM_PRODUCES
pickup_from_produces = np.zeros(len(names), dtype=np.int32)
pickup_from_produces[object_to_idx('onion_stack', scope=scope)] = onion_id
pickup_from_produces[object_to_idx('tomato_stack', scope=scope)] = object_to_idx('tomato', scope=scope)
pickup_from_produces[object_to_idx('plate_stack', scope=scope)] = plate_id

new_inv, new_otm, new_osm, new_pc, new_pt = process_interactions_array(
    agent_pos, agent_dir, agent_inv, actions,
    object_type_map, object_state_map,
    np.array([[-1, -1, -1]], dtype=np.int32),  # no pots for this test
    np.array([30], dtype=np.int32),
    np.array([[0, 0]], dtype=np.int32),  # dummy pot position
    tables,
    type_ids,
    scope,
    dir_vec_table,
    4,  # action_pickup_drop_idx
    5,  # action_toggle_idx
)
assert new_inv[0, 0] == onion_id, f'Agent should have picked up onion: {new_inv[0, 0]}'
assert new_otm[1, 2] == 0, f'Onion should be removed from grid: {new_otm[1, 2]}'
print('Pickup test: PASSED')
print('ALL INTERACTION TESTS PASSED')
"` succeeds.

Run existing tests: `python -m pytest cogrid/test_gridworld_env.py cogrid/test_overcooked_env.py -x -q` -- all pass.
  </verify>
  <done>
`cogrid/core/interactions.py` exists with:
- `process_interactions_array()` handling all 4 interaction branches (pickup, pickup_from, drop, place_on) using lookup tables instead of isinstance()
- `tick_objects_array()` implementing vectorized pot cooking timer
- Pot cooking state machine matching existing semantics (auto-cook on full, timer countdown, soup type determination)
- Interaction priority order matching existing code exactly
- All mutation sites marked for Phase 2 conversion
  </done>
</task>

<task type="auto">
  <name>Task 2: Add interaction parity test</name>
  <files>cogrid/core/interactions.py</files>
  <action>
Add a `test_interaction_parity()` function to `cogrid/core/interactions.py` that validates the array-based interactions produce identical results to the existing object-based interactions.

**Approach:**
1. Instantiate an Overcooked environment (cramped_room), reset it
2. Run 100 random steps. At each step:
   a. Before `interact()`, capture the array state from the Grid
   b. Run `process_interactions_array()` with the same actions
   c. Let the existing `interact()` also run
   d. Compare: agent inventories, object types on grid, pot contents, pot timers
3. Also test `tick_objects_array()` parity against existing `Grid.tick()`

Focus on key scenarios:
- Agent picks up onion from onion stack
- Agent places onion in pot
- Pot cooking timer progression
- Agent picks up plate, collects soup from ready pot
- Agent drops soup on delivery zone

Since these scenarios may not all occur in 100 random steps, also set up specific deterministic test cases for each.

Mark as development-time parity test: `# DEV: Remove or move to test suite after integration`
  </action>
  <verify>
Run: `python -c "from cogrid.core.interactions import test_interaction_parity; test_interaction_parity()"` -- prints success.
  </verify>
  <done>
Parity test confirms array-based interactions match existing object-based interactions for random and deterministic test cases. Pickup, drop, place-on, and pot cooking all produce identical results.
  </done>
</task>

</tasks>

<verification>
1. Pickup uses CAN_PICKUP lookup table, updates inventory array, clears grid cell
2. Pickup-from handles stacks (dispenses correct item) and pots (requires plate, produces correct soup)
3. Drop places item from inventory onto empty grid cell
4. Place-on handles counters and pots with correct constraint checking
5. Pot cooking: timer decrements when full, ready when timer==0, same-type ingredient enforcement
6. Interaction priority order matches existing code exactly
7. Parity test passes against existing implementation
8. All existing tests pass unchanged
</verification>

<success_criteria>
- `process_interactions_array()` handles all 4 interaction branches with lookup tables
- `tick_objects_array()` implements vectorized pot cooking
- Pot state machine matches existing semantics exactly
- Interaction parity test passes
- No isinstance() calls in the step path
</success_criteria>

<output>
After completion, create `.planning/phases/01-dual-backend-vectorized-core-rewrite/01-04-SUMMARY.md`
</output>

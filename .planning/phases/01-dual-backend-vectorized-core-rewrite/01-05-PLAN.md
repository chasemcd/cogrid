---
phase: 01-dual-backend-vectorized-core-rewrite
plan: 05
type: execute
wave: 4
depends_on: ["01-01", "01-02"]
files_modified:
  - cogrid/feature_space/array_features.py
  - cogrid/feature_space/feature_space.py
autonomous: true

must_haves:
  truths:
    - "agent_pos feature returns (2,) array from agent_pos state array, not from Agent object"
    - "agent_dir feature returns (4,) one-hot from agent_dir state array"
    - "full_map_encoding feature returns (max_H, max_W, 3) from object_type_map/object_state_map arrays"
    - "can_move_direction feature returns (4,) multi-hot from wall_map and object_type_map arrays"
    - "Feature composition resolved at init time, composed function operates on state arrays"
    - "Per-agent observations generated without Python loop over agents for array-based features"
    - "Observation arrays are numerically identical to current features for same grid state"
  artifacts:
    - path: "cogrid/feature_space/array_features.py"
      provides: "Array-based feature extractors: agent_pos_array, agent_dir_array, full_map_encoding_array, can_move_direction_array, inventory_array"
      contains: "def agent_pos_feature"
      min_lines: 60
  key_links:
    - from: "cogrid/feature_space/array_features.py"
      to: "cogrid/backend"
      via: "xp import for array operations"
      pattern: "from cogrid.backend import xp"
    - from: "cogrid/feature_space/array_features.py"
      to: "cogrid/core/grid_object.py"
      via: "get_object_names for encoding indices"
      pattern: "get_object_names|object_to_idx"
---

<objective>
Create array-based feature extractors that operate on state arrays instead of Grid/Agent objects, with feature composition resolved at init time.

Purpose: The existing feature system calls `env.grid.encode()`, `env.env_agents[id].pos`, etc. -- all operating on mutable Python objects. The array-based extractors operate directly on state arrays (agent_pos, agent_dir, object_type_map, etc.), producing numerically identical observations. Feature composition (which features to include, in what order) is resolved at init time, producing a single composed function that can be called with state arrays.

Output: New file `cogrid/feature_space/array_features.py` with standalone feature functions and a composition utility.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-RESEARCH.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-CONTEXT.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-01-SUMMARY.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-02-SUMMARY.md
@cogrid/feature_space/features.py
@cogrid/envs/overcooked/overcooked_features.py
@cogrid/feature_space/feature.py
@cogrid/feature_space/feature_space.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create array-based core feature extractors</name>
  <files>cogrid/feature_space/array_features.py</files>
  <action>
Create NEW file `cogrid/feature_space/array_features.py` with pure-function feature extractors that operate on state arrays.

Each function takes state arrays as input and returns the feature array. No env/Grid/Agent object access.

**Core features (matching OBS-01 requirements):**

1. **`agent_pos_feature(agent_pos, agent_idx) -> ndarray`:**
   - Returns `agent_pos[agent_idx]` -- shape `(2,)`, dtype int32
   - Matches existing `AgentPosition.generate()`

2. **`agent_dir_feature(agent_dir, agent_idx) -> ndarray`:**
   - One-hot encoding of direction: shape `(4,)`, dtype int32
   - `encoding = xp.zeros(4, dtype=xp.int32); encoding[agent_dir[agent_idx]] = 1`
   - Matches existing `AgentDir.generate()`

3. **`full_map_encoding_feature(object_type_map, object_state_map, grid_agents_encoding, max_map_size=(12, 12)) -> ndarray`:**
   - Returns `(max_H, max_W, 3)` array padded with zeros
   - Channel 0: type IDs from `object_type_map` (matching Grid.encode channel 0)
   - Channel 1: color indices -- need a TYPE_TO_COLOR lookup table built at init, OR just use the existing grid encoding format. Actually the existing `Grid.encode(encode_char=False)` returns `(H, W, 3)` with channels (type_idx, color_idx, state). For parity, we need the same 3 channels. The type_idx comes from `object_type_map`. The color_idx needs a `TYPE_TO_COLOR[type_id]` lookup. The state comes from `object_state_map`.
   - Build `TYPE_TO_COLOR` array at init time from `get_object_names()` and each object class's `color` attribute.
   - `grid_agents_encoding` is needed to render agents on the grid (they appear as "agent_^", "agent_>", etc. in the encoding). For each agent position, override the type/color/state with agent encoding. The agent type_idx is `object_to_idx(f"agent_{dir_char}", scope)`.
   - Pad to max_map_size with zeros
   - Matches existing `FullMapEncoding.generate()`

4. **`can_move_direction_feature(agent_pos, agent_idx, wall_map, object_type_map, can_overlap_table) -> ndarray`:**
   - Returns `(4,)` multi-hot: 1 if agent can move in that direction
   - For each of 4 adjacent positions (Right, Down, Left, Up): check if cell is in bounds, not a wall, and object there is overlappable
   - Adjacent positions follow the same order as existing `grid_utils.adjacent_positions()`: check the exact order
   - `from cogrid.core.grid_utils import adjacent_positions` or compute inline
   - Matches existing `CanMoveDirection.generate()`

5. **`inventory_feature(agent_inv, agent_idx) -> ndarray`:**
   - Returns `(1,)` array with the inventory type ID (or 0 if empty... wait, check existing: `Inventory.generate()` returns `object_to_idx(item) + 1` for items, 0 for empty. Our array uses -1 for empty. Need to match the existing encoding.)
   - Check existing `Inventory.generate()` code carefully: it does `get_object_names(scope).index(obj.object_id) + 1` for items, and `encoding` starts as zeros (0 for empty). So the feature encodes inventory as: 0 = empty, N+1 = type N.
   - Our `agent_inv` uses: -1 = empty, type_id = type.
   - Conversion: `feature_val = xp.where(agent_inv[agent_idx, 0] == -1, 0, agent_inv[agent_idx, 0] + 1)`
   - Wait, re-check: `object_to_idx(item, scope)` returns the index in `get_object_names()`. The existing feature does `.index(obj.object_id) + 1`. So it adds 1. If `object_to_idx("onion", scope="overcooked")` returns 8, the feature value would be 9. And if `agent_inv` stores `object_to_idx("onion")` = 8, then `feature_val = 8 + 1 = 9`. This matches as long as `agent_inv` stores the same index. Verify this.
   - Actually wait: the existing code does `get_object_names(scope=env.scope).index(obj.object_id) + 1`, which is just `object_to_idx(obj, scope) + 1`. Our `agent_inv` stores `object_to_idx(obj, scope)`. So `feature = agent_inv + 1` for non-empty, `0` for empty.
   - Final: `feature_val = xp.where(agent_inv[agent_idx, 0] == -1, 0, agent_inv[agent_idx, 0] + 1)`

**Feature composition utility:**

```python
def compose_features(feature_fns: list[callable], state_dict: dict, agent_idx: int) -> ndarray:
    """Compose multiple feature functions into a single observation array.

    Each feature_fn takes (state_dict, agent_idx) and returns an ndarray.
    Results are concatenated into a flat array.
    """
    features = [fn(state_dict, agent_idx) for fn in feature_fns]
    return xp.concatenate([f.ravel() for f in features])
```

**Init-time composition resolver:**

```python
def build_feature_fn(feature_names: list[str], scope: str, **kwargs) -> callable:
    """Build a composed feature function from feature names.

    Called at init time. Returns a function that takes (state_dict, agent_idx) -> obs_array.
    Resolves which features to include and their parameters once at init.
    """
```

This function maps feature name strings to the array-based functions above. The returned composed function captures all parameters via closure.

**Per-agent vectorization (OBS-04):**
For features that are per-agent (agent_pos, agent_dir, inventory, can_move_direction), create a vectorized version:

```python
def get_all_agent_obs(feature_fn, state_dict, n_agents) -> ndarray:
    """Generate observations for all agents.

    Returns (n_agents, obs_dim) array.
    # PHASE2: convert to vmap
    """
    return xp.stack([feature_fn(state_dict, i) for i in range(n_agents)])
```

Phase 1 uses a Python loop; Phase 2 converts to `jax.vmap`. Mark with comment.

NOTE: Not all existing features need array-based versions in this plan. Focus on the CORE features listed in OBS-01: agent_pos, agent_dir, full_map_encoding, can_move_direction, plus inventory. The Overcooked-specific features (ClosestObj, PotFeatures, DistToOtherPlayers, etc.) are more complex and can continue using the existing object-based path until the integration plan wires both paths together.

IMPORTANT: These array features do NOT replace the existing Feature classes. They exist alongside them. The integration plan (Plan 07) will wire them into the observation pipeline. For now, they are standalone functions that can be tested independently.
  </action>
  <verify>
Run: `python -c "
import numpy as np
import cogrid.envs  # trigger registration
from cogrid.feature_space.array_features import (
    agent_pos_feature, agent_dir_feature, can_move_direction_feature,
    inventory_feature, full_map_encoding_feature
)
from cogrid.core.grid_object import get_object_names, object_to_idx, build_lookup_tables
from cogrid.core.grid_utils import layout_to_array_state
from cogrid.core.agent import create_agent_arrays
from cogrid.core.layouts import get_layout
from cogrid.core.grid import Grid

# Setup
scope = 'overcooked'
name, layout, state = get_layout('cramped_room')
grid = Grid(len(layout), len(layout[0]))
grid.decode(layout, state, scope=scope)
array_state = layout_to_array_state(grid, scope=scope)

# Create mock agent arrays
agent_pos = np.array([[1, 1], [1, 3]], dtype=np.int32)
agent_dir = np.array([0, 2], dtype=np.int32)  # Right, Left
agent_inv = np.array([[-1], [-1]], dtype=np.int32)

# Test agent_pos_feature
pos = agent_pos_feature(agent_pos, 0)
assert np.array_equal(pos, [1, 1]), f'Wrong pos: {pos}'
print('agent_pos_feature: PASSED')

# Test agent_dir_feature
d = agent_dir_feature(agent_dir, 0)
assert d.shape == (4,)
assert d[0] == 1 and d.sum() == 1, f'Wrong dir encoding: {d}'
print('agent_dir_feature: PASSED')

# Test can_move_direction_feature
tables = build_lookup_tables(scope=scope)
cm = can_move_direction_feature(agent_pos, 0, array_state['wall_map'], array_state['object_type_map'], tables['CAN_OVERLAP'])
assert cm.shape == (4,), f'Wrong shape: {cm.shape}'
print('can_move_direction_feature: PASSED (shape correct)')

# Test inventory_feature
inv = inventory_feature(agent_inv, 0)
assert inv.shape == (1,) and inv[0] == 0, f'Empty inventory should be 0: {inv}'
# Test with item
onion_id = object_to_idx('onion', scope=scope)
agent_inv_with_onion = np.array([[onion_id], [-1]], dtype=np.int32)
inv2 = inventory_feature(agent_inv_with_onion, 0)
assert inv2[0] == onion_id + 1, f'Should be onion_id+1={onion_id+1}, got {inv2[0]}'
print('inventory_feature: PASSED')

print('ALL FEATURE TESTS PASSED')
"` succeeds.

Run existing tests: `python -m pytest cogrid/test_gridworld_env.py cogrid/test_overcooked_env.py -x -q` -- all pass.
  </verify>
  <done>
Array-based feature extractors exist: agent_pos, agent_dir, full_map_encoding, can_move_direction, inventory. All operate on state arrays, not Grid/Agent objects. Feature composition utility resolves at init time. Per-agent observation generation works (Python loop, marked for Phase 2 vmap). All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Validate feature parity against existing feature system</name>
  <files>cogrid/feature_space/array_features.py</files>
  <action>
Add a `test_feature_parity()` function that validates array-based features produce identical values to existing Feature.generate() for the same state.

**Approach:**
1. Instantiate an Overcooked environment (cramped_room), reset it
2. For each core feature (agent_pos, agent_dir, full_map_encoding, can_move_direction, inventory):
   a. Get the existing feature output via the env's feature system
   b. Convert env state to array state
   c. Get the array-based feature output
   d. Assert `np.array_equal(existing_output, array_output)` or `np.allclose()` for float features
3. Run for 20 steps with random actions to check multiple states

Focus on exact numerical parity. Any difference means the array encoding or feature logic doesn't match.

Known complexity: `full_map_encoding` requires agent overlays (agents rendered on the grid encoding). Make sure the array version handles this correctly -- agents appear as their direction-specific type ID in the encoding.

Mark as development-time parity test.
  </action>
  <verify>
Run: `python -c "from cogrid.feature_space.array_features import test_feature_parity; test_feature_parity()"` -- prints success.
  </verify>
  <done>
Feature parity test confirms array-based features produce numerically identical outputs to existing Feature.generate() system for agent_pos, agent_dir, full_map_encoding, can_move_direction, and inventory across 20 random steps.
  </done>
</task>

</tasks>

<verification>
1. All core feature extractors produce correct shapes and values
2. Feature composition resolves at init time
3. Per-agent observations generated (Python loop for Phase 1, marked for vmap)
4. Parity test confirms numerical identity with existing feature system
5. All existing tests pass unchanged
</verification>

<success_criteria>
- Array-based versions of agent_pos, agent_dir, full_map_encoding, can_move_direction, inventory exist
- Features operate on state arrays, not Grid/Agent objects
- Composition resolved at init time via build_feature_fn()
- Feature parity test passes for 20+ steps
- No regression in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/01-dual-backend-vectorized-core-rewrite/01-05-SUMMARY.md`
</output>

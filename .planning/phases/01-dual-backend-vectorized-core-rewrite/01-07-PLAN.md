---
phase: 01-dual-backend-vectorized-core-rewrite
plan: 07
type: execute
wave: 5
depends_on: ["01-01", "01-02", "01-03", "01-04", "01-05", "01-06"]
files_modified:
  - cogrid/cogrid_env.py
  - cogrid/envs/overcooked/overcooked.py
autonomous: false

must_haves:
  truths:
    - "CoGridEnv(config, backend='numpy') instantiates and behaves identically to current CoGridEnv(config)"
    - "All existing tests pass without modification on numpy backend"
    - "Backend parameter is accepted and calls set_backend()"
    - "Array state is maintained alongside Grid objects during step()"
    - "Vectorized movement is used instead of old move_agents()"
    - "Vectorized interactions are used instead of old interact()"
    - "Array-based features produce observations matching existing features"
    - "Array-based rewards produce values matching existing rewards"
    - "For a given grid state and action sequence, outputs match the current implementation"
  artifacts:
    - path: "cogrid/cogrid_env.py"
      provides: "CoGridEnv with backend parameter and array state management"
      contains: "backend"
    - path: "cogrid/envs/overcooked/overcooked.py"
      provides: "Overcooked env with array state initialization"
  key_links:
    - from: "cogrid/cogrid_env.py"
      to: "cogrid/backend"
      via: "set_backend() call in __init__"
      pattern: "set_backend"
    - from: "cogrid/cogrid_env.py"
      to: "cogrid/core/movement.py"
      via: "move_agents_array() call in step"
      pattern: "move_agents_array"
    - from: "cogrid/cogrid_env.py"
      to: "cogrid/core/interactions.py"
      via: "process_interactions_array() call in step"
      pattern: "process_interactions_array"
---

<objective>
Wire all vectorized components (backend dispatch, movement, interactions, observations, rewards) into the CoGridEnv step loop, maintaining backward compatibility with all existing tests.

Purpose: This is the integration plan that brings everything together. The individual vectorized components (Plans 01-06) are standalone functions. This plan wires them into the actual environment step() loop so that `CoGridEnv(config, backend='numpy')` uses the vectorized code path while producing identical outputs to the current implementation.

Output: Modified `cogrid_env.py` with backend parameter, array state management, and vectorized step components. All existing tests pass unchanged.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-RESEARCH.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-CONTEXT.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-01-SUMMARY.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-02-SUMMARY.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-03-SUMMARY.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-04-SUMMARY.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-05-SUMMARY.md
@.planning/phases/01-dual-backend-vectorized-core-rewrite/01-06-SUMMARY.md
@cogrid/cogrid_env.py
@cogrid/envs/overcooked/overcooked.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire vectorized components into CoGridEnv</name>
  <files>cogrid/cogrid_env.py, cogrid/envs/overcooked/overcooked.py</files>
  <action>
Modify `cogrid/cogrid_env.py` to integrate all vectorized components. This is the most delicate task -- it must maintain exact backward compatibility.

**Strategy:** Dual-path approach for Phase 1. The existing Grid/Agent/GridObj objects remain the source of truth. The vectorized operations run in parallel, and their results are synced back to the objects. This is intentionally redundant in Phase 1 to enable parity verification. Phase 2 will remove the object path.

**Changes to `CoGridEnv.__init__()`:**

1. Accept `backend` parameter: `def __init__(self, config, render_mode=None, agent_class=None, backend='numpy', **kwargs)`
2. Call `set_backend(backend)` at the very start of `__init__`, before any other imports that use `xp`:
   ```python
   from cogrid.backend import set_backend
   set_backend(backend)
   ```
3. After grid creation (`_gen_grid()`), build array state:
   ```python
   from cogrid.core.grid_utils import layout_to_array_state
   from cogrid.core.agent import create_agent_arrays
   from cogrid.core.grid_object import build_lookup_tables
   self._array_state = None  # initialized in reset()
   self._lookup_tables = build_lookup_tables(scope=self.scope)
   ```
4. Compute type IDs needed by interactions and rewards:
   ```python
   from cogrid.core.grid_object import object_to_idx
   self._type_ids = {
       'pot': object_to_idx('pot', scope=self.scope) if 'pot' in [name for name in get_object_names(self.scope) if name] else -1,
       'onion': object_to_idx('onion', scope=self.scope) if 'onion' in ... else -1,
       # ... etc for all needed types
   }
   ```
   IMPORTANT: Only compute type_ids for types that exist in the current scope. For non-Overcooked scopes, some types won't exist. Use a try/except or conditional.

5. Build pickup_from_produces table and other interaction tables.

6. Build composed feature and reward functions (resolved at init time per OBS-02, REW-02).

**Changes to `reset()`:**

After existing reset logic, create array state:
```python
self._array_state = layout_to_array_state(self.grid, scope=self.scope)
agent_arrays = create_agent_arrays(self.env_agents, scope=self.scope)
self._array_state.update(agent_arrays)
```

**Changes to `step()`:**

The existing step() flow is:
1. Copy prev_grid
2. Grid.tick()
3. Convert actions to strings
4. move_agents(actions)
5. interact(actions)
6. update_grid_agents()
7. get_obs()
8. compute_rewards()
9. get_terminateds_truncateds()
10. render()

**FINAL APPROACH:** Use vectorized movement as the PRIMARY path. Sync results back to Agent/Grid objects. Keep existing interact()/features/rewards since they already work on the synced objects. This gives us:
- Movement: vectorized (primary) -> synced to objects
- Interactions: existing object-based (primary) + shadow parity check against process_interactions_array()
- Features: existing object-based (primary) + shadow parity check against array features
- Rewards: existing object-based (primary) + shadow parity check against array rewards

This satisfies all MOVE requirements (vectorized is the actual path) while the shadow checks verify INTR/OBS/REW parity (the functions exist and produce correct outputs, as proven by the shadow assertions).

**Syncing array state back to Grid/Agent objects after move_agents_array():**
- Update each agent's `.pos` and `.dir` from the arrays
- Call `update_grid_agents()` to sync GridAgent wrappers on the grid

**Shadow parity checks (optional, enabled by `self._validate_array_parity = True`):**
After `interact()`, run `process_interactions_array()` on a copy of the pre-interaction array state and assert results match. Same for features and rewards. These can be disabled for performance.

Modify `__init__` to accept `backend=`, call `set_backend()`, build lookup tables and type IDs.
Modify `reset()` to create array state.
Modify `move_agents()` to use `move_agents_array()` and sync back.
Add shadow parity checks for `interact()`, `get_obs()`, `compute_rewards()`.
  </action>
  <verify>
Run full test suite: `python -m pytest cogrid/test_gridworld_env.py cogrid/test_overcooked_env.py -x -v` -- ALL tests pass.
Run: `python -c "
from cogrid.envs.overcooked.overcooked import Overcooked
import cogrid.envs
config = {
    'name': 'overcooked',
    'num_agents': 2,
    'action_set': 'cardinal_actions',
    'features': 'overcooked_features',
    'rewards': ['delivery_reward'],
    'grid': {'layout': 'cramped_room'},
    'max_steps': 100,
    'scope': 'overcooked',
}
env = Overcooked(config=config, backend='numpy')
obs, info = env.reset(seed=42)
print('Reset OK, obs keys:', list(obs.keys()))
for step in range(50):
    actions = {aid: env.action_space(aid).sample() for aid in env.agents}
    obs, rewards, terminated, truncated, infos = env.step(actions)
print(f'50 steps completed. Rewards: {rewards}')
print('INTEGRATION TEST PASSED')
"` succeeds.
Run: `python -m pytest cogrid/ -x -q --timeout=60` -- all tests pass.
  </verify>
  <done>
CoGridEnv accepts `backend='numpy'` parameter and calls set_backend(). Array state created on reset(). Vectorized movement used as primary path with sync back to Agent objects. Existing interactions, features, rewards continue working on synced objects. All existing tests pass without modification.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify full integration and test suite</name>
  <files>cogrid/cogrid_env.py</files>
  <action>
This is a human verification checkpoint. Claude has automated the integration -- the user verifies it works correctly by running the commands in the verify section.
  </action>
  <verify>
1. Run full test suite: `python -m pytest cogrid/test_gridworld_env.py cogrid/test_overcooked_env.py -v`
2. Run smoke test: `python -c "import cogrid.envs; from cogrid.envs.overcooked.overcooked import Overcooked; config = {'name': 'overcooked', 'num_agents': 2, 'action_set': 'cardinal_actions', 'features': 'overcooked_features', 'rewards': ['delivery_reward'], 'grid': {'layout': 'cramped_room'}, 'max_steps': 200, 'scope': 'overcooked'}; env = Overcooked(config=config, backend='numpy'); obs, _ = env.reset(seed=42); [env.step({a: env.action_space(a).sample() for a in env.agents}) for _ in range(200)]; print('OK')"`
3. Verify backend: `python -c "from cogrid.backend import xp, get_backend; print(f'Backend: {get_backend()}, xp: {xp.__name__}')"`
  </verify>
  <done>
User confirms: all tests pass, smoke test runs 200 steps without error, backend module reports numpy. Phase 1 integration is complete.
  </done>
</task>

</tasks>

<verification>
1. `CoGridEnv(config, backend='numpy')` works and matches `CoGridEnv(config)` behavior
2. All existing tests pass: `python -m pytest cogrid/ -x -q`
3. Backend parameter accepted and set_backend() called
4. Array state maintained during step()
5. Vectorized movement produces positions matching old implementation
6. Parity assertions pass for interactions, features, rewards
</verification>

<success_criteria>
- `CoGridEnv(config, backend='numpy')` instantiates and runs identically to current
- All ~30+ existing tests pass without modification
- Backend dispatch module is called on environment creation
- Array state is created on reset and updated during step
- Movement resolution uses vectorized path
- For 200 random steps, environment runs without error
</success_criteria>

<output>
After completion, create `.planning/phases/01-dual-backend-vectorized-core-rewrite/01-07-SUMMARY.md`
</output>

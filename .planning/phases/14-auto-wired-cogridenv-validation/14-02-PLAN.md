---
phase: 14-auto-wired-cogridenv-validation
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - examples/goal_finding.py
  - cogrid/tests/test_step_pipeline.py
  - cogrid/tests/test_reward_parity.py
  - cogrid/tests/test_cross_backend_parity.py
  - cogrid/envs/overcooked/test_interactions.py
  - cogrid/tests/test_overcooked_migration.py
  - cogrid/tests/test_phase14_validation.py
autonomous: true

must_haves:
  truths:
    - "Goal-finding example uses ArrayReward subclass and zero manual scope_config -- no GoalFindingEnv subclass needed"
    - "Goal-finding example runs successfully on numpy backend"
    - "All test files import build_scope_config_from_components instead of build_overcooked_scope_config"
    - "All test files import autowired compute_fn instead of manual compute_rewards"
    - "Determinism test proves two auto-wired Overcooked envs with same seed produce identical outputs over 50 steps, with invariant checks (finite rewards, correct shapes, bool terminateds)"
    - "JIT + vmap test at 1024 environments completes without error"
  artifacts:
    - path: "examples/goal_finding.py"
      provides: "Goal-finding example using component API (ArrayReward subclass, direct CoGridEnv, no env subclass)"
    - path: "cogrid/tests/test_phase14_validation.py"
      provides: "End-to-end parity test + JIT/vmap validation for auto-wired Overcooked"
    - path: "cogrid/tests/test_step_pipeline.py"
      provides: "Updated imports using autowire instead of manual build_overcooked_scope_config"
  key_links:
    - from: "examples/goal_finding.py"
      to: "cogrid/core/array_rewards.py ArrayReward"
      via: "GoalReward(ArrayReward) subclass registered with @register_reward_type"
      pattern: "class GoalReward.*ArrayReward"
    - from: "examples/goal_finding.py"
      to: "cogrid/cogrid_env.py CoGridEnv"
      via: "Direct CoGridEnv instantiation (no env subclass)"
      pattern: "CoGridEnv\\(config="
    - from: "cogrid/tests/test_phase14_validation.py"
      to: "cogrid/cogrid_env.py CoGridEnv"
      via: "registry.make() for determinism + invariant validation"
      pattern: "registry\\.make"
---

<objective>
Convert the goal-finding example to the component API (proving INTG-04), update all test imports from manual builders to auto-wiring functions, and add explicit end-to-end parity + JIT/vmap validation tests for auto-wired Overcooked (proving TEST-01, TEST-02, TEST-03).

Purpose: Proves the component API works for new environments (goal-finding with zero manual config), migrates all test infrastructure to the new auto-wiring path (preparing for dead code deletion), and provides explicit validation that auto-wired Overcooked is identical to v1.1 manual-wired Overcooked under JIT+vmap.

Output: Updated goal_finding.py, updated test imports, new test_phase14_validation.py with parity + JIT/vmap tests.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-auto-wired-cogridenv-validation/14-RESEARCH.md
@.planning/phases/14-auto-wired-cogridenv-validation/14-01-SUMMARY.md
@examples/goal_finding.py
@cogrid/tests/test_step_pipeline.py
@cogrid/tests/test_reward_parity.py
@cogrid/tests/test_cross_backend_parity.py
@cogrid/envs/overcooked/test_interactions.py
@cogrid/tests/test_overcooked_migration.py
@cogrid/core/autowire.py
@cogrid/core/array_rewards.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert goal-finding example to component API and update test imports</name>
  <files>examples/goal_finding.py, cogrid/tests/test_step_pipeline.py, cogrid/tests/test_reward_parity.py, cogrid/tests/test_cross_backend_parity.py, cogrid/envs/overcooked/test_interactions.py</files>
  <action>
  **Goal-finding example (examples/goal_finding.py):**

  Rewrite the example to demonstrate the component API. The steps:

  1. Keep Goal GridObject registration (already uses @register_object_type).

  2. Replace the standalone `goal_reward()` function and `compute_rewards()` dispatcher with an `ArrayReward` subclass:
  ```python
  from cogrid.core.array_rewards import ArrayReward
  from cogrid.core.component_registry import register_reward_type

  @register_reward_type("goal", scope="global", coefficient=1.0, common_reward=True)
  class GoalReward(ArrayReward):
      def compute(self, prev_state, state, actions, reward_config):
          from cogrid.backend import xp
          goal_id = reward_config["type_ids"].get("goal", -1)
          otm = state["object_type_map"]
          rows = state["agent_pos"][:, 0]
          cols = state["agent_pos"][:, 1]
          on_goal = (otm[rows, cols] == goal_id).astype(xp.float32)
          return on_goal
  ```
  Note: the ArrayReward.compute() returns raw unweighted per-agent rewards. The autowire's composed compute_fn handles coefficient weighting and common_reward broadcasting.

  3. Replace the `GoalFindingEnv(CoGridEnv)` subclass with direct `CoGridEnv` usage. The environment config just needs `"scope": "global"` and the auto-wiring picks up the registered GoalReward.

  4. Update the `registry.register` call to use `CoGridEnv` directly instead of `GoalFindingEnv`:
  ```python
  registry.register(
      "GoalFinding-Simple-V0",
      functools.partial(CoGridEnv, config=goal_config),
  )
  ```
  This is a key step -- the registry entry must point to `CoGridEnv` (not a subclass), proving that no env subclass is needed when using the component API.

  5. Handle `terminated_fn`: `build_reward_config_from_components` does NOT support `terminated_fn` (it is not part of the ArrayReward interface). After constructing the env, manually patch it:
  ```python
  env = registry.make("GoalFinding-Simple-V0", backend="numpy")
  env._reward_config["terminated_fn"] = goal_terminated
  ```
  This is the correct pattern for scope-specific termination conditions that are not reward-based. Keep the existing `goal_terminated` function unchanged.

  6. Keep all the run_numpy() and run_jax() functions. Update them to work with the new API. The example should be self-contained and runnable.

  **Note on file count:** The test import updates below are mechanical find-and-replace changes (swapping import paths). They are grouped with the goal-finding rewrite because they are all "migrate to auto-wiring imports" work and each test file change is ~5 lines.

  **Test import updates:**

  For each test file, replace `build_overcooked_scope_config` imports with `build_scope_config_from_components`:

  - **test_step_pipeline.py:** Replace `from cogrid.envs.overcooked.array_config import build_overcooked_scope_config` with `from cogrid.core.autowire import build_scope_config_from_components, build_reward_config_from_components`. Replace `scope_config = build_overcooked_scope_config()` with `scope_config = build_scope_config_from_components("overcooked")`. Replace the `compute_rewards` import and manual reward_config with `build_reward_config_from_components("overcooked", n_agents=..., type_ids=..., action_pickup_drop_idx=...)`.

  - **test_reward_parity.py:** Replace `from cogrid.envs.overcooked.array_config import build_overcooked_scope_config` and `_SC = build_overcooked_scope_config()` with autowire equivalents. For `test_reward_parity_compute_rewards()`, replace the `ar_mod.compute_rewards(...)` calls with the autowired `compute_fn` from `build_reward_config_from_components`. The test verifies numpy vs JAX parity of the composed compute function -- update to test the auto-wired composed function instead of the manual dispatcher.

  - **test_cross_backend_parity.py:** Replace `from cogrid.envs.overcooked.array_rewards import compute_rewards` with the auto-wired compute_fn. The test at line ~544 creates a reward_config with the manual compute_rewards -- update to use `build_reward_config_from_components`.

  - **test_interactions.py:** Replace `from cogrid.envs.overcooked.array_config import build_overcooked_scope_config` with `from cogrid.core.autowire import build_scope_config_from_components`. Replace `get_scope_config(scope)` with `build_scope_config_from_components(scope)`.
  </action>
  <verify>
  Run `python examples/goal_finding.py` -- should print numpy results successfully. Run `python -m pytest cogrid/tests/ cogrid/envs/ -x -q` -- all tests pass with updated imports.
  </verify>
  <done>Goal-finding example uses ArrayReward subclass + direct CoGridEnv (no env subclass, no manual scope_config). All test files use auto-wiring imports. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add end-to-end parity and JIT/vmap validation tests</name>
  <files>cogrid/tests/test_phase14_validation.py</files>
  <action>
  Create `cogrid/tests/test_phase14_validation.py` with three test functions:

  **Test 1: test_autowired_overcooked_determinism_and_invariants**
  This test validates that the auto-wired Overcooked env produces deterministic, correct outputs. It does NOT compare against the manual builders (Phase 13 parity tests already proved config-level parity in test_overcooked_migration.py, and post-14-01 comparing against manual builders is circular since both paths go through the same __init__).

  Approach -- deterministic self-consistency + invariant checks:
  1. Create two Overcooked envs via `registry.make("Overcooked-CrampedRoom-V0")` on numpy backend
  2. Reset both with the same seed
  3. Run 50 scripted steps with deterministic actions (e.g., `actions = {0: step_idx % 7, 1: (step_idx + 3) % 7}`)
  4. Assert IDENTICAL outputs at every step between the two runs (determinism): `np.testing.assert_array_equal` for obs, rewards, terminateds, truncateds
  5. Assert invariants at every step:
     - Rewards are finite (no NaN/inf) and non-negative
     - Observation shapes are correct (match env.observation_space)
     - terminateds values are bool-typed
     - truncateds values are bool-typed
     - Agent positions are within grid bounds

  This proves the auto-wired path is deterministic and produces well-formed outputs.

  **Test 2: test_autowired_overcooked_jit_vmap_1024**
  Creates an Overcooked env via `registry.make("Overcooked-CrampedRoom-V0", backend="jax")`. Gets `step_fn = env.jax_step` and `reset_fn = env.jax_reset`. Runs `jax.jit(jax.vmap(reset_fn))` on 1024 keys. Runs `jax.jit(jax.vmap(step_fn))` for 10 steps with scripted actions. Asserts:
  - No errors during JIT compilation or vmap execution
  - Output shapes are correct: obs has batch dim 1024, rewards shape is (1024, n_agents)
  - Rewards are finite (no NaN/inf)

  Use pytest.mark.skipif to skip when JAX is not installed:
  ```python
  jax = pytest.importorskip("jax")
  ```

  **Test 3: test_goal_finding_component_api_numpy**
  Imports the goal_finding example module, creates the environment via `registry.make("GoalFinding-Simple-V0", backend="numpy")`, resets, runs 10 steps, asserts no errors and reward array shapes are correct. This validates TEST-03 (goal-finding works through component API with zero manual scope_config).

  All tests should use `from cogrid.backend._dispatch import _reset_backend_for_testing` at the start to ensure clean backend state.
  </action>
  <verify>
  Run `python -m pytest cogrid/tests/test_phase14_validation.py -x -v` -- all 3 tests pass. Run `python -m pytest cogrid/tests/ cogrid/envs/ -x -q` -- full suite passes.
  </verify>
  <done>Three validation tests exist and pass: determinism + invariant checks (numpy), JIT+vmap at 1024 envs (JAX), and goal-finding component API (numpy). All phase 14 success criteria TEST-01, TEST-02, TEST-03 are verified by automated tests.</done>
</task>

</tasks>

<verification>
1. `python examples/goal_finding.py` runs without error and prints reward output
2. `grep -rn "build_overcooked_scope_config" cogrid/tests/` returns zero matches
3. `grep -rn "from cogrid.envs.overcooked.array_rewards import compute_rewards" cogrid/tests/` returns zero matches
4. `python -m pytest cogrid/tests/test_phase14_validation.py -x -v` -- all 3 tests pass
5. `python -m pytest cogrid/tests/ cogrid/envs/ -x -q` -- all tests pass
</verification>

<success_criteria>
Goal-finding example demonstrates component API with zero manual config (INTG-04, TEST-03). All test files use autowire imports exclusively. Determinism + invariant test proves auto-wired Overcooked produces correct, reproducible outputs (TEST-01). JIT+vmap at 1024 envs works (TEST-02). All tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/14-auto-wired-cogridenv-validation/14-02-SUMMARY.md`
</output>

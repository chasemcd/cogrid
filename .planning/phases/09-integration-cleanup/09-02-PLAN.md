---
phase: 09-integration-cleanup
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - cogrid/cogrid_env.py
autonomous: true

must_haves:
  truths:
    - "CoGridEnv.step() delegates to self._step_fn for BOTH numpy and JAX backends"
    - "CoGridEnv.reset() delegates to self._reset_fn for BOTH numpy and JAX backends"
    - "env.jax_step and env.jax_reset expose the raw functional API for JIT/vmap"
    - "PettingZoo dict-based API works correctly (action dict in, obs/reward dicts out)"
  artifacts:
    - path: "cogrid/cogrid_env.py"
      provides: "Thin PettingZoo wrapper delegating to step_pipeline"
      contains: "self._step_fn"
  key_links:
    - from: "cogrid/cogrid_env.py"
      to: "cogrid/core/step_pipeline.py"
      via: "build_step_fn/build_reset_fn"
      pattern: "from cogrid.core.step_pipeline import"
---

<objective>
Rewrite `cogrid_env.py` so both numpy and JAX backends delegate step/reset to the unified step pipeline, making it a thin stateful wrapper around the functional core.

Purpose: Satisfies ARCH-06 (thin wrapper), ARCH-07 (functional API exposure), and CLEAN-02 (remove object-based simulation loop from step path). The wrapper translates between PettingZoo's dict-based API and the functional core's array-based API. The old numpy simulation loop (grid.tick, interact, move_agents) is removed from the step path.

Output: A `cogrid_env.py` where both backends use `build_step_fn`/`build_reset_fn`, the old `_jax_step_wrapper` is deleted, and `jax_step`/`jax_reset` properties expose the functional API.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-integration-cleanup/09-01-SUMMARY.md
@cogrid/cogrid_env.py
@cogrid/core/step_pipeline.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unify init and reset to use step_pipeline for both backends</name>
  <files>cogrid/cogrid_env.py</files>
  <action>
Rewrite `CoGridEnv.__init__` and `reset()` so both backends build step/reset functions from `step_pipeline.build_step_fn`/`build_reset_fn`.

**Changes to __init__:**
1. Remove the JAX-specific block (lines 220-296) that imports from `jax_step`, converts tables, builds feature_fn separately for JAX, etc.
2. Instead, set up backend-agnostic infrastructure for BOTH backends at init time:
   - Build feature_fn using `build_feature_fn` (not `build_feature_fn_jax` -- the alias is going away)
   - Compute action indices (`_action_pickup_drop_idx`, `_action_toggle_idx`)
   - Build reward config with `"compute_fn"` key pointing to the actual compute_rewards function (import from `cogrid.envs.overcooked.array_rewards` if scope is overcooked, or resolve via scope_config)
   - Set `self._agent_id_order = sorted(self.possible_agents)` for both backends
   - The lazy fields `_step_fn`, `_reset_fn`, `_env_state` are initialized to None for both backends
3. For the JAX backend, still register pytree and convert lookup/scope tables to JAX arrays (this remains JAX-specific since numpy doesn't need it). But do NOT import from jax_step.py.

**Changes to reset():**
1. Remove the two separate reset paths (JAX lines 446-516, numpy lines 518-528).
2. Replace with a SINGLE path:
   - Keep the grid generation, agent setup, and array_state building (these create the layout arrays needed by step_pipeline)
   - Build layout_arrays dict from `self._array_state` (same as current JAX path does, lines 461-468)
   - For JAX backend: convert arrays to jnp. For numpy: keep as np.
   - Build `self._reset_fn` and `self._step_fn` using `build_reset_fn` and `build_step_fn` from step_pipeline
   - Call `self._reset_fn(rng)` to get initial state and obs
   - Store `self._env_state = state`
   - Convert obs array to PettingZoo dict format: `{aid: obs_arr[i] for i, aid in enumerate(self._agent_id_order)}`
   - For rendering: if `self.render_mode is not None`, keep the Grid/Agent objects in sync (they're already built by `_gen_grid` and `setup_agents`). Call `self.render()` after reset.
3. The reward_config dict must include the `"compute_fn"` key per Plan 01's changes.

**Changes to step():**
1. Remove the JAX branch (`if self._backend == 'jax': return self._jax_step_wrapper(actions)`)
2. Remove the entire numpy simulation loop (lines 570-635: grid.tick, _vectorized_move, interact, _sync_array_state_from_objects, etc.)
3. Replace with a SINGLE path for both backends:
   - Convert action dict to ordered array: `actions_arr = xp.array([actions[aid] for aid in self._agent_id_order], dtype=xp.int32)`
   - Call `self._env_state, obs_arr, rewards_arr, done, infos = self._step_fn(self._env_state, actions_arr)`
   - Convert outputs to PettingZoo dict format (same as current `_jax_step_wrapper` does)
   - Handle termination/truncation (done -> truncateds dict)
   - Increment `self.t`
   - For rendering: if `self.render_mode is not None`, sync Grid/Agent objects from EnvState and call `self.render()`
4. Delete `_jax_step_wrapper` method entirely.
5. Delete `_vectorized_move` method entirely (no longer used in step path).
6. Delete `_sync_array_state_from_objects` method entirely (no longer used in step path).
7. Keep but simplify `move_agents` (the old Python-loop version) -- it's only needed by subclasses that might override it for the numpy path. Actually, since the step path no longer calls it, it can be deleted from the step path. Keep it ONLY if it's called by subclasses. If not, delete it entirely along with `determine_attempted_pos`, `can_toggle`, and `interact`. BUT keep all rendering methods, all hooks (on_move, on_step, on_reset, etc.), and observation/reward infrastructure for backward compat.

**IMPORTANT -- Observation format:**
The PettingZoo wrapper currently returns different observation formats for numpy (FeatureSpace dict) vs JAX (flat array). After this change, BOTH backends go through step_pipeline which returns flat arrays. The wrapper should convert the flat array into a per-agent dict: `{aid: obs_arr[i] for i, aid in enumerate(self._agent_id_order)}`. This means numpy users who previously got nested dicts from FeatureSpace will now get flat arrays. This is an intentional simplification -- the observation_space should be updated to match (a Box space, not a Dict space).

**IMPORTANT -- Rendering sync:**
Add a method `_sync_objects_from_state()` that updates Agent positions/directions and Grid objects from the current `self._env_state`. Only call it when `self.render_mode is not None`. This is a lightweight read from EnvState arrays back to Agent/Grid objects for rendering ONLY. It is NOT part of the simulation loop.

**Properties jax_step and jax_reset:**
Keep the existing properties (lines 764-798). They already return `self._step_fn` and `self._reset_fn` (which are now the same functions used internally). The only change: they should work for BOTH backends -- rename them to clarify they expose the functional API, but keep `jax_step`/`jax_reset` names for backward compat. The `_backend != 'jax'` check should be removed since the functional API is now available on both backends. However, the vmap requirement specifically says JAX, so keep the guard.
  </action>
  <verify>
Run: `python -c "from cogrid.cogrid_env import CoGridEnv"` succeeds.
Run: `python -m pytest cogrid/tests/test_step_pipeline.py -x -q` passes.
Manual test: Create an Overcooked env with backend="numpy", call reset() and step() -- should work.
Manual test: Create an Overcooked env with backend="jax", call reset() and step() -- should work.
  </verify>
  <done>
Both numpy and JAX backends in CoGridEnv delegate to the same step_pipeline functions. The old object-based simulation loop is removed from the step path. _jax_step_wrapper, _vectorized_move, and _sync_array_state_from_objects are deleted. jax_step/jax_reset properties expose the functional API.
  </done>
</task>

</tasks>

<verification>
1. `CoGridEnv` can be instantiated with both `backend="numpy"` and `backend="jax"`
2. `reset()` and `step()` work on both backends
3. `env.jax_step` and `env.jax_reset` return callable functions on JAX backend
4. The old `_jax_step_wrapper` method no longer exists
5. The old numpy simulation loop methods (`_vectorized_move`, `_sync_array_state_from_objects`) no longer exist
6. `self._step_fn` and `self._reset_fn` are used for both backends
</verification>

<success_criteria>
- CoGridEnv is a thin stateful wrapper with one step path and one reset path
- Both backends delegate to step_pipeline.build_step_fn/build_reset_fn
- The functional API is exposed via jax_step/jax_reset for direct JIT/vmap
- No duplicate simulation logic remains in cogrid_env.py
</success_criteria>

<output>
After completion, create `.planning/phases/09-integration-cleanup/09-02-SUMMARY.md`
</output>

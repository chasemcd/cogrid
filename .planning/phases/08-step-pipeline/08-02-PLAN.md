---
phase: 08-step-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - cogrid/core/step_pipeline.py
  - cogrid/core/jax_step.py
  - cogrid/tests/test_step_pipeline.py
autonomous: true

must_haves:
  truths:
    - "build_step_fn() returns a (state, actions) -> (state, obs, rewards, done, infos) closure that auto-JITs on JAX"
    - "build_reset_fn() returns a (rng) -> (state, obs) closure that auto-JITs on JAX"
    - "jax_step.py is a thin backward-compat shim re-exporting from step_pipeline"
    - "jax.jit(step_fn)(state, actions) compiles and executes without error"
    - "Numpy path step_fn(state, actions) executes without error"
  artifacts:
    - path: "cogrid/core/step_pipeline.py"
      provides: "build_step_fn(), build_reset_fn() factory functions"
      exports: ["step", "reset", "envstate_to_dict", "build_step_fn", "build_reset_fn"]
    - path: "cogrid/core/jax_step.py"
      provides: "Backward-compat aliases: jax_step, jax_reset, make_jitted_step, make_jitted_reset, envstate_to_dict"
    - path: "cogrid/tests/test_step_pipeline.py"
      provides: "End-to-end tests for unified step pipeline on both backends"
  key_links:
    - from: "cogrid/core/jax_step.py"
      to: "cogrid/core/step_pipeline.py"
      via: "import aliases"
      pattern: "from cogrid\\.core\\.step_pipeline import"
    - from: "cogrid/core/step_pipeline.py:build_step_fn"
      to: "cogrid/core/step_pipeline.py:step"
      via: "closure over step()"
      pattern: "return step\\("
    - from: "cogrid/core/step_pipeline.py:build_reset_fn"
      to: "cogrid/core/step_pipeline.py:reset"
      via: "closure over reset()"
      pattern: "return reset\\("
    - from: "cogrid/cogrid_env.py"
      to: "cogrid/core/jax_step.py"
      via: "backward-compat import"
      pattern: "from cogrid\\.core\\.jax_step import make_jitted_step"
---

<objective>
Add `build_step_fn()` and `build_reset_fn()` factory functions to step_pipeline.py, convert jax_step.py to a backward-compat shim, and add end-to-end tests verifying the complete pipeline on both backends including JIT compilation.

Purpose: Init-time function composition eliminates per-step dispatch overhead. The factories close over all static config and return pure `(state, actions) -> ...` functions. On JAX, they auto-wrap with `jax.jit`. The backward-compat shim in jax_step.py ensures `cogrid_env.py` and existing tests continue working without modification (Phase 9 handles that cleanup).

Output: Updated `step_pipeline.py`, thin `jax_step.py` shim, `test_step_pipeline.py` test suite.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-step-pipeline/08-RESEARCH.md
@.planning/phases/08-step-pipeline/08-01-SUMMARY.md
@cogrid/core/step_pipeline.py
@cogrid/core/jax_step.py
@cogrid/cogrid_env.py
@cogrid/tests/test_cross_backend_parity.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add build_step_fn and build_reset_fn factories, convert jax_step.py to shim</name>
  <files>cogrid/core/step_pipeline.py, cogrid/core/jax_step.py</files>
  <action>
**A. Add `build_step_fn()` to step_pipeline.py:**

```python
def build_step_fn(scope_config, lookup_tables, feature_fn, reward_config,
                  action_pickup_drop_idx, action_toggle_idx, max_steps,
                  jit_compile=None):
    """Build a step function with all static config closed over.

    Returns a function with signature
    ``(state, actions) -> (state, obs, rewards, done, infos)``.

    Args:
        scope_config: Scope config dict.
        lookup_tables: Dict of property arrays.
        feature_fn: Composed feature function.
        reward_config: Reward config dict.
        action_pickup_drop_idx: int, PickupDrop action index.
        action_toggle_idx: int, Toggle action index.
        max_steps: int, maximum timesteps per episode.
        jit_compile: If None, auto-detect from backend. If True/False, force.

    Returns:
        Step function (optionally JIT-compiled on JAX backend).
    """
    from cogrid.backend._dispatch import get_backend

    def step_fn(state, actions):
        return step(state, actions,
                    scope_config=scope_config,
                    lookup_tables=lookup_tables,
                    feature_fn=feature_fn,
                    reward_config=reward_config,
                    action_pickup_drop_idx=action_pickup_drop_idx,
                    action_toggle_idx=action_toggle_idx,
                    max_steps=max_steps)

    should_jit = jit_compile if jit_compile is not None else (get_backend() == "jax")
    if should_jit:
        import jax
        return jax.jit(step_fn)
    return step_fn
```

**B. Add `build_reset_fn()` to step_pipeline.py:**

```python
def build_reset_fn(layout_arrays, spawn_positions, n_agents, feature_fn,
                   scope_config, action_set, jit_compile=None, **kwargs):
    """Build a reset function with all layout config closed over.

    Returns a function with signature ``(rng) -> (state, obs)``.

    Args:
        layout_arrays: Dict of pre-computed layout arrays.
        spawn_positions: int32 array of shape (n_agents, 2).
        n_agents: Number of agents.
        feature_fn: Composed feature function.
        scope_config: Scope config dict.
        action_set: "cardinal" or "rotation".
        jit_compile: If None, auto-detect from backend. If True/False, force.
        **kwargs: Additional keyword args forwarded to reset()
            (e.g., max_inv_size, pot_capacity, cooking_time).

    Returns:
        Reset function (optionally JIT-compiled on JAX backend).
    """
    from cogrid.backend._dispatch import get_backend

    def reset_fn(rng):
        return reset(rng,
                     layout_arrays=layout_arrays,
                     spawn_positions=spawn_positions,
                     n_agents=n_agents,
                     feature_fn=feature_fn,
                     scope_config=scope_config,
                     action_set=action_set,
                     **kwargs)

    should_jit = jit_compile if jit_compile is not None else (get_backend() == "jax")
    if should_jit:
        import jax
        return jax.jit(reset_fn)
    return reset_fn
```

**C. Replace jax_step.py with a backward-compat shim:**

Replace the entire contents of `cogrid/core/jax_step.py` with:

```python
"""Backward-compatibility aliases for the unified step pipeline.

The actual implementation lives in :mod:`cogrid.core.step_pipeline`.
These aliases maintain import compatibility during the Phase 8->9
transition. All callers (``cogrid_env.py``, tests) that import from
this module continue to work unchanged.

.. deprecated::
    Import from ``cogrid.core.step_pipeline`` instead. This module
    will be removed in Phase 9.
"""
from cogrid.core.step_pipeline import (
    step as jax_step,
    reset as jax_reset,
    build_step_fn as make_jitted_step,
    build_reset_fn as make_jitted_reset,
    envstate_to_dict,
)
```

This ensures:
- `from cogrid.core.jax_step import make_jitted_step, make_jitted_reset` still works (cogrid_env.py uses this).
- `from cogrid.core.jax_step import jax_step, jax_reset` still works (tests use this).
- `from cogrid.core.jax_step import envstate_to_dict` still works (tests use this).

**D. Remove the `if __name__ == "__main__"` smoke test from jax_step.py** -- it's no longer needed as a shim file. The smoke test functionality is replaced by the test file in Task 2.
  </action>
  <verify>
Run: `python -c "from cogrid.core.jax_step import jax_step, jax_reset, make_jitted_step, make_jitted_reset, envstate_to_dict; print('Backward compat OK')"` -- all existing import paths still work.

Run: `python -c "from cogrid.core.step_pipeline import step, reset, build_step_fn, build_reset_fn, envstate_to_dict; print('New imports OK')"` -- new API is accessible.
  </verify>
  <done>
`build_step_fn()` and `build_reset_fn()` exist in step_pipeline.py, auto-JIT on JAX backend. `jax_step.py` is a thin shim re-exporting all names. All existing import paths (cogrid_env.py, tests) continue working.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create end-to-end test suite for unified step pipeline</name>
  <files>cogrid/tests/test_step_pipeline.py</files>
  <action>
Create `cogrid/tests/test_step_pipeline.py` with pytest tests verifying the complete pipeline.

**Test structure:**

```python
"""End-to-end tests for the unified step pipeline.

Tests both numpy and JAX backends, verifying that step() and reset()
produce correct outputs and that build_step_fn/build_reset_fn
factories work with optional JIT compilation.
"""
import pytest
import numpy as np
```

**Helper function:** Create a `_setup_overcooked_config()` helper that:
1. Imports and triggers overcooked registration (`import cogrid.envs`).
2. Creates env via registry, calls `env.reset(seed=42)`, extracts `env._array_state`.
3. Builds scope_config via `build_overcooked_scope_config()`.
4. Builds lookup_tables via `build_lookup_tables(scope="overcooked")`.
5. Builds feature_fn via `build_feature_fn(feature_names, scope="overcooked")`.
6. Builds reward_config dict.
7. Returns all of these as a dict for test consumption.
This helper runs on numpy backend (layouts are always parsed in numpy).

**Test 1: `test_step_numpy_backend`**
- Set backend to numpy (use `_reset_backend_for_testing` + `set_backend("numpy")`).
- Call helper to get config.
- Build layout_arrays and spawn_positions from array_state.
- Call `reset()` directly with `rng=42` (integer seed for numpy).
- Assert `state` is an EnvState, `obs` is an ndarray with shape `(n_agents, obs_dim)`.
- Call `step()` directly with `actions=np.zeros(n_agents, dtype=np.int32)`.
- Assert output is `(state, obs, rewards, done, infos)` tuple.
- Assert `obs.shape[0] == n_agents`, `rewards.shape == (n_agents,)`, `done` is scalar-like.
- Run 5 more steps, assert no errors.
- Reset backend after test.

**Test 2: `test_step_jax_backend_eager`**
- Set backend to JAX.
- Register envstate pytree.
- Call helper, convert all arrays to jnp (same pattern as jax_step.py __main__).
- Call `reset()` directly with `rng=jax.random.key(42)`.
- Assert shapes.
- Call `step()` directly with `actions=jnp.zeros(n_agents, dtype=jnp.int32)`.
- Assert shapes. Run 5 more steps.
- Reset backend after test.

**Test 3: `test_build_step_fn_jit_compiles`**
- Set backend to JAX.
- Register envstate pytree.
- Call helper, convert arrays to jnp.
- Call `build_step_fn(...)` (should auto-JIT).
- Call `build_reset_fn(...)` (should auto-JIT).
- Run `reset_fn(jax.random.key(42))` -- first call triggers JIT compilation.
- Run `step_fn(state, actions)` -- first call triggers JIT compilation.
- Run 10 more steps to verify repeated execution.
- Assert output shapes and extra_state persistence.
- Reset backend after test.

**Test 4: `test_backward_compat_aliases`**
- `from cogrid.core.jax_step import jax_step, jax_reset, make_jitted_step, make_jitted_reset, envstate_to_dict`
- Assert `jax_step is step` (from step_pipeline).
- Assert `make_jitted_step is build_step_fn`.
- Assert `make_jitted_reset is build_reset_fn`.

**Important patterns:**
- Use `from cogrid.backend._dispatch import _reset_backend_for_testing` before each backend switch.
- Use `set_backend()` to set the target backend.
- Use `try/finally` or pytest fixtures to reset backend after each test.
- For JAX array conversion, follow the exact pattern from jax_step.py's __main__ block (convert lookup_tables, static_tables, interaction_tables, pot_positions).
- Use `importlib.reload` for modules that cache xp at import time if needed, but since all step-path functions use function-level imports, this should not be necessary.
  </action>
  <verify>
Run: `cd /Users/chasemcd/Repositories/cogrid && python -m pytest cogrid/tests/test_step_pipeline.py -v` -- all 4 tests pass.

Also verify existing tests still pass:
Run: `cd /Users/chasemcd/Repositories/cogrid && python -m pytest cogrid/tests/test_cross_backend_parity.py -v -k "jax"` -- existing tests pass with the jax_step.py shim.
  </verify>
  <done>
4 tests pass: numpy step/reset, JAX eager step/reset, JIT-compiled step/reset via build factories, backward-compat alias verification. `jax.jit(step_fn)(state, actions)` compiles and executes without error. Existing tests continue passing via backward-compat shim.
  </done>
</task>

</tasks>

<verification>
1. `build_step_fn()` returns a callable that auto-JITs on JAX backend, plain closure on numpy.
2. `build_reset_fn()` returns a callable that auto-JITs on JAX backend, plain closure on numpy.
3. `jax_step.py` is <10 lines of re-exports from `step_pipeline.py`.
4. All existing import paths (`from cogrid.core.jax_step import ...`) continue working.
5. `cogrid_env.py` works without modification (it imports from jax_step.py which now re-exports from step_pipeline.py).
6. `test_step_pipeline.py` has 4 passing tests covering both backends and JIT compilation.
7. Phase 8 Success Criterion 4 is met: `jax.jit(step)(state, actions)` compiles and executes without error.
</verification>

<success_criteria>
- Init-time function composition via build_step_fn/build_reset_fn eliminates per-step dispatch overhead
- jax.jit(step_fn)(state, actions) compiles and executes without error on JAX backend
- Backward-compat aliases ensure zero breakage of existing code
- Test suite verifies both backends and JIT compilation
</success_criteria>

<output>
After completion, create `.planning/phases/08-step-pipeline/08-02-SUMMARY.md`
</output>

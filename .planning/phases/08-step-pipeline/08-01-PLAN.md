---
phase: 08-step-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cogrid/core/step_pipeline.py
autonomous: true

must_haves:
  truths:
    - "step(state, actions, ...) returns (state, obs, rewards, done, infos) using xp for all array ops"
    - "reset(rng, ...) returns (state, obs) using xp for all array ops"
    - "Both functions use get_backend() branching ONLY for RNG (jax.random.split vs np.random) and stop_gradient"
    - "envstate_to_dict is moved to step_pipeline.py unchanged"
  artifacts:
    - path: "cogrid/core/step_pipeline.py"
      provides: "Unified step(), reset(), envstate_to_dict()"
      exports: ["step", "reset", "envstate_to_dict"]
  key_links:
    - from: "cogrid/core/step_pipeline.py"
      to: "cogrid/core/movement.py"
      via: "move_agents() call in step()"
      pattern: "from cogrid\\.core\\.movement import move_agents"
    - from: "cogrid/core/step_pipeline.py"
      to: "cogrid/core/interactions.py"
      via: "process_interactions() call in step()"
      pattern: "from cogrid\\.core\\.interactions import process_interactions"
    - from: "cogrid/core/step_pipeline.py"
      to: "cogrid/feature_space/array_features.py"
      via: "get_all_agent_obs() call in step() and reset()"
      pattern: "from cogrid\\.feature_space\\.array_features import get_all_agent_obs"
    - from: "cogrid/core/step_pipeline.py"
      to: "cogrid/envs/overcooked/array_rewards.py"
      via: "compute_rewards() call in step()"
      pattern: "from cogrid\\.envs\\.overcooked\\.array_rewards import compute_rewards"
---

<objective>
Create the unified step_pipeline.py module with `step()`, `reset()`, and `envstate_to_dict()` functions that compose all Phases 5-7 sub-functions into a pure pipeline using `xp`.

Purpose: This is the core deliverable of Phase 8 -- a single step/reset code path that works on both numpy and JAX backends. The current `jax_step.py` is JAX-only (hardcodes `import jax`, `jnp`, `lax`). Phase 8 replaces those JAX-specific calls with `xp` and minimal `get_backend()` branching for the 3 JAX-specific operations: RNG, stop_gradient, JIT.

Output: `cogrid/core/step_pipeline.py` with `step()`, `reset()`, and `envstate_to_dict()`.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-step-pipeline/08-RESEARCH.md
@cogrid/core/jax_step.py
@cogrid/core/layout_parser.py
@cogrid/backend/_dispatch.py
@cogrid/backend/env_state.py
@cogrid/backend/array_ops.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create step_pipeline.py with unified step(), reset(), and envstate_to_dict()</name>
  <files>cogrid/core/step_pipeline.py</files>
  <action>
Create `cogrid/core/step_pipeline.py` by porting the logic from `cogrid/core/jax_step.py`, replacing JAX-specific operations with `xp` and backend branching.

The module has three public functions:

**1. `envstate_to_dict(state) -> dict`**
- Copy the existing `envstate_to_dict` from `jax_step.py` exactly as-is. It is already backend-agnostic.

**2. `step(state, actions, *, scope_config, lookup_tables, feature_fn, reward_config, action_pickup_drop_idx, action_toggle_idx, max_steps)`**
- Same signature as `jax_step()` in `jax_step.py`.
- Use function-level `from cogrid.backend import xp` (late-binding pattern from decision [06-04]).
- Use function-level `from cogrid.backend._dispatch import get_backend`.
- Body structure (matches current jax_step exactly):
  a. `prev_state = state` (zero-cost on both backends)
  b. **Tick**: Same pot tick logic as jax_step.py lines 140-162. Uses `set_at_2d` from `array_ops`. No changes needed (already uses xp-compatible ops via scope config tick_handler).
  c. **Movement**: Backend branch for RNG only:
     - If `get_backend() == "jax"`: `import jax; key, subkey = jax.random.split(state.rng_key); priority = jax.random.permutation(subkey, state.n_agents)`
     - Else: `import numpy as _np; priority = _np.random.default_rng().permutation(state.n_agents).astype(_np.int32); key = state.rng_key`
     - Then call `move_agents(...)` exactly as jax_step does.
     - `state = dataclasses.replace(state, agent_pos=new_pos, agent_dir=new_dir, rng_key=key)`
  d. **Interactions**: Replace `jnp.array([[0,1],[1,0],[0,-1],[-1,0]], dtype=jnp.int32)` with `xp.array([[0,1],[1,0],[0,-1],[-1,0]], dtype=xp.int32)`. Rest is identical to jax_step.
  e. **Observations**: `obs = get_all_agent_obs(feature_fn, envstate_to_dict(state), state.n_agents)` -- unchanged.
  f. **Rewards**: `rewards = compute_rewards(envstate_to_dict(prev_state), envstate_to_dict(state), actions, reward_config)` -- unchanged.
  g. **Dones**: `done = state.time >= max_steps` -- unchanged.
  h. **Stop gradient**: Backend branch:
     - If `get_backend() == "jax"`: `import jax.lax as lax; obs = lax.stop_gradient(obs); rewards = lax.stop_gradient(rewards); done = lax.stop_gradient(done)`
     - Else: pass through unchanged.
  i. Return `(state, obs, rewards, done, {})`.

**3. `reset(rng, *, layout_arrays, spawn_positions, n_agents, feature_fn, scope_config, action_set, max_inv_size=1, pot_capacity=3, cooking_time=30)`**
- Same signature as `jax_reset()` in `jax_step.py`.
- Use function-level `from cogrid.backend import xp` and `from cogrid.backend._dispatch import get_backend`.
- Backend branch for RNG:
  - If `get_backend() == "jax"`: `import jax; key, subkey = jax.random.split(rng); agent_dir = jax.random.randint(subkey, (n_agents,), 0, 4).astype(xp.int32)`
  - Else: `import numpy as _np; agent_dir = _np.random.default_rng(rng if isinstance(rng, int) else None).integers(0, 4, size=(n_agents,)).astype(_np.int32); key = None`
- Replace all `jnp.` calls with `xp.`: `xp.int32`, `xp.full(...)`, `xp.array(...)`.
- `agent_pos = spawn_positions.astype(xp.int32)`
- Build `extra_state`, `create_env_state(...)` exactly as jax_reset does.
- Compute initial obs via `get_all_agent_obs`.
- Stop gradient branch (same pattern as step).
- Return `(state, obs)`.

**Important details:**
- Module docstring should describe this as the unified step pipeline replacing jax_step.py.
- All imports of sub-functions (move_agents, process_interactions, get_all_agent_obs, compute_rewards) go inside the function bodies for late-binding.
- `import dataclasses` at module level is fine (stdlib, no backend concern).
- Do NOT import jax at module level. All jax imports are conditional inside `get_backend() == "jax"` blocks.
  </action>
  <verify>
Run: `python -c "from cogrid.core.step_pipeline import step, reset, envstate_to_dict; print('Import OK')"` succeeds.

Run: `python -c "
from cogrid.backend import set_backend
set_backend('numpy')
from cogrid.core.step_pipeline import step, reset, envstate_to_dict
print('step signature:', step.__code__.co_varnames[:10])
print('reset signature:', reset.__code__.co_varnames[:10])
print('envstate_to_dict OK')
"` -- imports and basic introspection work on numpy backend without JAX.
  </verify>
  <done>
`cogrid/core/step_pipeline.py` exists with `step()`, `reset()`, and `envstate_to_dict()` that: (1) use `xp` for all array operations, (2) branch on `get_backend()` only for RNG and stop_gradient, (3) compose all Phase 5-7 sub-functions (move_agents, process_interactions, get_all_agent_obs, compute_rewards, tick_handler) in the correct order, (4) import successfully on both backends.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify step_pipeline works end-to-end on JAX backend</name>
  <files>cogrid/core/step_pipeline.py</files>
  <action>
Run the existing `jax_step.py` smoke test pattern against the new `step_pipeline.py` functions. This validates that the unified code produces the same results as the JAX-only code.

Create a temporary verification script (do not commit) that:

1. Sets up numpy backend, creates env, extracts arrays (same as jax_step.py `__main__` block).
2. Switches to JAX backend, converts arrays.
3. Calls `step_pipeline.reset()` directly (not via `build_reset_fn` -- that's plan 02).
4. Calls `step_pipeline.step()` directly with all keyword args.
5. Runs 10 steps.
6. Asserts shapes: obs (n_agents, obs_dim), rewards (n_agents,), done scalar.
7. Asserts extra_state persists through steps.

If any issue is found in step_pipeline.py (e.g., missing import, wrong xp usage), fix it in step_pipeline.py.

Also verify on numpy backend:
1. Set backend to numpy.
2. Use `parse_layout()` to create an EnvState directly.
3. Call `step_pipeline.step()` with that state and dummy actions.
4. Assert the function returns (state, obs, rewards, done, infos) tuple with correct shapes.

**Important:** The numpy path test is intentionally lightweight -- it verifies the function runs without error, not full behavioral correctness. The JAX path test is the primary validation because it exercises JIT compilation which is the strictest correctness check.
  </action>
  <verify>
JAX smoke test: `step_pipeline.step()` and `step_pipeline.reset()` produce correct-shaped outputs under JIT compilation (via direct call, JIT traces automatically if backend is JAX... actually no, direct call without jax.jit just runs eagerly on JAX arrays which is fine for validation).

Numpy smoke test: `step_pipeline.step()` and `step_pipeline.reset()` run without error on numpy arrays.
  </verify>
  <done>
`step_pipeline.step()` and `step_pipeline.reset()` execute correctly on both JAX (eager) and numpy backends, producing correct output shapes and maintaining extra_state through multiple steps.
  </done>
</task>

</tasks>

<verification>
1. `cogrid/core/step_pipeline.py` exists and exports `step`, `reset`, `envstate_to_dict`.
2. `step()` body contains ZERO `jnp.` or `lax.` calls outside of `get_backend() == "jax"` blocks.
3. `reset()` body contains ZERO `jnp.` or `lax.` or `jax.random.` calls outside of `get_backend() == "jax"` blocks.
4. Both functions work on numpy backend without JAX installed (no unconditional jax imports).
5. Both functions work on JAX backend with correct array types.
</verification>

<success_criteria>
- `step()` and `reset()` are pure functions using `xp` that compose tick, movement, interaction, observation, and reward sub-functions from Phases 6-7
- Backend-specific code (RNG, stop_gradient) is isolated to `get_backend()` conditionals
- Functions work correctly on both numpy and JAX backends
</success_criteria>

<output>
After completion, create `.planning/phases/08-step-pipeline/08-01-SUMMARY.md`
</output>

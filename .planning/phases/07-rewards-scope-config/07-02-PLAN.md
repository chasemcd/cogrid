---
phase: 07-rewards-scope-config
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - cogrid/tests/test_cross_backend_parity.py
  - cogrid/tests/test_reward_parity.py
autonomous: true

must_haves:
  truths:
    - "Unified delivery_reward produces identical float32 reward values on numpy and JAX backends for the same state inputs"
    - "Unified onion_in_pot_reward produces identical float32 reward values on numpy and JAX backends for the same state inputs"
    - "Unified soup_in_dish_reward produces identical float32 reward values on numpy and JAX backends for the same state inputs"
    - "Unified compute_rewards produces identical combined reward values on numpy and JAX backends"
    - "All reward functions produce correct values under jax.jit (no ConcretizationTypeError)"
  artifacts:
    - path: "cogrid/tests/test_reward_parity.py"
      provides: "Cross-backend parity tests for all 3 unified reward functions + compute_rewards"
      contains: "def test_reward_parity_delivery"
    - path: "cogrid/tests/test_cross_backend_parity.py"
      provides: "Updated existing test to use compute_rewards instead of compute_rewards_jax"
      contains: "from cogrid.envs.overcooked.array_rewards import compute_rewards"
  key_links:
    - from: "cogrid/tests/test_reward_parity.py"
      to: "cogrid/envs/overcooked/array_rewards"
      via: "imports unified reward functions"
      pattern: "from cogrid.envs.overcooked.array_rewards import delivery_reward"
    - from: "cogrid/tests/test_reward_parity.py"
      to: "cogrid.backend._dispatch._reset_backend_for_testing"
      via: "backend switching for parity comparison"
      pattern: "_reset_backend_for_testing"
---

<objective>
Create cross-backend parity tests verifying that all unified reward functions produce identical results on numpy and JAX backends, and update the existing test file to use unified names.

Purpose: Satisfies TEST-01 requirement -- cross-backend parity test verifies that unified functions produce identical outputs on numpy and JAX backends for scripted state transitions. Also ensures the existing eager-vs-JIT test works with the renamed function.
Output: New `cogrid/tests/test_reward_parity.py` with 4 parity tests, updated `cogrid/tests/test_cross_backend_parity.py`.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-rewards-scope-config/07-RESEARCH.md
@cogrid/tests/test_cross_backend_parity.py
@cogrid/envs/overcooked/array_rewards.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cross-backend reward parity tests</name>
  <files>cogrid/tests/test_reward_parity.py</files>
  <action>
Create `cogrid/tests/test_reward_parity.py` with 4 test functions that verify unified reward functions produce identical float32 results on numpy and JAX backends.

Each test follows this pattern (from the research's verified test pattern):
1. Reset backend, set to "numpy", import the unified reward function
2. Build a scripted prev_state dict with numpy arrays (agent_pos, agent_dir, agent_inv, object_type_map, object_state_map, pot_contents, pot_timer, pot_positions)
3. Call the reward function, capture numpy result
4. Reset backend, set to "jax", convert the same state dict values to jax arrays
5. Call the SAME unified function (re-import after backend switch), capture JAX result
6. Compare with `np.testing.assert_allclose(np.array(result_np), np.array(result_jax), atol=1e-7)`

Use `_reset_backend_for_testing` from `cogrid.backend._dispatch` for backend switching between numpy and JAX.

**Test 1: `test_reward_parity_delivery`**
- Set up state where agent 0 holds onion_soup (type_id from Overcooked scope config), faces a delivery_zone, and performs action 4 (PickupDrop). Agent 1 is idle.
- Expected: agent 0 earns delivery reward. With common_reward=True (default), both agents get coefficient.
- Type IDs: Look them up from the Overcooked scope config symbol registry (import and call `build_overcooked_scope_config()` to get type_ids, or hardcode based on SYMBOL_REGISTRY).
- Build a minimal 5x5 grid object_type_map with a delivery_zone cell at agent 0's forward position.

**Test 2: `test_reward_parity_onion_in_pot`**
- Agent 0 holds onion, faces a pot with capacity (pot_contents has 1 onion in slot 0, slots 1-2 empty=-1), performs action 4.
- Expected: agent 0 earns onion_in_pot reward (coefficient=0.1, common_reward=False by default).
- pot_positions array matches the pot cell position.

**Test 3: `test_reward_parity_soup_in_dish`**
- Agent 0 holds plate, faces a pot with timer==0 (ready), performs action 4.
- Expected: agent 0 earns soup_in_dish reward (coefficient=0.3).
- pot_timer[pot_idx] == 0 for the matched pot.

**Test 4: `test_reward_parity_compute_rewards`**
- Uses the same delivery scenario from test 1.
- Calls `compute_rewards(prev_state, state, actions, reward_config)` on both backends with a reward_config containing delivery + onion_in_pot specs.
- Verifies combined rewards match across backends.

**Important implementation details:**
- To get type_ids, use `from cogrid.envs.overcooked.array_config import build_overcooked_scope_config; sc = build_overcooked_scope_config(); type_ids = sc["type_ids"]`. This is called ONCE before any backend switching (it only uses Python dicts, no array ops).
- The `_reset_backend_for_testing` call must happen BEFORE `set_backend` and BEFORE re-importing any module that uses `from cogrid.backend import xp`. Use `importlib.reload` on the reward module after backend switch to pick up the new xp binding, OR call the function fresh each time (the function-level xp import inside each reward function handles this automatically -- no reload needed).
- Actually, since reward functions use function-level `from cogrid.backend import xp` imports (established in 06-04), you do NOT need to reload the module. Just call `_reset_backend_for_testing()` then `set_backend("jax")`, and the next call to any reward function will pick up the JAX backend. But you DO need to re-import the functions after backend switch to clear any stale module-level references. Simplest approach: import the module once and call functions via `array_rewards.delivery_reward(...)`.
- Use `pytest.importorskip("jax")` to skip JAX tests gracefully when JAX is not installed.
- State dict values must be arrays of correct dtype (int32 for positions/types/timers, float32 not needed since rewards are computed from int state).
  </action>
  <verify>
Run: `python -m pytest cogrid/tests/test_reward_parity.py -v` -- all 4 tests should pass.

Run: `python -m pytest cogrid/tests/test_reward_parity.py -v --tb=short` -- verify no ConcretizationTypeError or TracerArrayConversionError.
  </verify>
  <done>
4 cross-backend parity tests pass, each verifying that the unified reward function produces identical float32 values on numpy and JAX backends (within atol=1e-7) for scripted state transitions that trigger each reward type.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update existing test to use unified compute_rewards</name>
  <files>cogrid/tests/test_cross_backend_parity.py</files>
  <action>
Update `test_rewards_jax_eager_vs_jit` in `cogrid/tests/test_cross_backend_parity.py` (lines 619-679):

1. Change the import on line 623 from:
   `from cogrid.envs.overcooked.array_rewards import compute_rewards_jax`
   to:
   `from cogrid.envs.overcooked.array_rewards import compute_rewards`

2. Update the eager call on line 639 from:
   `rew_e = compute_rewards_jax(prev_dict, curr_dict, actions, reward_config)`
   to:
   `rew_e = compute_rewards(prev_dict, curr_dict, actions, reward_config)`

3. Update the jitted wrapper function body on line 664 from:
   `return compute_rewards_jax(prev, curr, actions, reward_config)`
   to:
   `return compute_rewards(prev, curr, actions, reward_config)`

4. Update the docstring on line 620 from `compute_rewards_jax` to `compute_rewards`.

5. Update the error message on line 678 from `compute_rewards_jax` to `compute_rewards`.

Note: The existing test accesses `state.pot_contents`, `state.pot_timer`, `state.pot_positions` directly on EnvState (lines 669-672). These may have moved to extra_state. Check if the test uses `_setup_jax_env()` which returns an env with an `_env_state` that has these as direct attributes (old v1.0 EnvState) or via extra_state. If the test already works via the backward-compat alias `compute_rewards_jax = compute_rewards`, the change is purely cosmetic. Make the import change anyway for clarity.
  </action>
  <verify>
Run: `python -m pytest cogrid/tests/test_cross_backend_parity.py::test_rewards_jax_eager_vs_jit -v` -- should pass.

Run: `grep -n 'compute_rewards_jax' cogrid/tests/test_cross_backend_parity.py` -- should return no matches.
  </verify>
  <done>
The existing eager-vs-JIT reward test uses `compute_rewards` (unified name) and passes. No references to `compute_rewards_jax` remain in the test file.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest cogrid/tests/test_reward_parity.py -v` -- all 4 parity tests pass
2. `python -m pytest cogrid/tests/test_cross_backend_parity.py::test_rewards_jax_eager_vs_jit -v` -- existing test passes with unified import
3. `grep -rn 'compute_rewards_jax' cogrid/tests/` -- returns no matches in any test file
4. No ConcretizationTypeError or TracerArrayConversionError in any test output
</verification>

<success_criteria>
- 4 new cross-backend parity tests pass (delivery, onion_in_pot, soup_in_dish, compute_rewards)
- Existing eager-vs-JIT test updated to unified name and passes
- TEST-01 requirement satisfied: cross-backend parity verified for all unified reward functions
</success_criteria>

<output>
After completion, create `.planning/phases/07-rewards-scope-config/07-02-SUMMARY.md`
</output>

---
phase: 18-autowire-integration-parity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cogrid/core/array_features.py
  - cogrid/core/autowire.py
  - cogrid/tests/test_array_features.py
  - cogrid/tests/test_autowire.py
autonomous: true

must_haves:
  truths:
    - "compose_feature_fns accepts features from both global and scope-specific registries via multi-scope lookup"
    - "compose_feature_fns preserves caller-specified feature order when preserve_order=True"
    - "build_feature_config_from_components discovers registered ArrayFeature subclasses for global+scope and returns a composed feature function"
    - "LayoutID._layout_idx is set by build_feature_config_from_components before building feature functions"
  artifacts:
    - path: "cogrid/core/autowire.py"
      provides: "build_feature_config_from_components function"
      contains: "build_feature_config_from_components"
    - path: "cogrid/core/array_features.py"
      provides: "Updated compose_feature_fns with preserve_order and multi-scope support"
      contains: "preserve_order"
  key_links:
    - from: "cogrid/core/autowire.py"
      to: "cogrid/core/array_features.py"
      via: "build_feature_config_from_components calls compose_feature_fns"
      pattern: "compose_feature_fns"
    - from: "cogrid/core/autowire.py"
      to: "cogrid/core/component_registry.py"
      via: "get_feature_types to discover registered features"
      pattern: "get_feature_types"
---

<objective>
Add `build_feature_config_from_components(scope, n_agents, layout_idx)` to autowire and extend `compose_feature_fns` to support multi-scope feature lookup and caller-controlled ordering.

Purpose: Enable autowire to discover all registered ArrayFeature subclasses (global + scope) and compose them into a single observation function matching the existing 677-dim Overcooked output order exactly.

Output: `build_feature_config_from_components` in autowire.py + updated `compose_feature_fns` in array_features.py + test coverage
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@cogrid/core/array_features.py
@cogrid/core/autowire.py
@cogrid/core/component_registry.py
@cogrid/envs/overcooked/overcooked_array_features.py
@cogrid/tests/test_array_features.py
@cogrid/tests/test_autowire.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend compose_feature_fns with multi-scope lookup and preserve_order</name>
  <files>cogrid/core/array_features.py, cogrid/tests/test_array_features.py</files>
  <action>
  Two changes to `cogrid/core/array_features.py`:

  **1. Multi-scope feature lookup in _resolve_feature_metas:**

  Add an optional `scopes` parameter (list of scope strings) to `_resolve_feature_metas`. When provided, merge feature metadata from ALL listed scopes. When not provided, behave as before (single scope). Update `compose_feature_fns` and `obs_dim_for_features` to accept an optional `scopes` parameter and pass it through.

  Implementation:
  ```python
  def _resolve_feature_metas(feature_names, scope, scopes=None):
      from cogrid.core.component_registry import get_feature_types
      if scopes is not None:
          all_metas = []
          for s in scopes:
              all_metas.extend(get_feature_types(s))
      else:
          all_metas = get_feature_types(scope)
      meta_by_id = {m.feature_id: m for m in all_metas}
      for name in feature_names:
          if name not in meta_by_id:
              raise ValueError(f"Feature '{name}' not registered in scope '{scope}'.")
      return meta_by_id
  ```

  **2. Add preserve_order parameter to compose_feature_fns:**

  Add `preserve_order=False` parameter. When `True`, use the provided `feature_names` order directly (splitting per_agent and global but keeping each group in list order). When `False` (default), sort alphabetically as before.

  The key change is in the sorting lines:
  ```python
  if preserve_order:
      per_agent_names = [n for n in feature_names if meta_by_id[n].per_agent]
      global_names = [n for n in feature_names if not meta_by_id[n].per_agent]
  else:
      per_agent_names = sorted(n for n in feature_names if meta_by_id[n].per_agent)
      global_names = sorted(n for n in feature_names if not meta_by_id[n].per_agent)
  ```

  Also propagate `scopes` parameter to `compose_feature_fns` and `obs_dim_for_features`.

  **Tests to add in test_array_features.py:**

  1. `test_compose_preserve_order`: Register 3 per-agent features ("charlie", "alpha", "bravo") in a test scope. Call `compose_feature_fns` with `preserve_order=True` and order ["charlie", "alpha", "bravo"]. Verify output order is charlie, alpha, bravo (NOT alphabetical).

  2. `test_compose_multi_scope`: Register one feature in scope "test_scope_a" and another in "test_scope_b". Call `compose_feature_fns` with `scopes=["test_scope_a", "test_scope_b"]`. Verify both features are found and composed.

  IMPORTANT: Do NOT change any existing test behavior. The default `preserve_order=False` maintains alphabetical ordering. Existing tests remain unchanged.
  </action>
  <verify>
  Run `python -m pytest cogrid/tests/test_array_features.py -v` -- all existing tests pass plus 2 new tests.
  </verify>
  <done>
  compose_feature_fns supports `preserve_order=True` (caller-controlled ordering) and `scopes` (multi-scope lookup). Default behavior unchanged. 2 new tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add build_feature_config_from_components to autowire</name>
  <files>cogrid/core/autowire.py, cogrid/tests/test_autowire.py</files>
  <action>
  Add `build_feature_config_from_components(scope, n_agents, layout_idx=0)` to `cogrid/core/autowire.py`. This function:

  1. Discovers all registered ArrayFeature subclasses for both `scope` and `"global"` (using `get_feature_types` from component_registry).

  2. Builds the **exact ordered feature list** matching the existing `build_overcooked_feature_fn` output. The function must produce an explicit per-agent and global feature name list. For Overcooked scope, the per-agent order is:
     ```python
     [
         "agent_dir", "overcooked_inventory", "next_to_counter", "next_to_pot",
         "closest_onion", "closest_plate", "closest_plate_stack", "closest_onion_stack",
         "closest_onion_soup", "closest_delivery_zone", "closest_counter",
         "ordered_pot_features", "dist_to_other_players", "agent_position",
         "can_move_direction",
     ]
     ```
     And global order: `["layout_id", "environment_layout"]`

     For scopes WITHOUT explicit ordering (i.e., not overcooked), use alphabetical ordering (the compose_feature_fns default).

     Implementation approach: The function collects features from both global and scope registries. If all features are found, it passes `preserve_order=True` with an explicit order list. Otherwise it falls back to alphabetical.

     **Scope-specific ordering convention:** Define a module-level `_FEATURE_ORDER` dict mapping scope name to the ordered feature list. For "overcooked", this is the exact list above. Scopes not in this dict get alphabetical ordering.

  3. Sets `LayoutID._layout_idx = layout_idx` before calling `compose_feature_fns` (so the built feature function captures the correct layout index).

  4. Calls `compose_feature_fns(feature_names, scope, n_agents, scopes=[scope, "global"], preserve_order=True)` and returns a dict:
     ```python
     {
         "feature_fn": composed_fn,  # fn(state_dict, agent_idx) -> (obs_dim,) float32
         "obs_dim": total_obs_dim,
         "feature_names": feature_names,  # ordered list used
     }
     ```

  **Exclusion logic:** Global scope has "inventory" registered, but Overcooked uses "overcooked_inventory" instead. The `_FEATURE_ORDER` dict for "overcooked" explicitly lists which features to use, so unlisted features (like "inventory") are simply not included.

  For non-overcooked scopes without explicit ordering: include ALL global + scope features, sorted alphabetically. Exclude global features that have a scope-specific override with the same conceptual purpose (this is a future concern -- for now, just include all).

  **Tests to add in test_autowire.py:**

  1. `test_build_feature_config_overcooked`: Call `build_feature_config_from_components("overcooked", n_agents=2, layout_idx=0)`. Verify it returns a dict with "feature_fn", "obs_dim", and "feature_names" keys. Verify `obs_dim == 677`. Verify `feature_names` has exactly 17 entries (15 per-agent + 2 global).

  2. `test_build_feature_config_sets_layout_idx`: Call with `layout_idx=3`. After the call, verify `LayoutID._layout_idx` was set to 3. Reset to 0 after.

  3. `test_build_feature_config_returns_callable`: Call it, then call the returned `feature_fn` with a mock state_dict (build one from a real Overcooked env reset). Verify the output shape is `(677,)` and dtype is `float32`.
  </action>
  <verify>
  Run `python -m pytest cogrid/tests/test_autowire.py -v` -- all existing tests pass plus 3 new tests. Also run `python -m pytest cogrid/tests/test_array_features.py -v` to confirm no regressions.
  </verify>
  <done>
  `build_feature_config_from_components("overcooked", 2, 0)` returns a dict with a composed feature function producing 677-dim float32 observations. LayoutID._layout_idx is wired correctly. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest cogrid/tests/test_array_features.py -v` -- all existing + 2 new tests pass
2. `python -m pytest cogrid/tests/test_autowire.py -v` -- all existing + 3 new tests pass
3. `python -m pytest cogrid/tests/ -v` -- full test suite passes (no regressions)
</verification>

<success_criteria>
- build_feature_config_from_components exists in autowire.py and returns composed feature function for overcooked scope
- compose_feature_fns supports preserve_order and multi-scope lookup
- Overcooked feature config produces obs_dim=677 for n_agents=2
- LayoutID._layout_idx is correctly wired by build_feature_config_from_components
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/18-autowire-integration-parity/18-01-SUMMARY.md`
</output>

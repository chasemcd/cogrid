---
phase: 18-autowire-integration-parity
plan: 02
type: execute
wave: 2
depends_on: ["18-01"]
files_modified:
  - cogrid/cogrid_env.py
  - cogrid/tests/test_overcooked_array_features.py
autonomous: true

must_haves:
  truths:
    - "CoGridEnv uses build_feature_config_from_components for feature composition -- no feature_fn_builder path"
    - "The step pipeline receives the composed feature function unchanged -- get_all_agent_obs call site works as before"
    - "Overcooked 677-dim observation matches element-by-element across all 5 layouts"
    - "Non-overcooked scopes still work via generic array features fallback"
  artifacts:
    - path: "cogrid/cogrid_env.py"
      provides: "CoGridEnv using autowired feature composition"
      contains: "build_feature_config_from_components"
    - path: "cogrid/tests/test_overcooked_array_features.py"
      provides: "Element-by-element parity test for composed vs monolithic features"
      contains: "test_composed_vs_monolithic_677_parity"
  key_links:
    - from: "cogrid/cogrid_env.py"
      to: "cogrid/core/autowire.py"
      via: "build_feature_config_from_components call in __init__ / reset"
      pattern: "build_feature_config_from_components"
    - from: "cogrid/cogrid_env.py"
      to: "cogrid/core/step_pipeline.py"
      via: "self._feature_fn passed to build_step_fn and build_reset_fn"
      pattern: "self._feature_fn"
---

<objective>
Wire CoGridEnv to use `build_feature_config_from_components` for feature composition, eliminating the `feature_fn_builder` path, and verify exact 677-dim parity across all 5 Overcooked layouts.

Purpose: Complete the integration so CoGridEnv uses the autowired ArrayFeature composition as the sole feature path. The step pipeline interface remains unchanged -- only the source of the feature function changes.

Output: Updated cogrid_env.py + element-by-element parity test
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/18-autowire-integration-parity/18-01-SUMMARY.md
@cogrid/cogrid_env.py
@cogrid/core/autowire.py
@cogrid/core/step_pipeline.py
@cogrid/tests/test_overcooked_array_features.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire CoGridEnv to use build_feature_config_from_components</name>
  <files>cogrid/cogrid_env.py</files>
  <action>
  Replace the current feature_fn_builder path in CoGridEnv with the new autowired feature composition.

  **In __init__ (lines ~222-238):**

  Remove the `feature_fn_builder` / fallback block:
  ```python
  # REMOVE THIS BLOCK:
  feature_fn_builder = self._scope_config.get("feature_fn_builder")
  if feature_fn_builder is not None:
      self._feature_fn_builder = feature_fn_builder
      self._feature_fn = None  # built in reset() once layout is known
  else:
      self._feature_fn_builder = None
      from cogrid.feature_space.array_features import build_feature_fn
      jax_feature_names = [...]
      self._feature_fn = build_feature_fn(...)
  ```

  Replace with:
  ```python
  # Feature function is built in reset() after layout is known,
  # using autowired ArrayFeature composition.
  self._feature_fn = None
  ```

  **In reset() (lines ~506-525):**

  Remove the `_feature_fn_builder` block:
  ```python
  # REMOVE THIS BLOCK:
  if self._feature_fn_builder is not None:
      _overcooked_layouts = [...]
      _layout_idx = (...)
      self._feature_fn = self._feature_fn_builder(
          scope=self.scope, n_agents=n_agents,
          layout_idx=_layout_idx, grid_shape=(self.grid.height, self.grid.width),
      )
  ```

  Replace with autowired feature composition:
  ```python
  # Build feature function via autowired ArrayFeature composition
  from cogrid.core.autowire import build_feature_config_from_components

  _overcooked_layouts = [
      "overcooked_cramped_room_v0",
      "overcooked_asymmetric_advantages_v0",
      "overcooked_coordination_ring_v0",
      "overcooked_forced_coordination_v0",
      "overcooked_counter_circuit_v0",
  ]
  _layout_idx = (
      _overcooked_layouts.index(self.current_layout_id)
      if self.current_layout_id in _overcooked_layouts
      else 0
  )

  feature_config = build_feature_config_from_components(
      self.scope, n_agents=n_agents, layout_idx=_layout_idx,
  )
  self._feature_fn = feature_config["feature_fn"]
  ```

  **Key points:**
  - The `_feature_fn_builder` attribute is removed entirely. No more `self._feature_fn_builder`.
  - Feature function is always built in reset() via autowire.
  - The layout_idx computation stays in reset() (it needs `self.current_layout_id` which is set by `_gen_grid()`).
  - For non-overcooked scopes, `build_feature_config_from_components` uses alphabetical ordering of all discovered features (global + scope), which is the same as the existing generic `build_feature_fn` but through the new ArrayFeature system.
  - The step pipeline receives `self._feature_fn` unchanged -- the interface is the same `fn(state_dict, agent_idx) -> (obs_dim,) float32`.

  **Also clean up:** Remove the `import` of `build_feature_fn` from `cogrid.feature_space.array_features` in the `__init__` fallback since that path no longer exists.

  IMPORTANT: Do NOT touch `cogrid/core/step_pipeline.py`. The step pipeline already works with any `feature_fn(state_dict, agent_idx)` callable. The interface is unchanged.

  IMPORTANT: The `feature_fn_builder` key still exists in `scope_config` (Pot.build_feature_fn is still registered as a GridObject classmethod -- that cleanup is Phase 19). We just stop USING it in CoGridEnv. It remains in scope_config as dead weight until Phase 19 removes it.
  </action>
  <verify>
  Run `python -m pytest cogrid/tests/test_overcooked_array_features.py -v` -- all existing tests pass (especially `test_obs_shape_677`, `test_parity_with_python_features`, `test_step_preserves_shape`).
  Run `python -m pytest cogrid/tests/ -v` -- full test suite passes.
  </verify>
  <done>
  CoGridEnv uses `build_feature_config_from_components` exclusively for feature composition. No `feature_fn_builder` usage remains in cogrid_env.py. All existing 677-dim and parity tests pass. Step pipeline interface unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add element-by-element composed vs monolithic 677-dim parity test</name>
  <files>cogrid/tests/test_overcooked_array_features.py</files>
  <action>
  Add a parity test that verifies the composed ArrayFeature output matches the monolithic `build_overcooked_feature_fn` output element-by-element across all 5 Overcooked layouts and multiple states (reset + several steps).

  Add this test to `cogrid/tests/test_overcooked_array_features.py`:

  ```python
  @pytest.mark.parametrize("layout_name", OVERCOOKED_LAYOUTS)
  def test_composed_vs_monolithic_677_parity(layout_name):
      """Composed ArrayFeature output matches monolithic build_overcooked_feature_fn element-by-element."""
      from cogrid.core.autowire import build_feature_config_from_components
      from cogrid.envs.overcooked.overcooked_array_features import build_overcooked_feature_fn
      import cogrid.envs  # noqa: F401 -- ensure registration

      _overcooked_layouts = [
          "overcooked_cramped_room_v0",
          "overcooked_asymmetric_advantages_v0",
          "overcooked_coordination_ring_v0",
          "overcooked_forced_coordination_v0",
          "overcooked_counter_circuit_v0",
      ]
      layout_idx = _overcooked_layouts.index(layout_name)

      # Build monolithic feature function (the old way)
      monolithic_fn = build_overcooked_feature_fn(
          scope="overcooked", n_agents=2, layout_idx=layout_idx,
          grid_shape=None,  # Not used by the function for output shape
      )

      # Build composed feature function (the new way)
      feature_config = build_feature_config_from_components(
          "overcooked", n_agents=2, layout_idx=layout_idx,
      )
      composed_fn = feature_config["feature_fn"]

      # Create env and get state_dict
      env = _make_env(layout_name)
      env.reset(seed=42)

      # Build state_dict from env._env_state (same as step_pipeline._build_state_dict)
      state = env._env_state
      state_dict = {
          "agent_pos": np.array(state.agent_pos),
          "agent_dir": np.array(state.agent_dir),
          "agent_inv": np.array(state.agent_inv),
          "wall_map": np.array(state.wall_map),
          "object_type_map": np.array(state.object_type_map),
          "object_state_map": np.array(state.object_state_map),
      }
      for key, val in state.extra_state.items():
          short_key = key.split(".", 1)[-1] if "." in key else key
          state_dict[short_key] = np.array(val)

      # Compare outputs for both agents
      for agent_idx in range(2):
          mono_obs = monolithic_fn(state_dict, agent_idx)
          comp_obs = composed_fn(state_dict, agent_idx)

          assert mono_obs.shape == comp_obs.shape == (677,), (
              f"Shape mismatch: mono={mono_obs.shape}, comp={comp_obs.shape}"
          )
          np.testing.assert_allclose(
              mono_obs, comp_obs, atol=1e-6,
              err_msg=f"Layout {layout_name}, agent {agent_idx}: element-by-element mismatch",
          )

      # Also verify after a few steps
      for step_num in range(3):
          actions = {aid: np.random.randint(0, 5) for aid in env.possible_agents}
          obs, _, terms, truncs, _ = env.step(actions)
          if any(terms.values()) or any(truncs.values()):
              break

          state = env._env_state
          state_dict = {
              "agent_pos": np.array(state.agent_pos),
              "agent_dir": np.array(state.agent_dir),
              "agent_inv": np.array(state.agent_inv),
              "wall_map": np.array(state.wall_map),
              "object_type_map": np.array(state.object_type_map),
              "object_state_map": np.array(state.object_state_map),
          }
          for key, val in state.extra_state.items():
              short_key = key.split(".", 1)[-1] if "." in key else key
              state_dict[short_key] = np.array(val)

          for agent_idx in range(2):
              mono_obs = monolithic_fn(state_dict, agent_idx)
              comp_obs = composed_fn(state_dict, agent_idx)
              np.testing.assert_allclose(
                  mono_obs, comp_obs, atol=1e-6,
                  err_msg=f"Layout {layout_name}, step {step_num}, agent {agent_idx}",
              )
  ```

  NOTE: The `grid_shape` parameter passed to `build_overcooked_feature_fn` is not used by any feature in the monolithic function for computing outputs (it was originally planned for environment_layout but max_layout_shape is used instead). Pass any value or None.

  Also update the existing `test_autowire_provides_feature_fn_builder` test name to `test_autowire_provides_feature_fn_builder_legacy` and add a comment that this is testing the Pot.build_feature_fn classmethod path which still exists in scope_config but is no longer used by CoGridEnv. This documents the state clearly without breaking backward compat.

  Actually, on second thought, do NOT rename the existing test. Just add a comment to it noting it tests the legacy path still present in scope_config. Phase 19 will remove it.
  </action>
  <verify>
  Run `python -m pytest cogrid/tests/test_overcooked_array_features.py::test_composed_vs_monolithic_677_parity -v` -- all 5 layout parameterizations pass.
  Run `python -m pytest cogrid/tests/ -v` -- full test suite passes.
  </verify>
  <done>
  Element-by-element parity test passes for all 5 Overcooked layouts across reset state and 3 steps. Composed ArrayFeature output is numerically identical to monolithic build_overcooked_feature_fn output. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest cogrid/tests/test_overcooked_array_features.py -v` -- all tests pass including new parity test
2. `python -m pytest cogrid/tests/ -v` -- full test suite passes (no regressions)
3. Grep `cogrid/cogrid_env.py` for `feature_fn_builder` -- no references remain (removed)
4. Grep `cogrid/cogrid_env.py` for `build_feature_config_from_components` -- present in reset()
5. `test_composed_vs_monolithic_677_parity` passes for all 5 layouts with element-by-element comparison
</verification>

<success_criteria>
- CoGridEnv uses build_feature_config_from_components exclusively (no feature_fn_builder usage)
- Step pipeline interface unchanged (get_all_agent_obs works as before)
- 677-dim parity verified element-by-element across all 5 Overcooked layouts and multiple states
- Full test suite passes with no regressions
- feature_fn_builder key still exists in scope_config (Pot classmethod remains for Phase 19 cleanup) but is not used by CoGridEnv
</success_criteria>

<output>
After completion, create `.planning/phases/18-autowire-integration-parity/18-02-SUMMARY.md`
</output>

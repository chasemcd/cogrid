---
phase: 06-core-algorithms
plan: 04
type: tdd
wave: 2
depends_on: ["06-01", "06-02", "06-03"]
files_modified:
  - cogrid/tests/test_collision_resolution.py
  - cogrid/core/jax_step.py
  - cogrid/core/movement.py
  - cogrid/core/interactions.py
  - cogrid/feature_space/array_features.py
  - cogrid/envs/overcooked/array_config.py
autonomous: true

must_haves:
  truths:
    - "Collision resolution unit tests cover head-on collisions, T-intersection conflicts, 3-way conflicts (for n_agents>2), swap detection, and wall-blocked agents"
    - "All collision tests pass on numpy backend"
    - "Zero int() casts on array values exist in movement.py, interactions.py, array_features.py, and array_config.py step-path functions"
    - "jax_step.py imports unified functions (move_agents, process_interactions, get_all_agent_obs, overcooked_tick) instead of _jax variants"
    - "jax_step.py smoke test passes end-to-end JIT compilation"
  artifacts:
    - path: "cogrid/tests/test_collision_resolution.py"
      provides: "Dedicated collision resolution edge-case tests"
      contains: "def test_head_on_collision"
    - path: "cogrid/core/jax_step.py"
      provides: "Updated jax_step using unified function imports"
      contains: "from cogrid.core.movement import move_agents"
  key_links:
    - from: "cogrid/core/jax_step.py"
      to: "cogrid/core/movement.py"
      via: "import move_agents (unified)"
      pattern: "from cogrid\\.core\\.movement import move_agents"
    - from: "cogrid/core/jax_step.py"
      to: "cogrid/core/interactions.py"
      via: "import process_interactions (unified)"
      pattern: "from cogrid\\.core\\.interactions import process_interactions"
    - from: "cogrid/core/jax_step.py"
      to: "cogrid/feature_space/array_features.py"
      via: "import get_all_agent_obs (unified)"
      pattern: "from cogrid\\.feature_space\\.array_features import get_all_agent_obs"
---

<objective>
Write collision resolution edge-case tests (TEST-02), perform final int() cast audit (CLEAN-05), and wire jax_step.py to use the unified functions from Plans 01-03.

Purpose: Validate correctness of the vectorized collision resolution algorithm for all known edge cases, ensure zero int() casts remain in the step path, and update jax_step.py as the main consumer of the unified functions.

Output: Test file proving collision resolution correctness, clean step path with zero int() casts, jax_step.py using unified imports.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-core-algorithms/06-RESEARCH.md
@cogrid/core/jax_step.py
@cogrid/core/movement.py
@cogrid/core/interactions.py
@cogrid/feature_space/array_features.py
@cogrid/envs/overcooked/array_config.py
@cogrid/tests/test_cross_backend_parity.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write collision resolution edge-case tests</name>
  <files>cogrid/tests/test_collision_resolution.py</files>
  <action>
Create cogrid/tests/test_collision_resolution.py with dedicated unit tests for the vectorized collision resolution in move_agents(). Use pytest.

Tests must cover the following edge cases on a simple 5x5 or 7x7 grid (no walls except borders for simplicity):

**Test 1: test_head_on_collision**
Two agents moving toward each other, resulting in both trying to occupy the same cell.
- Agent 0 at (2,1) facing Right, Agent 1 at (2,3) facing Left.
- Both take MoveRight/MoveLeft respectively (toward (2,2)).
- Expected: One agent reaches (2,2), the other stays. Both outputs are valid positions (no overlap). Priority determines winner.
- Test both priority orderings: [0,1] and [1,0].

**Test 2: test_swap_detection**
Two adjacent agents trying to swap positions.
- Agent 0 at (2,2) facing Right, Agent 1 at (2,3) facing Left.
- Both move toward each other: MoveRight and MoveLeft.
- Expected: Swap detected, both revert to original positions.

**Test 3: test_into_staying_agent**
One agent tries to move into the cell of a non-moving agent.
- Agent 0 at (2,2) facing Right, Agent 1 at (2,3) doing Noop (action 6).
- Agent 0 takes MoveRight toward (2,3).
- Expected: Agent 0 blocked (Agent 1 is staying at (2,3)).

**Test 4: test_no_conflict_independent_movement**
Two agents moving to different cells with no conflicts.
- Agent 0 at (1,1) facing Right, Agent 1 at (3,3) facing Left.
- Both move in their facing direction.
- Expected: Both succeed, Agent 0 at (1,2), Agent 1 at (3,2).

**Test 5: test_wall_blocked**
An agent tries to move into a wall.
- Agent 0 at (1,1) facing Up (toward row 0 which is wall).
- Expected: Agent 0 stays at (1,1).

**Test 6: test_no_overlap_invariant**
Run 100 random steps on cramped_room layout. After each step, verify that no two agents occupy the same cell (the fundamental collision resolution invariant).
- Use the actual Overcooked cramped_room wall_map and object_type_map.
- Randomize actions and priorities each step.

**Test 7: test_priority_determines_winner**
Two agents target the same cell. Verify that the agent with priority index 0 (first in priority array) wins.
- Priority [0, 1]: Agent 0 gets the cell.
- Priority [1, 0]: Agent 1 gets the cell.

Each test:
- Sets up agent_pos, agent_dir, actions, wall_map, object_type_map, can_overlap, priority arrays directly.
- Calls move_agents().
- Asserts specific position outcomes.
- Uses numpy backend (import numpy as np).

```python
import numpy as np
import pytest
from cogrid.backend import set_backend
set_backend("numpy")  # at module level for test file
from cogrid.core.movement import move_agents
```
  </action>
  <verify>
Run `pytest cogrid/tests/test_collision_resolution.py -v` and verify all tests pass.
  </verify>
  <done>
  - test_collision_resolution.py exists with 7+ tests covering all edge cases
  - All tests pass on numpy backend
  - No-overlap invariant verified across 100 random steps
  - Priority ordering correctness verified
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire jax_step.py to unified functions and audit int() casts</name>
  <files>
    cogrid/core/jax_step.py
    cogrid/core/movement.py
    cogrid/core/interactions.py
    cogrid/feature_space/array_features.py
    cogrid/envs/overcooked/array_config.py
  </files>
  <action>
**Part A: Update jax_step.py imports and calls**

Update jax_step.py to use the unified function imports:

1. Replace `from cogrid.core.movement import move_agents_jax` with `from cogrid.core.movement import move_agents`.

2. In the movement section of `jax_step()`, change the call to:
   ```python
   # Compute priority from RNG
   import jax
   key, subkey = jax.random.split(state.rng_key)
   priority = jax.random.permutation(subkey, state.n_agents)

   new_pos, new_dir = move_agents(
       state.agent_pos, state.agent_dir, actions,
       state.wall_map, state.object_type_map,
       lookup_tables["CAN_OVERLAP"],
       priority, state.action_set,
   )
   state = dataclasses.replace(state, agent_pos=new_pos, agent_dir=new_dir, rng_key=key)
   ```
   Note: The RNG key split happens in jax_step, not in move_agents. The priority array is pre-computed and passed in. The return is now `(new_pos, new_dir)` -- no third rng_key return.

3. Replace `from cogrid.core.interactions import process_interactions_jax` with `from cogrid.core.interactions import process_interactions`.

4. Update the interaction call to match the new signature:
   ```python
   agent_inv, otm, osm, extra_state_out = process_interactions(
       state.agent_pos, state.agent_dir, state.agent_inv, actions,
       state.object_type_map, state.object_state_map,
       lookup_tables, scope_config, dir_vec_table,
       action_pickup_drop_idx, action_toggle_idx,
       **{k.split(".", 1)[-1] if "." in k else k: v
          for k, v in state.extra_state.items()},
   )
   ```
   Adjust as needed to match the actual unified process_interactions() return format.

5. Replace `from cogrid.feature_space.array_features import get_all_agent_obs_jax` with `from cogrid.feature_space.array_features import get_all_agent_obs`.

6. Replace `get_all_agent_obs_jax(feature_fn, state_dict, state.n_agents)` with `get_all_agent_obs(feature_fn, state_dict, state.n_agents)`.

7. For the tick handler call, replace `tick_handler_jax` key lookup with `tick_handler`:
   ```python
   tick_handler = scope_config.get("tick_handler") if scope_config else None
   ```
   And call `tick_handler(pot_contents, pot_timer)` -- same function signature.

8. In `jax_reset()`, update the feature function call:
   ```python
   from cogrid.feature_space.array_features import get_all_agent_obs
   # ...
   obs = get_all_agent_obs(feature_fn, state_dict, n_agents)
   ```

9. In the smoke test (`__main__` block), update:
   - `build_feature_fn_jax` -> `build_feature_fn` import
   - Any `_jax` function references

**Part B: Final int() cast audit**

Search all 4 step-path files for remaining `int()` casts on array values:

```bash
grep -n 'int(' cogrid/core/movement.py cogrid/core/interactions.py cogrid/feature_space/array_features.py cogrid/envs/overcooked/array_config.py
```

For each occurrence found:
- If in a step-path function (move_agents, process_interactions, feature functions, overcooked_tick, overcooked_interaction_body): MUST eliminate.
- If in init-time code (_build_static_tables, _build_type_ids, _extract_overcooked_state): acceptable, keep.
- If in test code (test_movement_parity, test_feature_parity): acceptable, keep.

Common replacements:
- `int(arr)` for comparison -> `arr == value` (array comparison)
- `int(arr)` for indexing -> use array scalar directly (both numpy and JAX support this)
- `if int(x) == 0:` -> `xp.where(x == 0, ...)`

Document the final count: the goal is zero int() casts in step-path functions (CLEAN-05).

**Part C: Verify jax_step smoke test**

Run `python cogrid/core/jax_step.py` to verify the end-to-end smoke test still passes after all the import changes. This test JIT-compiles reset + step on Overcooked cramped_room and runs 11 steps.

If the smoke test fails, debug and fix the issue. Common issues:
- Import path changes (function renamed)
- Return tuple structure changes
- Missing extra_state handling
- Scope config key name changes

The smoke test passing is the ultimate integration validation for Phase 6.
  </action>
  <verify>
Run `grep -rn 'int(' cogrid/core/movement.py cogrid/core/interactions.py cogrid/feature_space/array_features.py cogrid/envs/overcooked/array_config.py | grep -v '# init-time\|_build_\|_extract_\|test_\|__main__\|dtype=\|int32\|int8'` and verify zero results from step-path code.

Run `python cogrid/core/jax_step.py` and verify "SMOKE TEST PASSED" output.

Run `pytest cogrid/tests/test_collision_resolution.py -v` and verify all tests pass.

Run `grep -rn 'move_agents_jax\|move_agents_array\|process_interactions_jax\|process_interactions_array\|get_all_agent_obs_jax\|build_feature_fn_jax\|tick_handler_jax\|interaction_body_jax' cogrid/core/jax_step.py` and verify zero results (all old function names gone).
  </verify>
  <done>
  - jax_step.py imports and calls unified functions exclusively
  - Zero _jax or _array function references in jax_step.py
  - Zero int() casts in step-path functions across all 4 files
  - jax_step.py smoke test passes (JIT compilation + 11 steps)
  - All collision resolution tests pass
  </done>
</task>

</tasks>

<verification>
1. `pytest cogrid/tests/test_collision_resolution.py -v` -- all tests pass
2. `python cogrid/core/jax_step.py` -- smoke test passes
3. Zero _jax function references in jax_step.py
4. Zero int() casts in step-path functions
5. All edge cases covered: head-on, swap, staying-blocked, wall-blocked, no-overlap invariant
</verification>

<success_criteria>
- Collision resolution test file exists with 7+ tests
- All tests pass on numpy backend
- jax_step.py uses only unified function imports
- jax_step.py smoke test passes end-to-end JIT compilation
- Zero int() casts in step-path code (CLEAN-05 met)
- No-overlap invariant holds for 100 random steps
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-algorithms/06-04-SUMMARY.md`
</output>

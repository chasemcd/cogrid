---
phase: 06-core-algorithms
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - cogrid/feature_space/array_features.py
autonomous: true

must_haves:
  truths:
    - "Each of the 5 feature extractors exists as a single function using xp -- no _jax variants"
    - "build_feature_fn() is a single function that works for both numpy and JAX backends"
    - "get_all_agent_obs() is a single function using xp.stack with a Python loop (vmap deferred to Phase 8)"
    - "full_map_encoding_feature() uses vectorized agent overlay with xp instead of a Python loop with int() casts"
    - "Zero int() casts on array values exist in any feature function"
  artifacts:
    - path: "cogrid/feature_space/array_features.py"
      provides: "5 unified feature extractors + build_feature_fn + get_all_agent_obs"
      contains: "def agent_pos_feature("
  key_links:
    - from: "cogrid/feature_space/array_features.py"
      to: "cogrid/backend/xp"
      via: "xp import for all array operations"
      pattern: "from cogrid\\.backend import xp"
---

<objective>
Consolidate all 10 feature functions (5 numpy + 5 JAX) into 5 unified functions using xp, plus unified build_feature_fn() and get_all_agent_obs().

Purpose: Feature extractors are the simplest unification targets -- most are trivial one-line xp replacements. The main complexity is full_map_encoding which needs vectorized agent overlay.

Output: cogrid/feature_space/array_features.py with 5 unified feature functions, unified composition functions, and zero duplicate implementations.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-core-algorithms/06-RESEARCH.md
@cogrid/feature_space/array_features.py
@cogrid/backend/array_ops.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unify core feature extractors to use xp</name>
  <files>cogrid/feature_space/array_features.py</files>
  <action>
Replace all 10 feature functions (5 numpy + 5 JAX) with 5 unified functions using `xp`. Remove the `import numpy as np` at module level; replace with `from cogrid.backend import xp`.

**1. agent_pos_feature (trivial):**
```python
def agent_pos_feature(agent_pos, agent_idx):
    """Extract agent position as (2,) int32 array."""
    return agent_pos[agent_idx].astype(xp.int32)
```
Delete `agent_pos_feature_jax`.

**2. agent_dir_feature (trivial):**
```python
def agent_dir_feature(agent_dir, agent_idx):
    """One-hot encoding of agent direction as (4,) int32 array."""
    return (xp.arange(4) == agent_dir[agent_idx]).astype(xp.int32)
```
This uses the broadcast comparison approach from the JAX version. Delete `agent_dir_feature_jax`.

**3. inventory_feature (trivial):**
```python
def inventory_feature(agent_inv, agent_idx):
    """Inventory encoding as (1,) array. 0 = empty, type_id+1 otherwise."""
    inv_val = agent_inv[agent_idx, 0]
    feature_val = xp.where(inv_val == -1, 0, inv_val + 1)
    return xp.array([feature_val], dtype=xp.int32)
```
Uses xp.where instead of int() + Python if/else. Delete `inventory_feature_jax`.

**4. can_move_direction_feature:**
```python
def can_move_direction_feature(agent_pos, agent_idx, wall_map, object_type_map, can_overlap_table):
    """Multi-hot encoding of movability in 4 directions."""
    H, W = wall_map.shape
    deltas = xp.array([[0, 1], [0, -1], [1, 0], [-1, 0]], dtype=xp.int32)
    pos = agent_pos[agent_idx]
    neighbors = pos[None, :] + deltas  # (4, 2)

    in_bounds = (
        (neighbors[:, 0] >= 0) & (neighbors[:, 0] < H)
        & (neighbors[:, 1] >= 0) & (neighbors[:, 1] < W)
    )

    clipped = xp.clip(neighbors, xp.array([0, 0]), xp.array([H - 1, W - 1]))
    type_ids = object_type_map[clipped[:, 0], clipped[:, 1]]
    can_overlap = can_overlap_table[type_ids]

    return (in_bounds & (can_overlap == 1)).astype(xp.int32)
```
Uses deltas array approach from JAX version. Delete `can_move_direction_feature_jax`. Also remove the `from cogrid.core.grid_utils import adjacent_positions` import if no longer needed.

**5. full_map_encoding_feature:**

This is the most complex. The numpy version uses a Python loop with `int()` casts for agent overlay; the JAX version uses vectorized scatter with pre-computed `agent_type_ids`.

The unified version takes `agent_type_ids` as a parameter (pre-computed at init time by build_feature_fn), matching the JAX approach:

```python
def full_map_encoding_feature(
    object_type_map, object_state_map,
    agent_pos, agent_dir, agent_inv,
    agent_type_ids,  # (4,) int32 -- pre-computed at init time
    max_map_size=(12, 12),
):
    """Full map encoding as (max_H, max_W, 3) int8 array."""
    from cogrid.backend.array_ops import set_at_2d

    max_H, max_W = max_map_size
    H, W = object_type_map.shape

    encoding = xp.zeros((max_H, max_W, 3), dtype=xp.int8)

    # Channel 0: type IDs
    # Use set_at-compatible approach. For sliced assignment:
    # On numpy: encoding[:H, :W, 0] = object_type_map.astype(int8)
    # On JAX: encoding = encoding.at[:H, :W, 0].set(...)
    # Since this is a slice assignment (not single-element), use a different approach:
    # Build the encoding from pieces. The simplest xp-compatible way:
    # Create a (max_H, max_W) padded version of each channel.
    ch0 = xp.zeros((max_H, max_W), dtype=xp.int8)
    # For slice assignment compatibility, use array construction:
    # pad object_type_map to max_H x max_W, then cast
    # Actually: numpy supports ch0[:H, :W] = data. JAX supports ch0.at[:H, :W].set(data).
    # Both work with the array_ops pattern? No -- set_at_2d takes row, col scalars.
    # For slice assignments, directly use the backend:
    from cogrid.backend._dispatch import get_backend
    if get_backend() == "jax":
        encoding = encoding.at[:H, :W, 0].set(object_type_map.astype(xp.int8))
        encoding = encoding.at[:H, :W, 2].set(object_state_map.astype(xp.int8))
    else:
        encoding[:H, :W, 0] = object_type_map.astype(xp.int8)
        encoding[:H, :W, 2] = object_state_map.astype(xp.int8)
    ```

    WAIT -- the project rule says "ALL backend branching MUST go through array_ops.set_at()". But set_at only handles scalar indices. For slice assignment, we need to either:
    (a) Extend array_ops with a set_at_slice helper, or
    (b) Use a different approach that works on both backends without branching.

    Better approach: construct the full padded array without slice assignment:
    ```python
    import numpy as _np  # for pad, which works at init
    # Actually, xp.pad works on both:
    pad_h = max_H - H
    pad_w = max_W - W
    ch0 = xp.pad(object_type_map.astype(xp.int8), ((0, pad_h), (0, pad_w)))
    ch1 = xp.zeros((max_H, max_W), dtype=xp.int8)
    ch2 = xp.pad(object_state_map.astype(xp.int8), ((0, pad_h), (0, pad_w)))
    encoding = xp.stack([ch0, ch1, ch2], axis=-1)
    ```

    Then agent overlay using vectorized scatter:
    ```python
    agent_type = agent_type_ids[agent_dir]  # (n_agents,)
    agent_state = xp.where(agent_inv[:, 0] == -1, 0, agent_inv[:, 0])

    rows = agent_pos[:, 0]
    cols = agent_pos[:, 1]

    # Scatter agents. Need set_at for each channel at (rows, cols).
    # array_ops.set_at_2d takes scalar row, col. For vectorized scatter:
    # On numpy: encoding[rows, cols, 0] = agent_type.astype(int8)
    # On JAX: encoding = encoding.at[rows, cols, 0].set(agent_type.astype(int8))
    # Since n_agents is 2 (tiny), unroll:
    for i in range(agent_pos.shape[0]):  # n_agents is static/small
        encoding = set_at_2d(... # doesn't support 3D
    ```

    **Simplest correct approach** (matching the anti-pattern rule pragmatically): Since encoding is created fresh in this function (no mutation of caller's data), and the only difference is the syntax for element/slice assignment, use a minimal backend check in this one function for the scatter step. But the research says: "ALL backend branching MUST go through array_ops.set_at()".

    **Practical solution**: Add a `set_at_rows_cols` helper to array_ops.py that handles fancy indexing for the scatter case. OR, since n_agents=2, unroll:

    ```python
    from cogrid.backend.array_ops import set_at_2d
    # set_at_2d returns new array with arr[row, col] = value
    # But we need arr[row, col, channel] -- 3D indexing.
    # Extend to use general set_at with tuple index.
    ```

    Actually, the cleanest approach: build encoding as numpy/jax-agnostic by constructing it fully with xp operations:

    ```python
    # Construct encoding directly
    pad_h = max_H - H
    pad_w = max_W - W
    ch0 = xp.pad(object_type_map.astype(xp.int8), ((0, pad_h), (0, pad_w)))
    ch1 = xp.zeros((max_H, max_W), dtype=xp.int8)
    ch2 = xp.pad(object_state_map.astype(xp.int8), ((0, pad_h), (0, pad_w)))

    # Agent overlay on ch0, ch1, ch2
    agent_type = agent_type_ids[agent_dir]
    agent_state = xp.where(agent_inv[:, 0] == -1, 0, agent_inv[:, 0])

    # For n_agents agents, scatter using set_at_2d on each 2D channel:
    rows = agent_pos[:, 0]
    cols = agent_pos[:, 1]
    for i_agent in range(agent_pos.shape[0]):
        r, c = rows[i_agent], cols[i_agent]
        ch0 = set_at_2d(ch0, r, c, agent_type[i_agent].astype(xp.int8))
        ch1 = set_at_2d(ch1, r, c, xp.int8(0))
        ch2 = set_at_2d(ch2, r, c, agent_state[i_agent].astype(xp.int8))

    encoding = xp.stack([ch0, ch1, ch2], axis=-1)
    return encoding
    ```

    This uses set_at_2d (the established helper) for each agent. The loop is over n_agents (2, static/tiny) and uses array-valued indices (not int() casts). This is acceptable per the Phase requirement because it's iterating over a static compile-time-known count, not a dynamic range -- similar to how the interaction body unrolls for 2 agents.

    IMPORTANT: `r, c = rows[i_agent], cols[i_agent]` -- these are array scalars (xp scalars), NOT Python ints. Do NOT cast with int().

Delete `full_map_encoding_feature_jax`.

**Update compose_features:**
```python
def compose_features(feature_fns, state_dict, agent_idx):
    features = [fn(state_dict, agent_idx) for fn in feature_fns]
    return xp.concatenate([f.ravel() for f in features])
```
Use `xp.concatenate` instead of `np.concatenate`.

**Delete all _jax variants and the JAX feature composition section.**

Delete:
- `agent_pos_feature_jax()`
- `agent_dir_feature_jax()`
- `full_map_encoding_feature_jax()`
- `can_move_direction_feature_jax()`
- `inventory_feature_jax()`
- `build_feature_fn_jax()`
- `get_all_agent_obs_jax()`

Remove the `import numpy as np` and replace with `from cogrid.backend import xp` (already present).
  </action>
  <verify>
Run `python -c "
from cogrid.feature_space.array_features import (
    agent_pos_feature, agent_dir_feature, full_map_encoding_feature,
    can_move_direction_feature, inventory_feature,
    build_feature_fn, get_all_agent_obs,
)
print('all imports OK')
"` to verify all functions importable.

Verify no _jax functions remain: `grep -c '_jax' cogrid/feature_space/array_features.py` should return 0.

Verify no `import numpy as np` at module level (only `from cogrid.backend import xp`): `grep -n '^import numpy' cogrid/feature_space/array_features.py` should return 0.

Verify zero `int(` in feature functions: `grep -n 'int(' cogrid/feature_space/array_features.py` should show 0 results (or only in the test_feature_parity function which is test code).
  </verify>
  <done>
  - 5 unified feature extractors replace 10 numpy+JAX functions
  - All functions use xp for array operations
  - full_map_encoding_feature takes agent_type_ids parameter and uses vectorized scatter
  - Zero int() casts in feature function bodies
  - All _jax variants deleted
  </done>
</task>

<task type="auto">
  <name>Task 2: Unify build_feature_fn() and get_all_agent_obs()</name>
  <files>cogrid/feature_space/array_features.py</files>
  <action>
**Unify build_feature_fn:**

Replace `build_feature_fn()` and `build_feature_fn_jax()` with a single `build_feature_fn()`. The key difference was that the JAX version pre-computes `agent_type_ids` and `can_overlap_table` as jnp arrays. The unified version does the same but with xp:

```python
def build_feature_fn(feature_names, scope="global", **kwargs):
    """Build composed feature function from feature names. Works on both backends."""
    from cogrid.core.grid_object import build_lookup_tables, object_to_idx

    tables = build_lookup_tables(scope=scope)
    max_map_size = kwargs.get("max_map_size", (12, 12))

    # Pre-compute agent_type_ids for full_map_encoding
    dir_to_char = [">", "v", "<", "^"]
    agent_type_ids = xp.array(
        [object_to_idx(f"agent_{c}", scope="global") for c in dir_to_char],
        dtype=xp.int32,
    )

    can_overlap_table = xp.array(tables["CAN_OVERLAP"], dtype=xp.int32)

    feature_fns = []
    for name in feature_names:
        if name == "agent_position":
            feature_fns.append(lambda sd, ai: agent_pos_feature(sd["agent_pos"], ai))
        elif name == "agent_dir":
            feature_fns.append(lambda sd, ai: agent_dir_feature(sd["agent_dir"], ai))
        elif name == "full_map_encoding":
            _atids = agent_type_ids
            _mms = max_map_size
            feature_fns.append(
                lambda sd, ai, atids=_atids, mms=_mms: full_map_encoding_feature(
                    sd["object_type_map"], sd["object_state_map"],
                    sd["agent_pos"], sd["agent_dir"], sd["agent_inv"],
                    agent_type_ids=atids, max_map_size=mms,
                )
            )
        elif name == "can_move_direction":
            _co = can_overlap_table
            feature_fns.append(
                lambda sd, ai, co=_co: can_move_direction_feature(
                    sd["agent_pos"], ai, sd["wall_map"], sd["object_type_map"], co
                )
            )
        elif name == "inventory":
            feature_fns.append(lambda sd, ai: inventory_feature(sd["agent_inv"], ai))
        else:
            raise ValueError(f"Unknown array feature: '{name}'")

    def composed_fn(state_dict, agent_idx):
        return compose_features(feature_fns, state_dict, agent_idx)

    return composed_fn
```

Key change from numpy version: pre-computes `agent_type_ids` (was missing, only computed in JAX version). Key change from JAX version: uses `xp` instead of `jnp`.

**Unify get_all_agent_obs:**

```python
def get_all_agent_obs(feature_fn, state_dict, n_agents):
    """Generate observations for all agents.
    Returns (n_agents, obs_dim) array. Uses Python loop with xp.stack.
    vmap optimization deferred to Phase 8.
    """
    return xp.stack([feature_fn(state_dict, i) for i in range(n_agents)])
```

Uses `xp.stack` instead of `np.stack`. The Python loop over n_agents (2-4) is acceptable per the research recommendation. vmap is deferred to Phase 8.

Delete `build_feature_fn_jax()` and `get_all_agent_obs_jax()`.

**Update test_feature_parity:** Keep the function but update it to use the unified functions. Replace any `np.` calls with `xp.` calls where operating on feature outputs. The test can still use `import numpy as np` for creating test data since tests are not in the step path.

**Update module docstring** to reflect that the file contains a single set of feature functions for both backends.
  </action>
  <verify>
Run `python -c "
from cogrid.backend import set_backend
set_backend('numpy')
from cogrid.feature_space.array_features import build_feature_fn, get_all_agent_obs
import numpy as np

fn = build_feature_fn(['agent_position', 'agent_dir', 'inventory'], scope='overcooked')
state_dict = {
    'agent_pos': np.array([[1,1],[3,3]], dtype=np.int32),
    'agent_dir': np.array([0, 2], dtype=np.int32),
    'agent_inv': np.full((2,1), -1, dtype=np.int32),
    'wall_map': np.zeros((7,7), dtype=np.int32),
    'object_type_map': np.zeros((7,7), dtype=np.int32),
    'object_state_map': np.zeros((7,7), dtype=np.int32),
}
obs = get_all_agent_obs(fn, state_dict, 2)
assert obs.shape[0] == 2
assert obs.ndim == 2
print(f'obs shape: {obs.shape}')
print('build_feature_fn + get_all_agent_obs smoke PASSED')
"` to verify the composition pipeline works.

Verify no _jax functions remain: `grep -c 'def.*_jax' cogrid/feature_space/array_features.py` should return 0.
  </verify>
  <done>
  - Single build_feature_fn() replaces both numpy and JAX versions
  - Single get_all_agent_obs() uses xp.stack with Python loop
  - Pre-computes agent_type_ids at init time using xp
  - All _jax composition functions deleted
  - Module has zero JAX-specific imports in non-test code
  </done>
</task>

</tasks>

<verification>
1. All 5 feature functions import from array_features without _jax suffix
2. build_feature_fn and get_all_agent_obs are single functions
3. No _jax function names remain
4. No `import jax` or `import jax.numpy` in non-test code
5. No int() casts in feature function bodies
6. Smoke test with numpy backend produces correct shapes
</verification>

<success_criteria>
- 5 unified feature functions (down from 10)
- Single build_feature_fn and get_all_agent_obs (down from 4)
- Zero _jax function variants in the file
- Zero int() casts in feature function bodies
- All functions use xp for array operations
- full_map_encoding uses vectorized agent overlay (set_at_2d loop over n_agents)
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-algorithms/06-03-SUMMARY.md`
</output>

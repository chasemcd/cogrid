---
phase: 06-core-algorithms
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - cogrid/core/interactions.py
  - cogrid/envs/overcooked/array_config.py
autonomous: true

must_haves:
  truths:
    - "A single process_interactions() function replaces both process_interactions_array() and process_interactions_jax()"
    - "Interaction processing uses vectorized condition computation with xp.where cascading -- no Python for-loops, no lax.fori_loop"
    - "Same-cell conflict detection and priority-based resolution work for 2 agents without loops"
    - "A single overcooked_tick() function replaces both _overcooked_tick_handler() and overcooked_tick_jax()"
    - "A single overcooked_interaction_body() replaces both _overcooked_interaction_handler() and overcooked_interaction_body_jax()"
    - "Zero int() casts on array values exist in the interaction and tick code paths"
  artifacts:
    - path: "cogrid/core/interactions.py"
      provides: "Unified process_interactions() using xp"
      contains: "def process_interactions("
    - path: "cogrid/envs/overcooked/array_config.py"
      provides: "Unified overcooked_tick() and overcooked_interaction_body()"
      contains: "def overcooked_tick("
  key_links:
    - from: "cogrid/core/interactions.py"
      to: "cogrid/envs/overcooked/array_config.py"
      via: "scope_config interaction handler delegation"
      pattern: "scope_config.*interaction"
    - from: "cogrid/core/interactions.py"
      to: "cogrid/backend/array_ops"
      via: "set_at/set_at_2d for array mutation"
      pattern: "from cogrid\\.backend\\.array_ops import"
---

<objective>
Unify the interaction processing pipeline and Overcooked tick/interaction handlers into single functions using xp array operations.

Purpose: The interaction pipeline is the second most complex algorithm to unify. It must replace the sequential Python loop (numpy path) and lax.fori_loop (JAX path) with vectorized condition computation and priority-masked application for all agents simultaneously.

Output: cogrid/core/interactions.py with unified process_interactions(), cogrid/envs/overcooked/array_config.py with unified overcooked_tick() and overcooked_interaction_body().
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-core-algorithms/06-RESEARCH.md
@cogrid/core/interactions.py
@cogrid/envs/overcooked/array_config.py
@cogrid/backend/array_ops.py
@cogrid/backend/env_state.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unify overcooked_tick() and overcooked_interaction_body()</name>
  <files>cogrid/envs/overcooked/array_config.py</files>
  <action>
**Unify the tick handler:**

Replace `_overcooked_tick_handler()` and `overcooked_tick_jax()` with a single `overcooked_tick()` function. This is straightforward since the two are nearly identical. The unified version:

```python
def overcooked_tick(pot_contents, pot_timer, capacity=3, cooking_time=30):
    """Unified pot cooking timer update using xp."""
    from cogrid.backend import xp

    # Handle empty pot array case
    n_pots = pot_contents.shape[0]
    # Note: for JAX, this if-check is fine because n_pots is a static shape dim,
    # not a traced value.

    n_items = xp.sum(pot_contents != -1, axis=1).astype(xp.int32)
    is_cooking = (n_items == capacity) & (pot_timer > 0)
    new_timer = xp.where(is_cooking, pot_timer - 1, pot_timer)
    pot_state = (n_items + n_items * new_timer).astype(xp.int32)
    return pot_contents, new_timer, pot_state
```

Key differences from numpy version: no `.copy()` (xp.where creates a new array). Key differences from JAX version: uses `xp` instead of `jnp`.

Delete `_overcooked_tick_handler()` and `overcooked_tick_jax()`.

**Unify the interaction body:**

Replace `_overcooked_interaction_handler()` (per-agent, uses int() casts) and `overcooked_interaction_body_jax()` (per-agent inside lax.fori_loop, uses jnp) with a single `overcooked_interaction_body()` that processes a single agent's interaction using xp and array_ops.

The new function signature should match what the unified `process_interactions()` needs -- it processes ONE agent at a time but uses xp operations instead of int() casts:

```python
def overcooked_interaction_body(
    i,                    # agent index
    agent_inv,            # (n_agents, 1) int32
    object_type_map,      # (H, W) int32
    object_state_map,     # (H, W) int32
    fwd_r, fwd_c,         # forward cell coordinates (scalar arrays, not Python ints)
    fwd_type,             # type at forward cell (scalar array)
    inv_item,             # inventory item (scalar array)
    base_ok,              # bool scalar -- is this agent interacting and no agent ahead
    pot_contents,         # (n_pots, 3) int32
    pot_timer,            # (n_pots,) int32
    pot_positions,        # (n_pots, 2) int32
    static_tables,        # dict of static lookup arrays
):
```

This function computes ALL branch conditions using xp.where cascading (same pattern as the JAX version) but uses `xp` instead of `jnp`, and `array_ops.set_at`/`set_at_2d` instead of `.at[].set()`. It returns the full updated state tuple.

The function must have zero `int()` casts. All comparisons use array operations:
- Replace `int(xp.sum(...))` with `xp.sum(...)` (keep as array scalar)
- Replace `int(pot_contents[pot_idx, s])` with array comparison `pot_contents[pot_idx, s] == -1`
- Replace `int(pot_timer[pot_idx])` with `pot_timer[pot_idx] == 0`
- Replace Python if/else chains with `xp.where` cascading

Delete helper functions that become unnecessary:
- `_place_on_pot()` -- logic folded into overcooked_interaction_body()
- `_place_on_delivery_zone()` -- logic folded into overcooked_interaction_body()
- `_overcooked_interaction_handler()` -- replaced by overcooked_interaction_body()
- `overcooked_interaction_body_jax()` -- replaced by overcooked_interaction_body()

**Update scope config builder:**

In `build_overcooked_scope_config()`, update the config dict to reference the new unified functions:
- `"tick_handler"` -> `overcooked_tick` (single function)
- `"interaction_body"` -> `overcooked_interaction_body` (single function)
- Remove `"tick_handler_jax"`, `"interaction_body_jax"` keys -- there's only one variant now
- Remove `"interaction_handler"` key (the per-agent handler pattern is replaced)

Keep `_build_static_tables()` as-is -- the init-time `int()` casts there are acceptable (they produce Python constants, not traced values).

Keep `_extract_overcooked_state()`, `_build_interaction_tables()`, `_build_type_ids()`, `build_overcooked_extra_state()` as-is -- they are init-time functions, not step-path.
  </action>
  <verify>
Run `python -c "
from cogrid.envs.overcooked.array_config import overcooked_tick, overcooked_interaction_body, build_overcooked_scope_config
print('imports OK')
config = build_overcooked_scope_config()
assert 'tick_handler' in config
assert 'interaction_body' in config
assert 'tick_handler_jax' not in config
assert 'interaction_body_jax' not in config
assert 'interaction_handler' not in config
print('scope config OK')
"` to verify the new API.

Verify no `int(` calls remain in overcooked_tick or overcooked_interaction_body: `grep -n 'int(' cogrid/envs/overcooked/array_config.py` should show only init-time code (_build_static_tables, _extract_overcooked_state), not the tick/interaction functions.

Verify deleted functions: `grep -c 'def _overcooked_tick_handler\|def overcooked_tick_jax\|def _overcooked_interaction_handler\|def overcooked_interaction_body_jax\|def _place_on_pot\|def _place_on_delivery_zone' cogrid/envs/overcooked/array_config.py` should return 0.
  </verify>
  <done>
  - overcooked_tick() replaces both _overcooked_tick_handler() and overcooked_tick_jax()
  - overcooked_interaction_body() replaces _overcooked_interaction_handler(), _place_on_pot(), _place_on_delivery_zone(), and overcooked_interaction_body_jax()
  - Scope config builder returns unified function references
  - Zero int() casts in tick/interaction body functions
  - All deleted functions are gone
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement unified process_interactions() with vectorized conflict resolution</name>
  <files>cogrid/core/interactions.py</files>
  <action>
Rewrite cogrid/core/interactions.py to contain a single `process_interactions()` function replacing both `process_interactions_array()` and `process_interactions_jax()`.

**New function signature:**

```python
def process_interactions(
    agent_pos,                # (n_agents, 2) int32
    agent_dir,                # (n_agents,) int32
    agent_inv,                # (n_agents, 1) int32, -1 = empty
    actions,                  # (n_agents,) int32
    object_type_map,          # (H, W) int32
    object_state_map,         # (H, W) int32
    lookup_tables,            # dict with CAN_PICKUP, CAN_OVERLAP, CAN_PLACE_ON, CAN_PICKUP_FROM
    scope_config,             # scope config dict
    dir_vec_table,            # (4, 2) int32
    action_pickup_drop_idx,   # int -- index of PickupDrop action
    action_toggle_idx,        # int -- index of Toggle action
    **extra_state,            # scope-specific state arrays
):
```

Return type: `(agent_inv, object_type_map, object_state_map, extra_state_dict)` -- same as the current numpy version.

**Implementation approach for 2 agents (Overcooked scope):**

The key challenge is that interactions modify shared grid state. For 2 agents, the approach is:

1. **Compute all agents' interaction conditions simultaneously:**
   ```python
   # Forward positions for ALL agents
   fwd_pos = agent_pos + dir_vec_table[agent_dir]  # (n_agents, 2)
   fwd_r = xp.clip(fwd_pos[:, 0], 0, H - 1)
   fwd_c = xp.clip(fwd_pos[:, 1], 0, W - 1)

   # Which agents are interacting
   is_interact = (actions == action_pickup_drop_idx)

   # Agent-ahead check for each agent (vectorized)
   # For each agent i, check if any OTHER agent is at fwd_pos[i]
   agent_ahead = xp.zeros(n_agents, dtype=xp.bool_)
   for each pair... actually, vectorize:
   fwd_matches_pos = xp.all(fwd_pos[:, None, :] == agent_pos[None, :, :], axis=2)
   # fwd_matches_pos[i,j] = True iff agent i's forward pos == agent j's position
   not_self = ~xp.eye(n_agents, dtype=xp.bool_)
   agent_ahead = xp.any(fwd_matches_pos & not_self, axis=1)

   base_ok = is_interact & ~agent_ahead
   ```

2. **Detect same-cell conflicts:**
   ```python
   # Check if two agents target the same forward cell
   same_fwd = xp.all(fwd_pos[:, None, :] == fwd_pos[None, :, :], axis=2)
   same_fwd = same_fwd & not_self
   has_same_fwd_conflict = xp.any(same_fwd, axis=1)
   ```

3. **Process non-conflicting agent first, then conflicting agent:**

   For the unified approach with scope config interaction body, call the scope config's `interaction_body` function per agent. Since we must avoid Python for-loops AND lax.fori_loop, but interactions modify shared state, use this pattern:

   **For 2 agents, unroll to exactly 2 calls.** Agent with lower index has priority (deterministic, matching existing behavior where the loop iterates i=0 then i=1):

   ```python
   interaction_body = scope_config.get("interaction_body") if scope_config else None

   # Get state for each agent
   fwd_type_0 = object_type_map[fwd_r[0], fwd_c[0]]
   inv_item_0 = agent_inv[0, 0]
   fwd_type_1 = object_type_map[fwd_r[1], fwd_c[1]]
   inv_item_1 = agent_inv[1, 0]

   if interaction_body is not None:
       # Process agent 0 first (lower index = higher priority)
       result = interaction_body(
           0, agent_inv, object_type_map, object_state_map,
           fwd_r[0], fwd_c[0], fwd_type_0, inv_item_0, base_ok[0],
           pot_contents, pot_timer, pot_positions, static_tables,
       )
       # Unpack result and conditionally apply (base_ok[0] is already checked inside)
       agent_inv, object_type_map, object_state_map, pot_contents, pot_timer = result

       # Re-read state for agent 1 (state may have changed)
       fwd_type_1 = object_type_map[fwd_r[1], fwd_c[1]]
       inv_item_1 = agent_inv[1, 0]

       # Process agent 1
       result = interaction_body(
           1, agent_inv, object_type_map, object_state_map,
           fwd_r[1], fwd_c[1], fwd_type_1, inv_item_1, base_ok[1],
           pot_contents, pot_timer, pot_positions, static_tables,
       )
       agent_inv, object_type_map, object_state_map, pot_contents, pot_timer = result
   else:
       # Generic scope: handle branches 1, 3, 4 without scope-specific handler
       # Same 2-agent unrolled pattern with generic xp.where logic
       ...process generic branches for agent 0, then agent 1...
   ```

   **IMPORTANT**: This is 2 sequential function calls, NOT a Python for-loop over a variable range. The number of calls is statically known (n_agents=2 for Overcooked). This is analogous to how the JAX path uses lax.fori_loop with static bounds -- except here we inline the 2 calls directly. For Overcooked scope (the only in-scope env), this is correct.

   **For generic scopes** (no interaction_body): implement the same 4-branch logic using xp.where cascading, processing agent 0 then agent 1.

4. **Delete old code:**
   - Delete `process_interactions_array()`
   - Delete `process_interactions_jax()` (and all its internal helpers: toggle_body, collision_body, etc.)
   - The toggle logic from the JAX path (`lax.switch` on type IDs) is Overcooked-irrelevant (Overcooked has no toggle types per scope config). For completeness, add a simple toggle pass if toggle branches exist in scope config, but for Overcooked this is a no-op.

5. **Return format:** Return `(agent_inv, object_type_map, object_state_map, extra_state_dict)` where extra_state_dict contains the updated pot arrays (matching the numpy variant's return format, not the JAX variant's flat tuple).

6. **Zero int() casts:** All the int() casts in the numpy path (7 in process_interactions_array) are eliminated by using array operations throughout. Forward positions are scalar arrays (xp.clip results), not Python ints.

**Update module docstring** to reflect single function.
  </action>
  <verify>
Run `python -c "from cogrid.core.interactions import process_interactions; print('import OK')"` to verify import succeeds.

Verify deleted functions: `grep -c 'def process_interactions_array\|def process_interactions_jax' cogrid/core/interactions.py` should return 0.

Verify zero `int(` in the function: `grep -n 'int(' cogrid/core/interactions.py` should show 0 results.

Verify no `lax.fori_loop` or `jax.lax` in interactions.py: `grep -c 'lax\.\|jax\.' cogrid/core/interactions.py` should return 0.
  </verify>
  <done>
  - cogrid/core/interactions.py contains a single process_interactions() function
  - process_interactions_array() and process_interactions_jax() are deleted
  - Interaction processing uses vectorized condition computation with xp.where cascading
  - For 2 agents, interactions are unrolled (2 sequential calls to interaction_body) -- no Python for-loop over variable range, no lax.fori_loop
  - Zero int() casts on array values
  - Returns (agent_inv, object_type_map, object_state_map, extra_state_dict)
  </done>
</task>

</tasks>

<verification>
1. `from cogrid.core.interactions import process_interactions` succeeds
2. `from cogrid.envs.overcooked.array_config import overcooked_tick, overcooked_interaction_body` succeeds
3. No `_array` or `_jax` function variants remain in either file
4. No `lax.fori_loop`, `lax.switch`, or `jax.lax` imports in interactions.py
5. No `int()` casts in the step-path functions
6. Scope config has unified function references (no `_jax` keys)
</verification>

<success_criteria>
- Single process_interactions() in cogrid/core/interactions.py
- Single overcooked_tick() and overcooked_interaction_body() in array_config.py
- All _array/_jax variants deleted
- Zero int() casts in step-path functions
- No JAX-specific imports (lax, jnp) in either file
- Scope config references unified functions only
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-algorithms/06-02-SUMMARY.md`
</output>

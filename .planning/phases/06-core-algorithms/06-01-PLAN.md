---
phase: 06-core-algorithms
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cogrid/core/movement.py
autonomous: true

must_haves:
  truths:
    - "A single move_agents() function replaces both move_agents_array() and move_agents_jax()"
    - "Collision resolution uses pairwise conflict detection and priority masking with pure xp array ops -- no Python for-loops, no lax.fori_loop"
    - "Swap detection uses vectorized cross-position comparison with xp -- no nested Python loops"
    - "move_agents() accepts a pre-computed priority array instead of an RNG object, keeping the function pure xp with zero backend branching"
    - "The function produces identical collision-resolution semantics on numpy and JAX backends for the same priority ordering"
  artifacts:
    - path: "cogrid/core/movement.py"
      provides: "Unified move_agents() with vectorized collision resolution"
      contains: "def move_agents("
  key_links:
    - from: "cogrid/core/movement.py"
      to: "cogrid/backend/xp"
      via: "xp import for all array operations"
      pattern: "from cogrid\\.backend import xp"
    - from: "cogrid/core/movement.py"
      to: "cogrid/backend/array_ops"
      via: "set_at for mutation"
      pattern: "from cogrid\\.backend\\.array_ops import"
---

<objective>
Unify move_agents_array() and move_agents_jax() into a single move_agents() function that uses pure xp array operations for collision resolution, swap detection, and movement computation.

Purpose: Movement is the most algorithmically complex function pair to unify -- it must replace both Python for-loops (numpy path) and lax.fori_loop (JAX path) with a single vectorized propose-filter-resolve pattern using only xp operations.

Output: cogrid/core/movement.py with a single move_agents() replacing both variants.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-core-algorithms/06-RESEARCH.md
@cogrid/core/movement.py
@cogrid/backend/array_ops.py
@cogrid/backend/_dispatch.py
@cogrid/core/agent.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement unified move_agents() with vectorized collision resolution</name>
  <files>cogrid/core/movement.py</files>
  <action>
Rewrite cogrid/core/movement.py to contain a single `move_agents()` function replacing both `move_agents_array()` and `move_agents_jax()`. The function signature changes:

```python
def move_agents(
    agent_pos,        # (n_agents, 2) int32
    agent_dir,        # (n_agents,) int32
    actions,          # (n_agents,) int32
    wall_map,         # (H, W) int32
    object_type_map,  # (H, W) int32
    can_overlap,      # (n_types,) int32
    priority,         # (n_agents,) int32 -- pre-computed priority ordering
    action_set,       # str -- "cardinal" or "rotation"
):
```

Key change: `rng` / `rng_key` parameter replaced by `priority` -- a pre-computed (n_agents,) array of agent indices in resolution order. The caller (step function) handles backend-specific RNG to produce this array.

Return type: `(new_pos, new_dir)` tuple on both backends (drop the third `new_rng_key` return from the JAX variant).

**Implementation steps:**

1. **Steps 1-5** (propose, bounds, wall, overlap, staying) -- These are already nearly identical between the two variants. Use `xp` throughout. Replace the lazy `_get_action_to_dir()` global with a local `action_to_dir = xp.array([3, 1, 2, 0, -1, -1, -1], dtype=xp.int32)` inside the function (no module-level mutable state). Do NOT use `.copy()` anywhere -- use `xp.where` patterns. Initialize `new_dir` as `agent_dir` (not `agent_dir.copy()`).

2. **Step 6: Vectorized collision resolution** (replaces the Python for-loop AND lax.fori_loop). For Overcooked's 2 agents, the algorithm is:

   a. Compute `proposed` positions for all agents (already done in steps 1-5).
   b. `staying = xp.all(proposed == agent_pos, axis=1)` -- agents whose proposed position equals their current position.
   c. Start with `final_pos = proposed` for staying agents, `agent_pos` for others -- actually, start with `final_pos = xp.where(staying[:, None], agent_pos, proposed)` to set staying agents immediately.
   d. For each priority position `k` in [0, n_agents), the agent at `priority[k]` resolves. Because n_agents is small (2-4) and known at Overcooked scope, unroll to 2 passes. But a general solution that works for any small n_agents:

   **Vectorized sequential resolution (unrolled for n_agents=2):**

   The core insight: with 2 agents, there's at most 1 conflict. Compute it all at once:

   ```python
   # Both agents have proposed positions (after wall/overlap filtering).
   # Detect same-target conflict:
   same_target = xp.all(proposed[0] == proposed[1])

   # Agent moving into the OTHER agent's current position while that agent stays:
   # Agent 0 wants agent 1's current pos and agent 1 is staying
   a0_into_a1_staying = xp.all(proposed[0] == agent_pos[1]) & staying[1]
   # Agent 1 wants agent 0's current pos and agent 0 is staying
   a1_into_a0_staying = xp.all(proposed[1] == agent_pos[0]) & staying[0]

   # Agent moving into OTHER agent's current pos (regardless of staying -- unresolved occupancy check)
   a0_into_a1_current = xp.all(proposed[0] == agent_pos[1]) & ~staying[0]
   a1_into_a0_current = xp.all(proposed[1] == agent_pos[0]) & ~staying[1]

   # Priority resolution: priority[0] is the winner index when conflict
   # Build a per-agent "blocked" mask:
   # For same_target: lower-priority agent is blocked
   # For into-staying-agent: the mover is blocked
   # For into-current-of-unresolved: the lower-priority mover is blocked

   # Start with proposed positions
   final_pos = proposed.copy() if using numpy -- NO. Use xp.array(proposed) or just work with where.

   # Resolution: an agent is blocked if:
   # (a) same_target AND they are the lower-priority agent, OR
   # (b) they're trying to move into a staying agent's position
   # For the 2-agent case:
   is_winner = xp.zeros(n_agents, dtype=xp.bool_)  # who wins the same-target conflict
   is_winner = set_at(is_winner, priority[0], True)  # first in priority wins

   blocked_same = same_target & ~is_winner & ~staying  # blocked from same-target
   blocked_staying = xp.zeros(n_agents, dtype=xp.bool_)
   # Agent 0 blocked by staying agent 1:
   # ...build per-agent blocked masks using xp.where
   ```

   Actually, implement the cleaner pairwise approach from the research. For n_agents agents:

   ```python
   # Pairwise same-proposed check: (n_agents, n_agents) bool
   same_proposed = xp.all(proposed[:, None, :] == proposed[None, :, :], axis=2)
   same_proposed = same_proposed & ~xp.eye(n_agents, dtype=xp.bool_)

   # Pairwise proposed-into-current check: proposed[i] == agent_pos[j]
   proposed_into_current = xp.all(proposed[:, None, :] == agent_pos[None, :, :], axis=2)
   proposed_into_current = proposed_into_current & ~xp.eye(n_agents, dtype=xp.bool_)

   # Build priority rank array: rank[i] = position of agent i in priority order
   rank = xp.zeros(n_agents, dtype=xp.int32)
   for k in range(n_agents):  # NO -- this is a Python loop. Use argsort:
   rank = xp.argsort(xp.argsort(priority))  # rank[agent_i] = priority position of agent i
   # Actually: priority is [winner_idx, loser_idx]. rank should give lower values to higher-priority agents.
   # If priority = [1, 0], then agent 1 has rank 0 (highest), agent 0 has rank 1.
   # rank = argsort(priority) gives the inverse permutation.
   # We need: rank[priority[k]] = k. That's the inverse permutation.
   # In numpy/jax: rank = xp.empty_like(priority); rank[priority] = xp.arange(n_agents)
   # But set_at is needed for JAX. Use:
   rank = xp.zeros(n_agents, dtype=xp.int32)
   # rank[priority] = arange(n_agents) -- this is a scatter. Use array_ops for JAX compat.
   # Or simpler: rank = xp.argsort(priority) -- NO, argsort(priority) gives sorted indices.
   # The inverse permutation of priority: rank[i] = "what position is agent i in?"
   # rank = xp.zeros(n_agents, dtype=xp.int32); rank = rank.at[priority].set(xp.arange(n_agents))
   # For numpy: rank[priority] = np.arange(n_agents). For JAX: rank = rank.at[priority].set(jnp.arange(n_agents)).
   # Use array_ops: build rank by scattering arange into priority indices.
   # Since array_ops.set_at only does scalar, build via xp trick:
   # Actually for 2 agents this is trivial. priority=[a, b] means rank[a]=0, rank[b]=1.
   # Use: rank = xp.argsort(xp.argsort(priority)) -- double argsort gives the rank.
   # This works for both numpy and JAX.
   ```

   **SIMPLIFY. For clarity (core value: simplicity), implement this algorithm:**

   ```python
   # 1. Start: final_pos = proposed (all agents get their proposed position)
   final_pos = proposed  # no copy needed -- we'll use xp.where to build result

   # 2. Blocked by same target: if two agents propose the same cell, lower-priority loses
   has_conflict = same_proposed  # (n_agents, n_agents)
   # For each agent, check if any higher-priority agent conflicts
   rank = xp.argsort(xp.argsort(priority))  # rank[i] = priority position of agent i (0=highest)
   higher_priority = rank[None, :] < rank[:, None]  # higher_priority[i,j] = True if j has higher priority than i
   blocked_by_higher = xp.any(has_conflict & higher_priority, axis=1)

   # 3. Blocked by stationary agent: if proposed[i] == agent_pos[j] and j is staying
   blocked_by_staying = xp.any(proposed_into_current & staying[None, :], axis=1)

   # 4. Blocked by unresolved agent's current position:
   # Agent i is blocked if proposed[i] == agent_pos[j] AND j is NOT staying AND j has lower priority
   # (meaning j hasn't resolved yet when i tries to move -- conservative: block the lower-priority one)
   # For 2 agents, this is: if I move into your current position and you're also moving,
   # the lower-priority one is blocked.
   lower_priority = rank[None, :] > rank[:, None]
   blocked_by_unresolved = xp.any(
       proposed_into_current & ~staying[None, :] & lower_priority, axis=1
   )

   # 5. Combined block mask
   blocked = (blocked_by_higher | blocked_by_staying | blocked_by_unresolved) & ~staying
   final_pos = xp.where(blocked[:, None], agent_pos, proposed)
   ```

   Then swap detection:

   ```python
   # 6. Swap detection (vectorized, already proven in JAX path)
   moved_to_old = xp.all(final_pos[:, None, :] == agent_pos[None, :, :], axis=2)
   swapped = moved_to_old & moved_to_old.T
   swapped = swapped & ~xp.eye(n_agents, dtype=xp.bool_)
   any_swap = xp.any(swapped, axis=1)
   final_pos = xp.where(any_swap[:, None], agent_pos, final_pos)
   ```

   **IMPORTANT**: The `blocked_by_unresolved` logic above needs careful validation. The existing numpy loop checks "if proposed[i] == agent_pos[j] where j is unresolved" (meaning j hasn't been processed yet). The lower-priority agent is processed later, so from its perspective, the higher-priority agent's current position is still "occupied" until the higher-priority agent resolves. The vectorized equivalent: agent i is blocked from moving to agent j's current position if j has higher priority (will resolve first and may move away, but conservatively block). Actually no -- the existing loop lets the higher-priority agent resolve first and then the lower-priority agent checks the final positions. In the vectorized version:

   - If agent i has LOWER priority than agent j, and proposed[i] == agent_pos[j], and j is NOT staying (j is trying to move): the existing loop would process j first (higher priority), j moves away, then i can move to j's old position. So i is NOT blocked.
   - If agent i has HIGHER priority than agent j, and proposed[i] == agent_pos[j], and j is NOT staying: the existing loop processes i first, i tries to move to j's current position. Since j is unresolved, j's current position is considered occupied. So i IS blocked.

   Corrected logic:
   ```python
   # Agent i is blocked if proposed[i] == agent_pos[j] where j has LOWER priority
   # (j hasn't resolved yet, j's current position is still "claimed")
   blocked_by_unresolved = xp.any(
       proposed_into_current & ~staying[None, :] & ~higher_priority & ~xp.eye(n_agents, dtype=xp.bool_),
       axis=1
   )
   # Note: ~higher_priority gives "same or lower priority". We need strictly lower.
   # lower_or_equal = rank[None, :] >= rank[:, None]... but we need just lower (not self).
   # The eye mask in proposed_into_current already handles self. So:
   # We want: proposed[i] == agent_pos[j], j not staying, j has lower priority (higher rank number) than i
   # Wait -- "lower priority" means resolved LATER. If priority = [1, 0], agent 1 resolves first (rank 0).
   # Agent with lower rank resolves FIRST. So "unresolved from i's perspective" means j has HIGHER rank than i.
   # If i has rank 0 (highest priority), j has rank 1 (lower priority = unresolved when i resolves).
   # i tries to move to j's current position. In the loop, i resolves first. j is unresolved.
   # The loop checks: "is j unresolved and at attempted position?" YES -> i is blocked.
   # So: i is blocked when proposed[i] == agent_pos[j] AND j is unresolved AND j has HIGHER rank (lower priority).

   blocked_by_unresolved = xp.any(
       proposed_into_current & ~staying[None, :] & (rank[None, :] > rank[:, None]),
       axis=1
   )
   ```

   This is correct. To match existing behavior: when agent i resolves (at its rank position), all agents with higher rank (lower priority) are still unresolved. If proposed[i] == agent_pos[j] where rank[j] > rank[i], then j is unresolved and i's move is blocked.

   **Testing**: After implementation, verify with the existing `test_movement_parity()` function. Modify it to pass a pre-computed priority array instead of an RNG. Also verify with the JAX `test_movement_jax()` test adapted for the new signature.

3. **Delete old code**: Remove `move_agents_array()`, `move_agents_jax()`, `test_movement_jax()`, the lazy `ACTION_TO_DIR` global, and `_get_action_to_dir()`. Keep `test_movement_parity()` but update it to call `move_agents()` with the new signature (pass `priority` from `rng.permutation(n_agents)`).

4. **Update module docstring** to reflect that the module now provides a single `move_agents()` function.

5. **Zero `int()` casts**: The unified function must have zero `int()` casts on array values. All values stay as array elements. The `action_set` string comparison is fine (it's a Python string, not an array value).
  </action>
  <verify>
Run `python -c "from cogrid.core.movement import move_agents; print('import OK')"` to verify import succeeds.

Run `python -c "
import numpy as np
from cogrid.backend import set_backend
set_backend('numpy')
from cogrid.core.movement import move_agents

# Quick smoke: 2 agents on 5x5 grid, no conflicts
agent_pos = np.array([[1,1],[3,3]], dtype=np.int32)
agent_dir = np.array([0, 2], dtype=np.int32)
actions = np.array([3, 2], dtype=np.int32)
wall_map = np.zeros((5,5), dtype=np.int32)
obj_map = np.zeros((5,5), dtype=np.int32)
can_overlap = np.ones(10, dtype=np.int32)
priority = np.array([0, 1], dtype=np.int32)

new_pos, new_dir = move_agents(agent_pos, agent_dir, actions, wall_map, obj_map, can_overlap, priority, 'cardinal')
assert new_pos.shape == (2,2)
assert new_dir.shape == (2,)
print('numpy smoke PASSED')
"` to verify numpy path.

Verify no `move_agents_array` or `move_agents_jax` function names remain: `grep -c 'def move_agents_array\|def move_agents_jax' cogrid/core/movement.py` should return 0.

Verify zero `int()` casts in the function: `grep -c 'int(' cogrid/core/movement.py` should show only occurrences in test code or type annotations, not in the move_agents function body.
  </verify>
  <done>
  - cogrid/core/movement.py contains a single `move_agents()` function with signature accepting `priority` array instead of RNG
  - Collision resolution is fully vectorized using pairwise conflict detection, priority masking, and xp.where -- no Python loops, no lax.fori_loop
  - Swap detection is vectorized using cross-position comparison matrix
  - `move_agents_array()` and `move_agents_jax()` are deleted
  - Zero `int()` casts on array values in the move_agents() function body
  - Returns `(new_pos, new_dir)` on both backends (no third rng_key return)
  </done>
</task>

</tasks>

<verification>
1. `from cogrid.core.movement import move_agents` succeeds
2. `move_agents` works on numpy backend with 2 agents
3. No functions named `move_agents_array` or `move_agents_jax` exist
4. No `lax.fori_loop` or `jax.lax` imports in movement.py
5. No Python for-loops in collision resolution or swap detection sections
</verification>

<success_criteria>
- A single move_agents() function exists in cogrid/core/movement.py
- Both move_agents_array() and move_agents_jax() are deleted
- Collision resolution uses vectorized pairwise conflict detection with xp
- Swap detection uses vectorized cross-position comparison with xp
- Zero int() casts in the function body
- Function accepts pre-computed priority array, not RNG
- Returns (new_pos, new_dir) tuple
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-algorithms/06-01-SUMMARY.md`
</output>

---
phase: 01.1-fix-environment-separation-of-concerns
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cogrid/core/scope_config.py
  - cogrid/envs/overcooked/array_config.py
  - cogrid/envs/overcooked/__init__.py
autonomous: true

must_haves:
  truths:
    - "A scope config registry exists that environments can register configurations with"
    - "Overcooked registers its interaction tables builder, type_ids builder, and state extractor via the scope config registry"
    - "Calling get_scope_config('overcooked') returns a dict with interaction_tables, type_ids, and state_extractor keys"
    - "Calling get_scope_config for an unregistered scope returns a default empty config without error"
  artifacts:
    - path: "cogrid/core/scope_config.py"
      provides: "Scope config registry with register_scope_config(), get_scope_config(), default_scope_config()"
      contains: "SCOPE_CONFIG_REGISTRY"
    - path: "cogrid/envs/overcooked/array_config.py"
      provides: "Overcooked-specific interaction tables, type_ids, state extraction, tick handler, and interaction handlers"
      contains: "build_overcooked_interaction_tables"
    - path: "cogrid/envs/overcooked/__init__.py"
      provides: "Auto-registration of overcooked scope config at import time"
      contains: "register_scope_config"
  key_links:
    - from: "cogrid/envs/overcooked/__init__.py"
      to: "cogrid/core/scope_config.py"
      via: "register_scope_config() call at import time"
      pattern: "register_scope_config.*overcooked"
    - from: "cogrid/envs/overcooked/array_config.py"
      to: "cogrid/core/grid_object.py"
      via: "object_to_idx() and get_object_names() calls"
      pattern: "object_to_idx.*scope"
---

<objective>
Create the scope config registry infrastructure and the Overcooked scope config module that provides all environment-specific array configuration (interaction tables, type IDs, state extractors, interaction handlers, tick handlers).

Purpose: Establish the registry pattern that allows environment-specific array logic to live in `cogrid/envs/` while being consumed by generic core modules. This is the foundation that Plan 03 wires into `cogrid_env.py` and `core/interactions.py`.

Output: `cogrid/core/scope_config.py` (registry), `cogrid/envs/overcooked/array_config.py` (Overcooked config builder), updated `cogrid/envs/overcooked/__init__.py` (auto-registration).
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-fix-environment-separation-of-concerns-no-environment-specific-logic-in-core-methods/01.1-RESEARCH.md
@cogrid/core/interactions.py
@cogrid/core/grid_object.py
@cogrid/envs/overcooked/__init__.py
@cogrid/envs/overcooked/overcooked_grid_objects.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scope config registry and Overcooked array config</name>
  <files>
    cogrid/core/scope_config.py
    cogrid/envs/overcooked/array_config.py
    cogrid/envs/overcooked/__init__.py
  </files>
  <action>
Create `cogrid/core/scope_config.py` with:
- Module-level `SCOPE_CONFIG_REGISTRY = {}` dict.
- `register_scope_config(scope: str, config_builder: callable)` -- stores `config_builder` in registry keyed by `scope`.
- `get_scope_config(scope: str) -> dict` -- calls `SCOPE_CONFIG_REGISTRY[scope]()` if registered, else returns `default_scope_config()`.
- `default_scope_config() -> dict` -- returns `{"interaction_tables": None, "type_ids": {}, "state_extractor": None, "interaction_handler": None, "tick_handler": None, "place_on_handlers": {}}`.

The config dict structure:
```python
{
    "interaction_tables": dict | None,  # from build_interaction_tables (pickup_from_produces, legal_pot_ingredients, type_ids)
    "type_ids": dict,                   # name -> int mapping
    "state_extractor": callable | None, # fn(grid, scope) -> dict of extra state arrays (pot_contents, pot_timer, pot_positions)
    "interaction_handler": callable | None,  # fn(process_interactions_array args) for scope-specific interaction sub-cases
    "tick_handler": callable | None,    # fn(state_arrays) -> updated state_arrays
    "place_on_handlers": dict,          # fwd_type -> handler_fn for scope-specific place_on behavior
}
```

Create `cogrid/envs/overcooked/array_config.py` with:
- `build_overcooked_scope_config() -> dict` -- the config builder function that returns a fully populated config dict.
- Move the ENTIRE body of `cogrid/core/interactions.py::build_interaction_tables()` here as `_build_interaction_tables(scope)`. Keep the same logic verbatim (onion_id, tomato_id, plate_id, pot_id lookups + pickup_from_produces + legal_pot_ingredients arrays).
- `_build_type_ids(scope) -> dict` -- move the logic from `CoGridEnv._build_type_ids()` here. Takes scope, uses `get_object_names(scope)` and `object_to_idx(name, scope)`. Contains the hardcoded list `['pot', 'onion', 'tomato', 'plate', 'onion_soup', 'tomato_soup', 'onion_stack', 'tomato_stack', 'plate_stack', 'counter', 'delivery_zone']`. Returns dict with -1 for missing types.
- `_extract_overcooked_state(grid, scope) -> dict` -- move the pot-specific state extraction from `layout_to_array_state()` here. Given a Grid object, iterate cells, find pots (`cell.object_id == "pot"`), extract pot_positions, pot_contents, pot_timer arrays. Return `{"pot_positions": list, "pot_contents": ndarray, "pot_timer": ndarray}`.
- `_overcooked_tick_handler(pot_contents, pot_timer, **kwargs)` -- move the body of `tick_objects_array()` here verbatim. Return same (pot_contents, pot_timer, pot_state) tuple.
- `_place_on_pot(agent_inv, agent_idx, inv_item, pot_contents, pot_timer, pot_idx, legal_pot_ingredients, cooking_time)` -- move from `core/interactions.py` verbatim.
- `_place_on_delivery_zone(agent_inv, agent_idx, inv_item, type_ids)` -- extract the delivery zone logic from `_place_on_non_pot()`. Only accepts soup (onion_soup or tomato_soup). Consumes soup from inventory.
- `_overcooked_interaction_handler(action_type, agent_idx, agent_inv, fwd_r, fwd_c, fwd_type, inv_item, object_type_map, object_state_map, extra_state)` -- a function that handles the Overcooked-specific parts of `process_interactions_array()`. The `action_type` parameter is a string, either `"pickup_from"` or `"place_on"`, indicating which priority branch is delegating. The remaining arguments provide all context needed. Specifically handles: (a) dynamic can_pickup_from condition for pots (dish_ready AND has plate), (b) pot pickup-from: soup type determination and plate consumption, (c) pot place-on via `_place_on_pot`, (d) delivery zone place-on via `_place_on_delivery_zone`. This function will be called by the refactored generic `process_interactions_array` in Plan 03.

The `build_overcooked_scope_config()` function assembles all of the above:
```python
def build_overcooked_scope_config():
    scope = "overcooked"
    itables = _build_interaction_tables(scope)
    type_ids = _build_type_ids(scope)
    return {
        "interaction_tables": itables,
        "type_ids": type_ids,
        "state_extractor": _extract_overcooked_state,
        "interaction_handler": _overcooked_interaction_handler,
        "tick_handler": _overcooked_tick_handler,
        "place_on_handlers": {},  # handled inside interaction_handler
    }
```

Update `cogrid/envs/overcooked/__init__.py` to add auto-registration:
```python
from cogrid.core.scope_config import register_scope_config
from cogrid.envs.overcooked.array_config import build_overcooked_scope_config
register_scope_config("overcooked", build_overcooked_scope_config)
```

IMPORTANT: Do NOT yet modify `cogrid/core/interactions.py` or `cogrid/cogrid_env.py`. Those are Plan 03's job. This plan only CREATES the new files and adds the registration. The existing contaminated code continues to work unchanged.

IMPORTANT: Import `xp` from `cogrid.backend` inside functions (not at module level) to avoid import-time backend dependency, matching the pattern used throughout the codebase.
  </action>
  <verify>
Run: `python -c "import cogrid.envs; from cogrid.core.scope_config import get_scope_config; cfg = get_scope_config('overcooked'); print('type_ids:', list(cfg['type_ids'].keys())); print('interaction_tables:', list(cfg['interaction_tables'].keys())); print('has state_extractor:', cfg['state_extractor'] is not None); print('has interaction_handler:', cfg['interaction_handler'] is not None); print('has tick_handler:', cfg['tick_handler'] is not None)"`

Expected output should show all keys populated for overcooked scope.

Also verify default config: `python -c "from cogrid.core.scope_config import get_scope_config; cfg = get_scope_config('search_rescue'); print('interaction_tables:', cfg['interaction_tables']); print('type_ids:', cfg['type_ids']); print('tick_handler:', cfg['tick_handler'])"`

Expected: interaction_tables=None, type_ids={}, tick_handler=None.

Also verify tick_handler parity:
```python
python -c "
import numpy as np
import cogrid.envs
from cogrid.core.scope_config import get_scope_config
from cogrid.core.interactions import tick_objects_array
cfg = get_scope_config('overcooked')

# Full pot test
pc = np.array([[3, 3, 3]], dtype=np.int32)  # 3 onions (type_id=3)
pt = np.array([30], dtype=np.int32)

_, pt_old, ps_old = tick_objects_array(pc.copy(), pt.copy())
_, pt_new, ps_new = cfg['tick_handler'](pc.copy(), pt.copy())
assert int(pt_old[0]) == int(pt_new[0]), f'Timer mismatch: {pt_old[0]} vs {pt_new[0]}'
assert int(ps_old[0]) == int(ps_new[0]), f'State mismatch: {ps_old[0]} vs {ps_new[0]}'
print('Tick handler parity: PASSED')
"
```
  </verify>
  <done>
`cogrid/core/scope_config.py` exists with SCOPE_CONFIG_REGISTRY, register_scope_config(), get_scope_config(), default_scope_config(). `cogrid/envs/overcooked/array_config.py` exists with all Overcooked-specific config builders moved from core modules. Overcooked scope auto-registers at import time. Default config returned for unregistered scopes. Tick handler produces identical output to existing tick_objects_array.
  </done>
</task>

</tasks>

<verification>
1. `python -c "import cogrid.envs; from cogrid.core.scope_config import get_scope_config; cfg = get_scope_config('overcooked'); assert cfg['interaction_tables'] is not None; assert len(cfg['type_ids']) == 11; assert cfg['state_extractor'] is not None; print('PASS')"` -- overcooked config fully populated
2. `python -c "from cogrid.core.scope_config import get_scope_config; cfg = get_scope_config('nonexistent'); assert cfg['interaction_tables'] is None; assert cfg['type_ids'] == {}; print('PASS')"` -- default config for unknown scopes
3. Existing tests still pass: `python -m pytest cogrid/ -x -q --tb=short 2>&1 | tail -5` -- no regressions
</verification>

<success_criteria>
- Scope config registry exists and is functional
- Overcooked scope auto-registers at import time via `__init__.py`
- All Overcooked-specific logic is duplicated (not yet removed) in `array_config.py`
- Default scope config returned for non-Overcooked scopes
- No changes to existing core files (those come in Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-fix-environment-separation-of-concerns-no-environment-specific-logic-in-core-methods/01.1-01-SUMMARY.md`
</output>

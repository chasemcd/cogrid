---
phase: 01.1-fix-environment-separation-of-concerns
plan: 03
type: execute
wave: 2
depends_on: ["01.1-01", "01.1-02"]
files_modified:
  - cogrid/cogrid_env.py
  - cogrid/core/interactions.py
  - cogrid/core/grid_utils.py
  - cogrid/core/array_rewards.py
autonomous: true

must_haves:
  truths:
    - "cogrid/cogrid_env.py contains zero occurrences of the string 'overcooked' (case-insensitive grep excluding comments)"
    - "cogrid/core/interactions.py contains zero Overcooked-specific type names (pot, onion, tomato, soup, delivery_zone)"
    - "cogrid/core/grid_utils.py contains no 'pot' string references or object_id checks"
    - "cogrid/core/array_rewards.py contains only compose_rewards() and no Overcooked reward functions"
    - "All existing parity tests pass: movement, interactions, features"
    - "Overcooked environments work identically (200-step smoke test passes)"
    - "Non-Overcooked scopes (search_rescue, goal_seeking) do not error on instantiation"
  artifacts:
    - path: "cogrid/cogrid_env.py"
      provides: "Generic env using scope config instead of hardcoded scope checks"
      contains: "get_scope_config"
    - path: "cogrid/core/interactions.py"
      provides: "Generic interaction skeleton with scope config hooks"
      contains: "scope_config"
    - path: "cogrid/core/grid_utils.py"
      provides: "Generic layout_to_array_state using scope config state_extractor"
      contains: "state_extractor"
  key_links:
    - from: "cogrid/cogrid_env.py"
      to: "cogrid/core/scope_config.py"
      via: "get_scope_config() call in __init__"
      pattern: "get_scope_config.*self\\.scope"
    - from: "cogrid/core/interactions.py"
      to: "scope_config dict"
      via: "scope_config parameter threaded through process_interactions_array"
      pattern: "scope_config"
    - from: "cogrid/core/grid_utils.py"
      to: "scope_config dict"
      via: "state_extractor callback from scope config"
      pattern: "state_extractor"
---

<objective>
Wire the scope config (from Plan 01) into `cogrid_env.py`, `core/interactions.py`, and `core/grid_utils.py`, replacing all hardcoded Overcooked-specific logic in core modules with generic scope-config-driven dispatch. Remove backward-compatible re-exports from `core/array_rewards.py`.

Purpose: This is the final cleanup that achieves the phase goal: zero environment-specific logic in core methods. After this plan, core modules contain only generic infrastructure, and all Overcooked-specific array logic lives in `cogrid/envs/overcooked/`.

Output: Cleaned core modules, scope-config-driven dispatch in env and interactions.
</objective>

<execution_context>
@/Users/chasemcd/.claude/get-shit-done/workflows/execute-plan.md
@/Users/chasemcd/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.1-fix-environment-separation-of-concerns-no-environment-specific-logic-in-core-methods/01.1-RESEARCH.md
@.planning/phases/01.1-fix-environment-separation-of-concerns-no-environment-specific-logic-in-core-methods/01.1-01-SUMMARY.md
@.planning/phases/01.1-fix-environment-separation-of-concerns-no-environment-specific-logic-in-core-methods/01.1-02-SUMMARY.md
@cogrid/cogrid_env.py
@cogrid/core/interactions.py
@cogrid/core/grid_utils.py
@cogrid/core/array_rewards.py
@cogrid/core/scope_config.py
@cogrid/envs/overcooked/array_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire scope config into cogrid_env.py, removing all Overcooked references</name>
  <files>
    cogrid/cogrid_env.py
  </files>
  <action>
Replace the three contaminated sections in `CoGridEnv.__init__()`:

**Section 1: Replace `_build_type_ids()` call and method (lines 206, 220-238)**

Delete the `_build_type_ids()` method entirely. Replace its call with scope config:
```python
from cogrid.core.scope_config import get_scope_config
self._scope_config = get_scope_config(self.scope)
self._type_ids = self._scope_config["type_ids"]
```

**Section 2: Replace interaction tables conditional (lines 208-212)**

Delete the `if self.scope == "overcooked":` block. Replace with:
```python
self._interaction_tables = self._scope_config["interaction_tables"]
```

This works because `get_scope_config()` returns `{"interaction_tables": None, ...}` for non-Overcooked scopes, preserving the exact same `None` fallback.

**Section 3: Update `_sync_array_state_from_objects()` (around line 560)**

The current implementation calls `layout_to_array_state(self.grid, scope=self.scope)`. After Plan 01, `layout_to_array_state` will accept an optional `scope_config` parameter. Pass `self._scope_config` so pot-specific extraction is handled by the Overcooked config's state_extractor:

```python
self._array_state = layout_to_array_state(self.grid, scope=self.scope, scope_config=self._scope_config)
```

Do the same for the `reset()` call to `layout_to_array_state` (around line 379).

**What NOT to change:**
- The `self._lookup_tables = build_lookup_tables(scope=self.scope)` line stays as-is -- `build_lookup_tables` is already generic (scope-aware via OBJECT_REGISTRY).
- The vectorized movement code stays as-is -- it's already generic.
- The `import` for `build_interaction_tables` from `cogrid.core.interactions` can be removed since we no longer call it directly.

After changes, verify that `cogrid_env.py` contains ZERO references to the string "overcooked" in non-comment code. The `self.scope` variable may equal "overcooked" at runtime, but the code must never check for that value.
  </action>
  <verify>
1. Grep for Overcooked contamination in cogrid_env.py:
```bash
grep -n "overcooked" cogrid/cogrid_env.py | grep -v "^#" | grep -v "# "
```
Expected: zero matches (only comments allowed, and ideally none).

2. Run 200-step smoke test:
```bash
python -c "
import cogrid.envs
from cogrid.envs.overcooked.overcooked import Overcooked
config = {'name': 'overcooked', 'num_agents': 2, 'action_set': 'cardinal_actions', 'features': 'overcooked_features', 'rewards': ['delivery_reward'], 'grid': {'layout': 'overcooked_cramped_room_v0'}, 'max_steps': 200, 'scope': 'overcooked'}
env = Overcooked(config=config, backend='numpy')
obs, _ = env.reset(seed=42)
for _ in range(200):
    env.step({a: env.action_space(a).sample() for a in env.agents})
print('200-step smoke test: PASSED')
"
```

3. Verify `_build_type_ids` method no longer exists:
```bash
python -c "from cogrid.cogrid_env import CoGridEnv; assert not hasattr(CoGridEnv, '_build_type_ids'), 'Should be removed'; print('_build_type_ids removed: OK')"
```
  </verify>
  <done>
`cogrid_env.py` uses `get_scope_config()` for type_ids, interaction_tables, and state extraction. No `if self.scope == "overcooked"` guards remain. `_build_type_ids()` method deleted. 200-step Overcooked smoke test passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor core/interactions.py to generic skeleton, clean grid_utils.py and array_rewards.py</name>
  <files>
    cogrid/core/interactions.py
    cogrid/core/grid_utils.py
    cogrid/core/array_rewards.py
  </files>
  <action>
**Part A: Refactor `cogrid/core/interactions.py`**

The goal is to make `process_interactions_array()` a generic skeleton that delegates environment-specific logic to the scope config. The generic parts (priority chain, forward position computation, bounds check, agent-ahead, simple pickup, drop on empty) stay. The Overcooked-specific parts (pot dynamic can_pickup_from, pot pickup-from, pot place-on, delivery zone) are delegated to the scope config's `interaction_handler`.

1. **Remove `build_interaction_tables()`** (lines 23-81). This is now in `cogrid/envs/overcooked/array_config.py`. The function is only called by cogrid_env.py which now gets it from scope_config.

2. **Refactor `process_interactions_array()`** to accept a `scope_config` parameter instead of `type_ids`, `pickup_from_produces`, `legal_pot_ingredients`:

New signature:
```python
def process_interactions_array(
    agent_pos,                # (n_agents, 2) int32
    agent_dir,                # (n_agents,) int32
    agent_inv,                # (n_agents, 1) int32, -1 = empty
    actions,                  # (n_agents,) int32
    object_type_map,          # (H, W) int32
    object_state_map,         # (H, W) int32
    lookup_tables,            # dict with CAN_PICKUP, CAN_OVERLAP, CAN_PLACE_ON, CAN_PICKUP_FROM
    scope_config,             # scope config dict from get_scope_config()
    dir_vec_table,            # (4, 2) int32 -- direction vectors
    action_pickup_drop_idx,   # int -- index of PickupDrop action
    action_toggle_idx,        # int -- index of Toggle action
    # Scope-specific state arrays passed as kwargs:
    **extra_state,            # e.g., pot_contents, pot_timer, pot_positions for Overcooked
):
```

The function body retains the generic structure:
- Copy arrays (agent_inv, object_type_map, object_state_map)
- Extract CAN_PICKUP, CAN_PICKUP_FROM, CAN_PLACE_ON from lookup_tables
- Loop over agents
- Skip non-interaction actions
- Compute forward position, bounds check, agent-ahead check
- **Priority branch 1 (pickup):** Generic -- stays exactly as-is. `CAN_PICKUP[fwd_type]` lookup + empty inventory check.
- **Priority branch 2 (pickup_from):** The dynamic condition evaluation and the pickup-from action are delegated to `scope_config["interaction_handler"]` if one exists. If no interaction_handler, fall through to branch 3. The interaction_handler receives all the context it needs (agent_inv, agent_idx, fwd_r, fwd_c, fwd_type, object_type_map, object_state_map, CAN_PICKUP_FROM, extra_state) and returns a boolean indicating if it handled the interaction.
- **Priority branch 3 (drop on empty):** Generic -- stays exactly as-is.
- **Priority branch 4 (place_on):** The CAN_PLACE_ON lookup is generic. If CAN_PLACE_ON and agent has item, delegate to `scope_config["interaction_handler"]` for scope-specific place_on behavior. If no handler, do generic place_on (store in object_state_map if empty, matching the current `else` branch of `_place_on_non_pot`).

The key design: the `interaction_handler` from scope_config is called with a structured context dict for each agent's interaction attempt. It returns updated arrays. The generic skeleton handles the priority chain and common cases (simple pickup, drop on empty).

Specifically, refactor the per-agent loop body to:
```python
# After computing fwd_pos, fwd_type, inv_item, agent_ahead check...

# Priority 1: simple pickup (GENERIC)
if fwd_type > 0 and CAN_PICKUP[fwd_type] == 1 and inv_item == -1:
    agent_inv[i, 0] = fwd_type
    object_type_map[fwd_r, fwd_c] = 0
    object_state_map[fwd_r, fwd_c] = 0

# Priority 2: pickup_from (DELEGATED if handler exists)
elif fwd_type > 0 and CAN_PICKUP_FROM[fwd_type] == 1:
    if interaction_handler is not None:
        interaction_handler(
            "pickup_from", i, agent_inv, fwd_r, fwd_c, fwd_type,
            inv_item, object_type_map, object_state_map, extra_state,
        )
    # No handler: skip (nothing generic to do for pickup_from)

# Priority 3: drop on empty (GENERIC)
elif fwd_type == 0 and inv_item != -1:
    object_type_map[fwd_r, fwd_c] = inv_item
    object_state_map[fwd_r, fwd_c] = 0
    agent_inv[i, 0] = -1

# Priority 4: place_on (GENERIC structure, DELEGATED specifics)
elif fwd_type > 0 and CAN_PLACE_ON[fwd_type] == 1 and inv_item != -1:
    if interaction_handler is not None:
        interaction_handler(
            "place_on", i, agent_inv, fwd_r, fwd_c, fwd_type,
            inv_item, object_type_map, object_state_map, extra_state,
        )
    else:
        # Generic place_on: store in object_state_map if empty
        if int(object_state_map[fwd_r, fwd_c]) == 0:
            object_state_map[fwd_r, fwd_c] = inv_item
            agent_inv[i, 0] = -1
```

Return value: `(agent_inv, object_type_map, object_state_map, extra_state)` -- return extra_state so the caller gets back updated pot arrays etc.

3. **Remove `_place_on_pot()`** (lines 293-333). Moved to `cogrid/envs/overcooked/array_config.py` in Plan 01.

4. **Remove `_place_on_non_pot()`** (lines 336-368). The generic part (counter: store in object_state_map if empty) is now inline in the generic `else` branch of priority 4. The Overcooked-specific parts (delivery zone soup acceptance) are in the Overcooked interaction_handler.

5. **Refactor `tick_objects_array()`** to become a simple pass-through that calls the scope config's tick_handler:
```python
def tick_objects_array(scope_config, **state_arrays):
    """Tick objects using scope-specific handler.

    If no tick_handler in scope_config, returns state_arrays unchanged.
    """
    tick_handler = scope_config.get("tick_handler") if scope_config else None
    if tick_handler is not None:
        return tick_handler(**state_arrays)
    return state_arrays
```

Actually, SIMPLER: just remove `tick_objects_array()` from core entirely. The caller (`cogrid_env.py`) can call `scope_config["tick_handler"]` directly if it's not None. This avoids an unnecessary indirection layer.

DECISION: Keep `tick_objects_array()` as a thin generic dispatcher for backward compat (the test in Plan 02 imports it). But make it accept scope_config and delegate:
```python
def tick_objects_array(scope_config=None, **kwargs):
    """Dispatch tick to scope-specific handler. Returns kwargs unchanged if no handler."""
    if scope_config and scope_config.get("tick_handler"):
        return scope_config["tick_handler"](**kwargs)
    # No-op: return inputs unchanged
    return kwargs
```

Wait -- the existing signature takes positional args (pot_contents, pot_timer, capacity, cooking_time). For backward compat with the moved test, keep the old signature but also accept scope_config. Actually, the test was moved to `cogrid/envs/overcooked/test_interactions.py` which can import directly from `cogrid/envs/overcooked/array_config.py`. So we can freely change the core signature.

FINAL DECISION: Remove `tick_objects_array()` from `cogrid/core/interactions.py` entirely. It was Overcooked-specific (pot cooking timer). The Overcooked tick handler lives in `array_config.py`. The cogrid_env.py step loop will call `self._scope_config["tick_handler"]()` directly if not None.

Update the `test_interactions.py` import in `cogrid/envs/overcooked/` to import from `array_config` instead of `core.interactions`.

**Part B: Clean `cogrid/core/grid_utils.py`**

In `layout_to_array_state()`:

1. Add an optional `scope_config=None` parameter.
2. Remove the pot-specific detection block (lines 72-74: `if cell.object_id == "pot": pot_positions.append(...); pots.append(cell)`).
3. Remove the pot array construction block (lines 77-91).
4. Instead, after the grid loop, if `scope_config` has a `state_extractor`, call it:
```python
# Extract scope-specific container state (e.g., pot arrays for Overcooked)
state_extractor = scope_config.get("state_extractor") if scope_config else None
if state_extractor:
    extra_state = state_extractor(grid, scope)
    result.update(extra_state)
```

This way, the generic `layout_to_array_state()` never mentions pots. The Overcooked state_extractor handles pot detection and array construction.

The return dict still contains `object_type_map`, `object_state_map`, `wall_map`, `spawn_points`. Pot-specific keys (`pot_positions`, `pot_contents`, `pot_timer`) are only present when the scope config provides a state_extractor that returns them.

Also update `grid_to_array_state()` to accept and pass through `scope_config`.

**Part C: Clean `cogrid/core/array_rewards.py`**

Remove the backward-compatible re-exports added in Plan 02:
```python
# Remove these lines:
from cogrid.envs.overcooked.array_rewards import (
    delivery_reward_array,
    onion_in_pot_reward_array,
    soup_in_dish_reward_array,
)
```

After removal, `core/array_rewards.py` should contain ONLY:
- Module docstring (updated to describe generic compose_rewards utility)
- `compose_rewards()` function
- Nothing else

**Part D: Update moved test**

In `cogrid/envs/overcooked/test_interactions.py`, update the import of `tick_objects_array` to import from `cogrid.envs.overcooked.array_config` (the `_overcooked_tick_handler` function) instead of `cogrid.core.interactions`. The test should use the Overcooked-specific tick handler directly since it's testing Overcooked behavior.

CRITICAL PARITY REQUIREMENT: After all changes, the 200-step Overcooked smoke test MUST pass. The refactored `process_interactions_array()` must produce identical results to the original. Run parity tests after each file change.
  </action>
  <verify>
1. **Zero Overcooked contamination in core:**
```bash
# Check cogrid_env.py
grep -in "overcooked" cogrid/cogrid_env.py | grep -v "#" | head -20

# Check core/interactions.py for Overcooked type names
grep -in "pot\|onion\|tomato\|soup\|delivery_zone\|overcooked" cogrid/core/interactions.py | grep -v "#" | head -20

# Check core/grid_utils.py for pot references
grep -in "pot\|overcooked" cogrid/core/grid_utils.py | grep -v "#" | head -20

# Check core/array_rewards.py is clean
wc -l cogrid/core/array_rewards.py  # Should be ~30-40 lines (just compose_rewards)
grep -c "def " cogrid/core/array_rewards.py  # Should be 1 (compose_rewards only)
```

2. **Overcooked 200-step smoke test:**
```bash
python -c "
import cogrid.envs
from cogrid.envs.overcooked.overcooked import Overcooked
config = {'name': 'overcooked', 'num_agents': 2, 'action_set': 'cardinal_actions', 'features': 'overcooked_features', 'rewards': ['delivery_reward'], 'grid': {'layout': 'overcooked_cramped_room_v0'}, 'max_steps': 200, 'scope': 'overcooked'}
env = Overcooked(config=config, backend='numpy')
obs, _ = env.reset(seed=42)
for _ in range(200):
    env.step({a: env.action_space(a).sample() for a in env.agents})
print('200-step smoke test: PASSED')
"
```

3. **Overcooked parity test from new location:**
```bash
python -c "from cogrid.envs.overcooked.test_interactions import test_interaction_parity; test_interaction_parity()"
```

4. **Non-Overcooked scope doesn't error:**
```bash
python -c "
from cogrid.core.scope_config import get_scope_config
cfg = get_scope_config('search_rescue')
assert cfg['interaction_tables'] is None
assert cfg['type_ids'] == {}
print('Non-Overcooked scope: OK')
"
```

5. **Full test suite:** `python -m pytest cogrid/ -x -q --tb=short 2>&1 | tail -10`
  </verify>
  <done>
All Overcooked-specific logic removed from `cogrid/cogrid_env.py`, `cogrid/core/interactions.py`, `cogrid/core/grid_utils.py`, and `cogrid/core/array_rewards.py`. Core modules contain only generic infrastructure. `process_interactions_array()` delegates environment-specific behavior via scope config interaction_handler. `layout_to_array_state()` delegates container state extraction via scope config state_extractor. `compose_rewards()` is the only function in `core/array_rewards.py`. All parity tests pass. 200-step Overcooked smoke test passes.
  </done>
</task>

</tasks>

<verification>
1. **Contamination audit (CRITICAL):**
   - `grep -rn "overcooked" cogrid/cogrid_env.py cogrid/core/interactions.py cogrid/core/grid_utils.py cogrid/core/array_rewards.py | grep -v "^.*:#"` -- ZERO matches expected
   - `grep -rn "'pot'\|\"pot\"\|pot_id\|onion_id\|tomato_id\|soup_id\|delivery_zone_id" cogrid/core/interactions.py cogrid/core/grid_utils.py` -- ZERO matches expected
2. **Functional parity:** Overcooked 200-step smoke test passes
3. **Parity tests:** `test_interaction_parity()` passes from new location
4. **Non-Overcooked scopes:** get_scope_config for unregistered scopes returns safe defaults
5. **Test suite:** `python -m pytest cogrid/ -x -q` passes (same pass/fail pattern as before)
</verification>

<success_criteria>
- ZERO environment-specific logic in cogrid/core/ and cogrid/cogrid_env.py
- All Overcooked array logic lives exclusively in cogrid/envs/overcooked/
- Core modules provide generic infrastructure consumed by scope configs
- Overcooked environments produce identical behavior (parity preserved)
- Non-Overcooked scopes work with default (empty) scope config
- Phase 01.1 goal achieved: no environment-specific logic in core methods
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-fix-environment-separation-of-concerns-no-environment-specific-logic-in-core-methods/01.1-03-SUMMARY.md`
</output>

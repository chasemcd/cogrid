{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#cogrid","title":"CoGrid","text":"<p>CoGrid is a library for creating grid-based multi-agent environments for reinforcement learning research. It provides a functional, array-based simulation core that operates identically on NumPy and JAX backends.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Multi-agent support -- multiple agents with independent observation and action spaces via the PettingZoo ParallelEnv interface</li> <li>Pluggable component API -- rewards, features, and objects are registered via <code>@register_reward_type</code>, <code>@register_feature_type</code>, and <code>@register_object_type</code> classmethods (<code>build_tick_fn</code>, <code>build_interaction_fn</code>, <code>build_render_sync_fn</code>, etc.)</li> <li>JAX backend -- JIT compilation and <code>vmap</code> batching for high-throughput simulation</li> <li>PettingZoo ParallelEnv interface -- standard multi-agent API compatible with existing RL libraries</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from cogrid.envs import registry\n\nenv = registry.make(\"SearchRescue-8x8-2Agent-V0\")\nobservations, infos = env.reset(seed=42)\n\nfor _ in range(100):\n    actions = {agent: env.action_space(agent).sample() for agent in env.agents}\n    observations, rewards, terminations, truncations, infos = env.step(actions)\n    if not env.agents:\n        break\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>If you use CoGrid in your research, please cite the following paper:</p> <pre><code>@article{mcdonald2024cogrid,\n  author  = {McDonald, Chase and Gonzalez, Cleotilde},\n  title   = {CoGrid and Interactive Gym: A Framework for Multi-Agent Experimentation},\n  year    = {forthcoming},\n}\n</code></pre>"},{"location":"#navigation","title":"Navigation","text":"<ul> <li>Getting Started -- installation and first steps</li> <li>Architecture -- backend, EnvState, component API, step pipeline</li> <li>Custom Environment -- build your own environment</li> <li>JAX Backend -- JIT, vmap, functional API</li> <li>Environments -- Overcooked, Search &amp; Rescue, Goal Seeking</li> <li>API Reference -- auto-generated from source</li> <li>Contributing -- how to contribute</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to CoGrid! This guide walks through the complete workflow: fork, install, develop, test, and submit.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Fork the repository on GitHub:    chasemcd/cogrid</p> </li> <li> <p>Clone your fork:</p> <pre><code>git clone https://github.com/YOUR_USERNAME/cogrid.git\ncd cogrid\n</code></pre> </li> <li> <p>Create a virtual environment:</p> <pre><code>python -m venv venv\nsource venv/bin/activate\n</code></pre> </li> <li> <p>Install development dependencies:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre> <p>This installs the package in editable mode along with test tools (pytest, ruff), documentation tools (mkdocs, mkdocstrings), and all core dependencies. See the Getting Started guide for basic installation options.</p> </li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Create a feature branch:</p> <pre><code>git checkout -b feature/your-feature\n</code></pre> </li> <li> <p>Make your changes.</p> </li> <li> <p>Run the test and lint checks (see sections below).</p> </li> <li> <p>Commit with a descriptive message and push:</p> <pre><code>git add your_files.py\ngit commit -m \"feat: add your feature description\"\ngit push origin feature/your-feature\n</code></pre> </li> <li> <p>Open a pull request against <code>main</code> on GitHub.</p> </li> </ol>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>CoGrid uses pytest for testing. The test suite covers both the NumPy and JAX backends.</p> <pre><code># Run all tests\npytest tests/ -v\n\n# Run only NumPy tests (default, works on Python 3.10+)\npytest tests/\n\n# Run only JAX tests (requires JAX: pip install cogrid[jax])\npytest tests/ -k jax\n</code></pre> <p>JAX requirement</p> <p>JAX tests require Python 3.11+ and JAX &gt;= 0.5.x. Install the JAX extras with <code>pip install -e \".[jax]\"</code> before running JAX-specific tests.</p>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>CoGrid uses Ruff for both linting and formatting. The configuration lives in <code>pyproject.toml</code>.</p> <pre><code># Check for lint issues\nruff check cogrid/\n\n# Auto-fix lint issues\nruff check --fix cogrid/\n\n# Check formatting\nruff format --check cogrid/\n\n# Auto-format\nruff format cogrid/\n</code></pre> <p>Style conventions:</p> <ul> <li>Line length: 100 characters</li> <li>Docstrings: Google convention (see   Google Python Style Guide)</li> <li>All public classes, methods, and functions must have docstrings</li> </ul>"},{"location":"contributing/#submitting-changes","title":"Submitting Changes","text":"<ol> <li>Ensure all tests pass: <code>pytest tests/ -v</code></li> <li>Ensure lint passes: <code>ruff check cogrid/</code></li> <li>Ensure formatting passes: <code>ruff format --check cogrid/</code></li> <li>Push to your fork: <code>git push origin feature/your-feature</code></li> <li>Open a pull request against <code>main</code></li> </ol> <p>CI runs automatically on every pull request:</p> <ul> <li>Tests on Python 3.10, 3.11, and 3.12</li> <li>Lint via <code>ruff check</code></li> <li>JAX tests on Python 3.12</li> </ul>"},{"location":"contributing/#previewing-documentation","title":"Previewing Documentation","text":"<p>To preview documentation changes locally:</p> <pre><code>pip install -e \".[docs]\"\nmkdocs serve\n</code></pre> <p>Visit http://127.0.0.1:8000 to see the live preview. Changes to Markdown files are hot-reloaded automatically.</p>"},{"location":"contributing/#creating-a-new-environment","title":"Creating a New Environment","text":"<p>New environments live in <code>cogrid/envs/your_env/</code> and follow the same pattern as the built-in environments (overcooked, search_rescue, goal_seeking).</p> <p>The component API provides three registration decorators:</p> <ul> <li><code>@register_object_type</code> -- define grid objects with interaction behavior</li> <li><code>@register_reward_type</code> -- define reward functions that compose automatically</li> <li><code>@register_feature_type</code> -- define observation features</li> </ul> <p>For a complete walkthrough of building an environment from scratch, see the Custom Environment Tutorial.</p> <p>No environment-specific logic in core</p> <p>All environment-specific behavior must be implemented through the component API. The core engine (<code>cogrid/core/</code> and <code>cogrid/cogrid_env.py</code>) must remain environment-agnostic.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide walks through installing CoGrid, creating an environment, and running your first simulation loop on both the NumPy and JAX backends.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"Basic (NumPy)With JAXDevelopment <pre><code>pip install cogrid\n</code></pre> <pre><code>pip install cogrid[jax]\n</code></pre> <pre><code>git clone https://github.com/chasemcd/cogrid.git\ncd cogrid\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/#quick-start","title":"Quick Start","text":"<p>CoGrid environments follow the PettingZoo parallel API. Create an environment, reset it, and step through a loop:</p> NumPy (default)JAX <pre><code>from cogrid.envs import registry\nimport cogrid.envs.overcooked  # triggers component registration\n\nenv = registry.make(\"Overcooked-CrampedRoom-V0\")\nobs, info = env.reset(seed=42)\n\nwhile env.agents:\n    actions = {a: env.action_space(a).sample() for a in env.agents}\n    obs, rewards, terminateds, truncateds, info = env.step(actions)\n</code></pre> <pre><code>import jax\nfrom cogrid.backend import set_backend\nfrom cogrid.envs import registry\nimport cogrid.envs.overcooked\n\nset_backend(\"jax\")\nenv = registry.make(\"Overcooked-CrampedRoom-V0\")\nobs, info = env.reset(seed=42)\n\n# Use the functional API for JIT/vmap\nstate, obs_arr = env.jax_reset(jax.random.key(0))\nactions = jax.numpy.array([0, 3], dtype=jax.numpy.int32)\nstate, obs_arr, rew, terms, truncs, info = env.jax_step(state, actions)\n</code></pre> <p>Import side effects</p> <p>You must <code>import cogrid.envs.overcooked</code> (or whichever environment module you want) before calling <code>registry.make()</code>. The import triggers <code>@register_object_type</code>, <code>@register_reward_type</code>, and <code>@register_feature_type</code> decorators that register components into CoGrid's engine.</p>"},{"location":"getting-started/#understanding-the-output","title":"Understanding the Output","text":"<p>After calling <code>env.step(actions)</code>, you get five return values:</p> Value Type Description <code>obs</code> <code>dict[AgentID, ndarray]</code> Per-agent observation arrays <code>rewards</code> <code>dict[AgentID, float]</code> Per-agent scalar rewards <code>terminateds</code> <code>dict[AgentID, bool]</code> True if the agent's episode ended by task completion <code>truncateds</code> <code>dict[AgentID, bool]</code> True if the agent's episode ended by time limit <code>info</code> <code>dict[AgentID, dict]</code> Per-agent auxiliary information <p>Observations are flat arrays composed from registered Feature functions. Each feature contributes a segment of the array, concatenated in the order listed in the environment config. For example, the Overcooked environments compose <code>agent_dir</code>, <code>agent_position</code>, and inventory features into a single flat vector per agent.</p> <p>Rewards are summed across all registered Reward components. Each <code>Reward.compute()</code> returns an <code>(n_agents,)</code> float32 array; the engine sums them and converts to per-agent floats.</p>"},{"location":"getting-started/#whats-next","title":"What's Next","text":"<ul> <li>Architecture -- Understand the xp backend   system, EnvState, component API, and step pipeline.</li> <li>Custom Environment Tutorial -- Create   your own environment with grid objects, rewards, and features.</li> <li>JAX Backend Tutorial -- Use JIT compilation   and vmap batching for high-performance training.</li> <li>API Reference -- Full auto-generated API documentation.</li> </ul>"},{"location":"concepts/architecture/","title":"Architecture","text":"<p>This page explains the key architectural concepts in CoGrid: the array backend system, the immutable state container, the component registration API, and the step pipeline that ties everything together.</p>"},{"location":"concepts/architecture/#overview","title":"Overview","text":"<p>CoGrid separates the stateful PettingZoo wrapper from a pure functional simulation core. All environment logic is composed from registered components at initialization time, then executed as a single compiled pipeline at runtime.</p> <pre><code>+-----------------------------+\n|        CoGridEnv            |   Stateful wrapper (PettingZoo API)\n+-----------------------------+\n| config dict                 |   Declares scope, features, rewards, layout\n+----+------------------------+\n     |\n     v\n+----+------------------------+\n|      Autowire Layer         |   Composes registered components into\n|  build_scope_config()       |   a scope_config dict at init time\n|  build_reward_config()      |\n|  build_feature_config()     |\n+----+------------------------+\n     |\n     v\n+----+------------------------+\n|      Step Pipeline          |   Pure function: (state, actions) -&gt; (state, obs, rewards, ...)\n|  tick -&gt; move -&gt; interact   |\n|  -&gt; observe -&gt; reward       |\n+-----------------------------+\n</code></pre> <p>The CoGridEnv wrapper handles PettingZoo dict conversion and rendering. The autowire layer discovers registered components and composes them into configuration dicts. The step pipeline is a pure function that takes an <code>EnvState</code> and actions, and returns the next state plus observations, rewards, and done flags.</p>"},{"location":"concepts/architecture/#the-xp-backend-system","title":"The xp Backend System","text":"<p>CoGrid supports both NumPy and JAX through a shared array namespace called <code>xp</code>. All simulation code uses <code>xp</code> operations, so the same code path works on both backends with zero branching.</p> <pre><code>from cogrid.backend import xp\n\n# This works identically whether the backend is numpy or jax.numpy\narr = xp.zeros((3, 3), dtype=xp.int32)\nresult = xp.where(arr &gt; 0, arr, xp.ones_like(arr))\n</code></pre> <p>Switch the backend before creating any environment:</p> NumPy (default)JAX <pre><code># NumPy is the default -- no setup needed\nfrom cogrid.envs import registry\n\nenv = registry.make(\"Overcooked-CrampedRoom-V0\")\n</code></pre> <pre><code>from cogrid.backend import set_backend\n\nset_backend(\"jax\")  # Must be called BEFORE creating environments\nfrom cogrid.envs import registry\n\nenv = registry.make(\"Overcooked-CrampedRoom-V0\")\n</code></pre> <p>Under the hood, <code>xp</code> is a lazy proxy that resolves to <code>numpy</code> or <code>jax.numpy</code> depending on which backend is active. The first environment created locks the backend for the process -- subsequent environments must use the same backend.</p> <p>Writing backend-compatible code</p> <p>Use <code>xp.where(condition, a, b)</code> instead of Python <code>if/else</code> on array values. JAX traces through code at compile time and cannot handle Python-level conditionals on traced values. The <code>xp.where</code> pattern works identically on both backends.</p>"},{"location":"concepts/architecture/#envstate","title":"EnvState","text":"<p>All simulation state is held in a single frozen dataclass: <code>EnvState</code>.</p> <pre><code>from cogrid.backend.env_state import EnvState\n</code></pre>"},{"location":"concepts/architecture/#core-fields","title":"Core Fields","text":"Field Shape Description <code>agent_pos</code> <code>(n_agents, 2)</code> int32 Row, column position per agent <code>agent_dir</code> <code>(n_agents,)</code> int32 Direction enum per agent <code>agent_inv</code> <code>(n_agents, 1)</code> int32 Held item type ID (-1 = empty) <code>wall_map</code> <code>(H, W)</code> int32 1 where walls exist <code>object_type_map</code> <code>(H, W)</code> int32 Object type ID at each cell <code>object_state_map</code> <code>(H, W)</code> int32 Object state value at each cell <code>extra_state</code> <code>dict[str, array]</code> Scope-prefixed environment-specific arrays <code>rng_key</code> <code>(2,)</code> uint32 JAX PRNG key (None on NumPy) <code>time</code> <code>()</code> int32 Current timestep <code>done</code> <code>(n_agents,)</code> bool True for agents whose episode ended"},{"location":"concepts/architecture/#static-fields","title":"Static Fields","text":"<p>These are compile-time constants (not traced through JAX JIT):</p> Field Description <code>n_agents</code> Number of agents <code>height</code> Grid height <code>width</code> Grid width <code>action_set</code> <code>\"cardinal\"</code> or <code>\"rotation\"</code>"},{"location":"concepts/architecture/#extra-state","title":"Extra State","text":"<p>The <code>extra_state</code> dict holds environment-specific arrays with scope-prefixed keys. For example, the Overcooked environment stores pot cooking timers as <code>\"overcooked.pot_timer\"</code>.</p> <pre><code>import dataclasses\nfrom cogrid.backend.env_state import get_extra, replace_extra\n\n# Read extra state\ntimer = get_extra(state, \"pot_timer\", scope=\"overcooked\")\n\n# Update extra state (returns a new EnvState -- immutable)\nstate = replace_extra(state, \"pot_timer\", new_timer, scope=\"overcooked\")\n\n# Or use dataclasses.replace directly\nnew_extra = {**state.extra_state, \"overcooked.pot_timer\": new_timer}\nstate = dataclasses.replace(state, extra_state=new_extra)\n</code></pre>"},{"location":"concepts/architecture/#stateview","title":"StateView","text":"<p>Reward functions and feature extractors receive a <code>StateView</code> instead of the raw <code>EnvState</code>. StateView provides the same dot access for core fields but strips scope prefixes from extra state keys:</p> <pre><code># Inside a reward's compute() method:\n# prev_state and state are StateView objects\ntimer = state.pot_timer  # instead of state.extra_state[\"overcooked.pot_timer\"]\npositions = state.agent_pos  # core fields work the same way\n</code></pre>"},{"location":"concepts/architecture/#jax-pytree-registration","title":"JAX Pytree Registration","text":"<p>On the JAX backend, both <code>EnvState</code> and <code>StateView</code> are registered as JAX pytrees. This means they can flow through <code>jax.jit</code>, <code>jax.vmap</code>, and <code>jax.lax.scan</code> without any special handling.</p> <p>Immutability</p> <p><code>EnvState</code> is a frozen dataclass. You cannot mutate it directly. Use <code>dataclasses.replace()</code> to create a new state with updated fields. This is required for JAX compatibility and ensures clean state transitions in the step pipeline.</p>"},{"location":"concepts/architecture/#component-api","title":"Component API","text":"<p>CoGrid environments are assembled from three kinds of registered components: grid objects, rewards, and features. Each uses a decorator to register itself into a global registry, and the autowire layer discovers them at initialization time.</p>"},{"location":"concepts/architecture/#registration-decorators","title":"Registration Decorators","text":"Decorator Registers Module <code>@register_object_type</code> Grid object classes <code>cogrid.core.grid_object</code> <code>@register_reward_type</code> Reward subclasses <code>cogrid.core.rewards</code> <code>@register_feature_type</code> Feature subclasses <code>cogrid.core.features</code> <p>Each decorator takes an <code>object_id</code> (or reward/feature name) and an optional <code>scope</code> parameter that namespaces the component to avoid collisions between environments.</p>"},{"location":"concepts/architecture/#grid-object-classmethods","title":"Grid Object Classmethods","text":"<p>Grid objects can declare behavior through classmethods that the autowire layer discovers and wires into the step pipeline:</p> Classmethod Returns Purpose <code>build_tick_fn</code> <code>(state, scope_config) -&gt; state</code> Per-step state updates (e.g., cooking timers) <code>extra_state_schema</code> <code>dict</code> Declare extra state arrays this object needs <code>extra_state_builder</code> <code>fn(parsed, scope) -&gt; dict</code> Initialize extra state from the parsed layout <code>build_static_tables</code> <code>dict</code> Additional lookup arrays for interaction logic <code>build_render_sync_fn</code> <code>fn(grid, state, scope) -&gt; None</code> Sync array state back to GridObj for rendering"},{"location":"concepts/architecture/#how-autowire-works","title":"How Autowire Works","text":"<p>At environment initialization, the autowire layer:</p> <ol> <li>Scans the object registry for all objects in the environment's scope</li> <li>Collects classmethods (<code>build_tick_fn</code>, <code>extra_state_schema</code>, etc.)</li> <li>Builds a <code>scope_config</code> dict containing tick handlers, interaction tables,    type ID mappings, and static lookup tables</li> <li>Builds a <code>reward_config</code> from registered reward components</li> <li>Builds a <code>feature_config</code> by composing registered feature functions</li> </ol> <p>The resulting configs are closed over by <code>build_step_fn</code> and <code>build_reset_fn</code>, producing pure functions that capture all environment logic. On the JAX backend, these closures are JIT-compiled as a single unit.</p> <p>For a hands-on walkthrough of creating components, see the Custom Environment Tutorial.</p>"},{"location":"concepts/architecture/#step-pipeline","title":"Step Pipeline","text":"<p>The step pipeline is the heart of CoGrid's simulation engine. It is a pure function that transforms state:</p> <pre><code>(EnvState, actions) -&gt; (EnvState, obs, rewards, terminateds, truncateds, info)\n</code></pre>"},{"location":"concepts/architecture/#pipeline-order","title":"Pipeline Order","text":"<p>Each call to <code>step()</code> executes these stages in order:</p> <pre><code>1. tick       -- Run scope-specific tick handler (e.g., decrement cooking timers)\n2. move       -- Resolve agent movement with collision detection\n3. interact   -- Process pickup/drop/place interactions\n4. observe    -- Compose feature functions into observation arrays\n5. reward     -- Compute rewards from all registered Reward components\n6. done       -- Evaluate termination and truncation conditions\n</code></pre>"},{"location":"concepts/architecture/#build-functions","title":"Build Functions","text":"<p>The pipeline is constructed at init time through factory functions:</p> <ul> <li> <p><code>build_step_fn</code> closes over <code>scope_config</code>, <code>lookup_tables</code>,   <code>feature_fn</code>, <code>reward_config</code>, and other static configuration. It returns   a <code>(state, actions) -&gt; ...</code> closure.</p> </li> <li> <p><code>build_reset_fn</code> closes over <code>layout_arrays</code>, <code>spawn_positions</code>, and   <code>feature_fn</code>. It returns a <code>(rng) -&gt; (state, obs)</code> closure.</p> </li> </ul> <p>On the JAX backend, both closures are automatically JIT-compiled. The entire step function -- from tick through reward computation -- compiles as one XLA computation for maximum performance.</p> NumPyJAX (functional) <pre><code># PettingZoo API (stateful wrapper calls pipeline internally)\nobs, rewards, terminateds, truncateds, info = env.step(actions)\n</code></pre> <pre><code># Direct functional API -- pure function on EnvState\nstate, obs, rew, terms, truncs, info = env.jax_step(state, actions)\n</code></pre> <p>JIT compilation</p> <p>On the JAX backend, the first call to <code>jax_step</code> or <code>jax_reset</code> triggers XLA compilation. Subsequent calls execute the compiled code and are significantly faster. See the JAX Backend Tutorial for details on JIT and vmap usage.</p>"},{"location":"environments/goal-seeking/","title":"Goal Seeking","text":""},{"location":"environments/goal-seeking/#overview","title":"Overview","text":"<p>Goal Seeking is a simple navigation environment where agents move through a grid to reach goal positions. It serves as a minimal example of how to build a CoGrid environment from scratch using the component API -- no environment subclass is needed.</p>"},{"location":"environments/goal-seeking/#environment-details","title":"Environment Details","text":""},{"location":"environments/goal-seeking/#game-mechanics","title":"Game Mechanics","text":"<ul> <li>Agents spawn on designated start cells and navigate using cardinal actions   (up, down, left, right).</li> <li>A goal cell (<code>g</code>) is placed on the grid. When any agent steps onto it,   all agents receive +1.0 reward (common reward).</li> <li>The episode terminates when an agent reaches the goal or <code>max_steps</code> is   reached.</li> </ul>"},{"location":"environments/goal-seeking/#objects","title":"Objects","text":"Object Char Color Description Goal <code>g</code> Green Target cell that agents navigate toward Wall <code>#</code> Grey Impassable boundary"},{"location":"environments/goal-seeking/#reward","title":"Reward","text":"<p>The <code>GoalReward</code> component awards +1.0 (common) for each agent standing on a goal cell at every step, encouraging agents to reach the goal quickly.</p>"},{"location":"environments/goal-seeking/#quick-start","title":"Quick Start","text":"NumPy (default)JAX <pre><code>from cogrid.envs import registry\n\n# The GoalFinding example registers \"GoalFinding-Simple-V0\"\nimport examples.goal_finding  # registers objects, layout, reward, and env\n\nenv = registry.make(\"GoalFinding-Simple-V0\", backend=\"numpy\")\nobs, info = env.reset(seed=42)\n\nfor _ in range(50):\n    actions = {a: env.action_space.sample() for a in env.possible_agents}\n    obs, rewards, terminateds, truncateds, info = env.step(actions)\n</code></pre> <pre><code>import jax\nimport jax.numpy as jnp\nfrom cogrid.envs import registry\nimport examples.goal_finding\n\nenv = registry.make(\"GoalFinding-Simple-V0\", backend=\"jax\")\n\n# Direct functional API (JIT-compiled)\nstep_fn = env.jax_step\nreset_fn = env.jax_reset\n\nstate, obs = reset_fn(jax.random.key(0))\nactions = jnp.array([0, 3], dtype=jnp.int32)  # Agent 0: Up, Agent 1: Right\nstate, obs, rew, terminateds, truncateds, _ = step_fn(state, actions)\n\n# Batched rollouts with vmap (1024 parallel environments)\nbatched_reset = jax.jit(jax.vmap(reset_fn))\nbatched_step = jax.jit(jax.vmap(step_fn))\n\nkeys = jax.random.split(jax.random.key(1), 1024)\nbatched_state, batched_obs = batched_reset(keys)\n</code></pre>"},{"location":"environments/goal-seeking/#links","title":"Links","text":"<ul> <li>JAX Backend Tutorial -- vmap, JIT, and the   functional API in detail</li> <li>Goal Finding Example --   full source with NumPy and JAX demos</li> </ul>"},{"location":"environments/overcooked/","title":"Overcooked","text":""},{"location":"environments/overcooked/#overview","title":"Overview","text":"<p>Overcooked is a cooperative multi-agent cooking environment based on Carroll et al. (2019). Two agents share a kitchen and must coordinate to pick up ingredients, cook soups in pots, plate the finished dishes, and deliver them to a serving area for reward.</p> <p>{ width=\"60%\" }</p>"},{"location":"environments/overcooked/#environment-details","title":"Environment Details","text":""},{"location":"environments/overcooked/#game-mechanics","title":"Game Mechanics","text":"<ol> <li>Pick up ingredients -- agents take onions (or tomatoes) from infinite    supply stacks.</li> <li>Place in pot -- ingredients are placed into a pot (capacity 3, same    ingredient type per pot).</li> <li>Wait for cooking -- once the pot is full, a 30-step cooking timer starts.</li> <li>Plate the soup -- when the timer reaches zero the soup is ready; an agent    holding a plate can pick it up from the pot.</li> <li>Deliver -- carry the plated soup to a delivery zone to earn the delivery    reward.</li> </ol>"},{"location":"environments/overcooked/#objects","title":"Objects","text":"Object Char Description OnionStack <code>O</code> Infinite supply of onions TomatoStack <code>T</code> Infinite supply of tomatoes Onion <code>o</code> A single onion ingredient Tomato <code>t</code> A single tomato ingredient Pot <code>U</code> Cooking pot (capacity 3, 30-step timer) PlateStack <code>=</code> Infinite supply of plates Plate <code>P</code> A plate for carrying soup OnionSoup <code>S</code> Completed onion soup TomatoSoup <code>!</code> Completed tomato soup DeliveryZone <code>@</code> Delivery area for serving soup Counter <code>C</code> Impassable counter surface"},{"location":"environments/overcooked/#rewards","title":"Rewards","text":"Reward Coefficient Scope Description Delivery 1.0 Common Deliver a plated soup to a delivery zone Onion-in-pot 0.1 Individual Place an onion into a pot with capacity Soup-in-dish 0.3 Individual Pick up a finished soup from a pot with a plate"},{"location":"environments/overcooked/#available-layouts","title":"Available Layouts","text":"Environment ID Layout Description <code>Overcooked-CrampedRoom-V0</code> Cramped Room Small 5x5 kitchen, tight coordination required <code>Overcooked-AsymmetricAdvantages-V0</code> Asymmetric Advantages Asymmetric access to ingredients and delivery <code>Overcooked-CoordinationRing-V0</code> Coordination Ring Circular layout requiring movement coordination <code>Overcooked-ForcedCoordination-V0</code> Forced Coordination Agents have fixed spawn points and must pass items <code>Overcooked-CounterCircuit-V0</code> Counter Circuit Large layout with central counter island <code>Overcooked-RandomizedLayout-V0</code> Randomized Randomly selects one of the five layouts each episode <code>Overcooked-CrampedRoom-SingleAgent-V0</code> Cramped Room (1 agent) Single-agent variant of Cramped Room"},{"location":"environments/overcooked/#quick-start","title":"Quick Start","text":"<pre><code>from cogrid.envs import registry\nimport cogrid.envs.overcooked\n\nenv = registry.make(\"Overcooked-CrampedRoom-V0\")\nobs, info = env.reset(seed=42)\n\nwhile env.agents:\n    actions = {a: env.action_space.sample() for a in env.agents}\n    obs, rewards, terminateds, truncateds, info = env.step(actions)\n</code></pre>"},{"location":"environments/overcooked/#links","title":"Links","text":"<ul> <li>Custom Environment Tutorial -- how   Overcooked is built using the component API</li> <li>JAX Backend Tutorial -- training Overcooked   agents with JAX and vmap</li> <li>API Reference: cogrid.envs.overcooked --   module documentation</li> </ul>"},{"location":"environments/search-rescue/","title":"Search &amp; Rescue","text":""},{"location":"environments/search-rescue/#overview","title":"Overview","text":"<p>Search &amp; Rescue is a cooperative environment inspired by the Minimap task (Nguyen &amp; Gonzalez, 2023). Two agents explore a partially-observable grid to locate and rescue victims of varying difficulty while clearing obstacles that block their path.</p> <p>{ width=\"60%\" }</p>"},{"location":"environments/search-rescue/#environment-details","title":"Environment Details","text":""},{"location":"environments/search-rescue/#victim-types","title":"Victim Types","text":"Victim Char Color Rescue Requirement Reward GreenVictim <code>G</code> Green Any adjacent agent toggles 0.1 PurpleVictim <code>P</code> Purple Any adjacent agent toggles 0.2 YellowVictim <code>Y</code> Yellow Agent must be a Medic or carry a MedKit 0.2 RedVictim <code>R</code> Red First agent with MedKit starts a 30-step countdown; a second agent must toggle within the window --"},{"location":"environments/search-rescue/#items-and-obstacles","title":"Items and Obstacles","text":"Object Char Description MedKit <code>M</code> Enables rescuing yellow victims; required to start red victim rescue Pickaxe <code>T</code> Enables clearing rubble (or the Engineer role) Rubble <code>X</code> Blocks movement; cleared by an agent with a pickaxe (reward: 0.05) Door <code>D</code> Locked door; opened with a key Key <code>K</code> Unlocks a locked door"},{"location":"environments/search-rescue/#collaboration-patterns","title":"Collaboration Patterns","text":"<ul> <li>Sequential -- one agent clears rubble or unlocks a door so both agents   can access new areas.</li> <li>Parallel -- rescuing a red victim requires two agents to act within a   shared time window: one with a MedKit starts the countdown, and a different   agent completes the rescue.</li> </ul>"},{"location":"environments/search-rescue/#quick-start","title":"Quick Start","text":"<pre><code>from cogrid.envs import registry\nimport cogrid.envs.search_rescue\n\nenv = registry.make(\"SearchRescue-Test-V0\")\nobs, info = env.reset(seed=42)\n\nwhile env.agents:\n    actions = {a: env.action_space.sample() for a in env.agents}\n    obs, rewards, terminateds, truncateds, info = env.step(actions)\n</code></pre>"},{"location":"environments/search-rescue/#links","title":"Links","text":"<ul> <li>Custom Environment Tutorial -- how   environments are built using the component API</li> <li>API Reference: cogrid.envs.search_rescue --   module documentation</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>cogrid<ul> <li>backend<ul> <li>array_ops</li> <li>env_state</li> <li>state_view</li> </ul> </li> <li>cogrid_env</li> <li>constants</li> <li>core<ul> <li>actions</li> <li>agent</li> <li>autowire</li> <li>component_registry</li> <li>constants</li> <li>directions</li> <li>features</li> <li>grid</li> <li>grid_object</li> <li>grid_object_base</li> <li>grid_object_registry</li> <li>grid_objects</li> <li>grid_utils</li> <li>interactions</li> <li>layout_parser</li> <li>layouts</li> <li>movement</li> <li>rewards</li> <li>roles</li> <li>step_pipeline</li> <li>typing</li> </ul> </li> <li>envs<ul> <li>goal_seeking<ul> <li>agent</li> <li>goal_seeking</li> </ul> </li> <li>overcooked<ul> <li>agent</li> <li>config</li> <li>features</li> <li>overcooked_grid_objects</li> <li>rewards</li> </ul> </li> <li>registry</li> <li>search_rescue<ul> <li>search_rescue_grid_objects</li> <li>sr_utils</li> </ul> </li> </ul> </li> <li>feature_space<ul> <li>features</li> </ul> </li> <li>rendering<ul> <li>env_renderer</li> </ul> </li> <li>run_interactive</li> <li>visualization<ul> <li>rendering</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/cogrid/","title":"cogrid","text":""},{"location":"reference/cogrid/#cogrid","title":"<code>cogrid</code>","text":"<p>CoGrid: Multi-agent grid-world environments for reinforcement learning.</p>"},{"location":"reference/cogrid/#cogrid.make","title":"<code>make(environment_id, **kwargs)</code>","text":"<p>Create a pre-registered CoGrid environment by name.</p> <p>Triggers registration of all built-in environments on first call.</p> Source code in <code>cogrid/__init__.py</code> <pre><code>def make(environment_id: str, **kwargs):\n    \"\"\"Create a pre-registered CoGrid environment by name.\n\n    Triggers registration of all built-in environments on first call.\n    \"\"\"\n    import cogrid.envs  # noqa: F401 -- trigger registration\n    from cogrid.envs import registry\n\n    return registry.make(environment_id, **kwargs)\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/","title":"cogrid_env","text":""},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env","title":"<code>cogrid.cogrid_env</code>","text":"<p>CoGrid environment: stateful wrapper around the functional step/reset pipeline.</p>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv","title":"<code>CoGridEnv</code>","text":"<p>               Bases: <code>ParallelEnv</code></p> <p>Thin stateful wrapper around the functional step/reset pipeline.</p> <p>Both numpy and JAX backends delegate to <code>build_step_fn</code>/<code>build_reset_fn</code>.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>class CoGridEnv(pettingzoo.ParallelEnv):\n    \"\"\"Thin stateful wrapper around the functional step/reset pipeline.\n\n    Both numpy and JAX backends delegate to ``build_step_fn``/``build_reset_fn``.\n    \"\"\"\n\n    metadata = {\n        \"render_modes\": [\"human\", \"rgb_array\"],\n        \"render_fps\": 35,\n        \"screen_size\": 480,\n        \"render_message\": \"\",\n        \"agent_pov\": None,\n        \"highlight\": False,\n        \"see_through_walls\": True,\n    }\n\n    def __init__(\n        self,\n        config: dict,\n        render_mode: str | None = None,\n        agent_class: agent.Agent | None = None,\n        backend: str = \"numpy\",\n        **kwargs,\n    ):\n        \"\"\"Initialize the CoGrid environment.\n\n        The first environment created sets the global backend; subsequent\n        envs must use the same backend or a RuntimeError is raised.\n        \"\"\"\n        super().__init__()\n        self._np_random: np.random.Generator | None = None  # set in reset()\n\n        set_backend(backend)\n        self._backend = backend\n        self.config = config\n        self.name = config[\"name\"]\n        self.cumulative_score = 0\n        self.max_steps = config[\"max_steps\"]\n        self.roles = config.get(\"roles\", True)\n        self.agent_class = agent_class or agent.Agent\n        self.t = 0\n\n        if \"features\" not in config or not isinstance(config[\"features\"], list):\n            raise ValueError(\"config['features'] must be a list of feature names.\")\n\n        self._init_rendering(render_mode, kwargs)\n        self._init_grid(config)\n        self._init_agents(config)\n        self._init_action_space(config)\n        self._init_vectorized_infrastructure()\n        self._init_jax_arrays()\n\n    def _init_rendering(self, render_mode, kwargs):\n        \"\"\"Set up rendering attributes and optional EnvRenderer.\"\"\"\n        self.render_mode = render_mode\n        self.render_message = kwargs.get(\"render_message\") or self.metadata[\"render_message\"]\n        self.tile_size = CoreConstants.TilePixels\n        self.screen_size = kwargs.get(\"screen_size\") or self.metadata[\"screen_size\"]\n        self._renderer = (\n            EnvRenderer(\n                name=self.name,\n                screen_size=self.screen_size,\n                render_fps=self.metadata[\"render_fps\"],\n            )\n            if render_mode\n            else None\n        )\n        self.visualizer = None\n\n    def _init_grid(self, config):\n        \"\"\"Initialize grid, spawn points, and shape from config.\"\"\"\n        self.scope: str = config.get(\"scope\", \"global\")\n        self.grid: grid.Grid | None = None\n        self.spawn_points: list = []\n        self.current_layout_id: str | None = None\n        self._gen_grid()\n        self.shape = (self.grid.height, self.grid.width)\n\n    def _init_agents(self, config):\n        \"\"\"Initialize agent bookkeeping: IDs, env_agents dict, rewards.\"\"\"\n        self.possible_agents = [i for i in range(config[\"num_agents\"])]\n        self.agents = copy.copy(self.possible_agents)\n        self._agent_ids: set[typing.AgentID] = set(self.agents)\n        self.env_agents: dict[typing.AgentID, agent.Agent] = {i: None for i in self.agents}\n        self.per_agent_reward: dict[typing.AgentID, float] = self.get_empty_reward_dict()\n        self.per_component_reward: dict[str, dict[typing.AgentID, float]] = {}\n        self.reward_this_step = self.get_empty_reward_dict()\n        self.agent_view_size = self.config.get(\"agent_view_size\", 7)\n\n    def _init_action_space(self, config):\n        \"\"\"Parse action set from config and build per-agent action spaces.\"\"\"\n        action_str = config.get(\"action_set\")\n        if action_str == \"rotation_actions\":\n            self.action_set = grid_actions.ActionSets.RotationActions\n        elif action_str == \"cardinal_actions\":\n            self.action_set = grid_actions.ActionSets.CardinalActions\n        else:\n            raise ValueError(f\"Invalid or None action set string: {action_str}.\")\n\n        self.action_spaces = {\n            a_id: spaces.Discrete(len(self.action_set)) for a_id in self.agent_ids\n        }\n\n        self._action_pickup_drop_idx = self.action_set.index(grid_actions.Actions.PickupDrop)\n        self._action_toggle_idx = self.action_set.index(grid_actions.Actions.Toggle)\n        self.prev_actions = None\n\n    def _init_vectorized_infrastructure(self):\n        \"\"\"Build lookup tables, scope config, reward config, and pipeline placeholders.\"\"\"\n        self._lookup_tables = build_lookup_tables(scope=self.scope)\n\n        from cogrid.core.autowire import (\n            build_reward_config_from_components,\n            build_scope_config_from_components,\n        )\n\n        self._scope_config = build_scope_config_from_components(self.scope)\n        if \"interaction_fn\" in self.config:\n            self._scope_config[\"interaction_fn\"] = self.config[\"interaction_fn\"]\n        self._type_ids = self._scope_config[\"type_ids\"]\n        self._interaction_tables = self._scope_config.get(\"interaction_tables\")\n\n        self._state = None\n        self._feature_fn = None\n\n        self._reward_config = build_reward_config_from_components(\n            self.scope,\n            n_agents=self.config[\"num_agents\"],\n            type_ids=self._type_ids,\n            action_pickup_drop_idx=self._action_pickup_drop_idx,\n        )\n\n        self._agent_id_order = sorted(self.possible_agents)\n        self._terminated_fn = self.config.get(\"terminated_fn\")\n\n        self._step_fn = None\n        self._reset_fn = None\n        self._env_state = None\n\n    def _init_jax_arrays(self):\n        \"\"\"Convert lookup and scope config tables to JAX arrays (JAX backend only).\"\"\"\n        if self._backend != \"jax\":\n            return\n\n        import jax.numpy as jnp\n\n        from cogrid.backend.env_state import register_envstate_pytree\n\n        register_envstate_pytree()\n\n        for key in self._lookup_tables:\n            self._lookup_tables[key] = jnp.array(self._lookup_tables[key], dtype=jnp.int32)\n\n        if \"static_tables\" in self._scope_config:\n            import numpy as _np\n\n            st = self._scope_config[\"static_tables\"]\n            for key in st:\n                if isinstance(st[key], _np.ndarray):\n                    st[key] = jnp.array(st[key], dtype=jnp.int32)\n\n        if self._scope_config.get(\"interaction_tables\") is not None:\n            import numpy as _np\n\n            it = self._scope_config[\"interaction_tables\"]\n            for key in it:\n                if isinstance(it[key], _np.ndarray):\n                    it[key] = jnp.array(it[key], dtype=jnp.int32)\n\n    def _gen_grid(self) -&gt; None:\n        \"\"\"Parse the ASCII layout into a Grid, extracting spawn points.\"\"\"\n        self.spawn_points = []\n        encoded_grid, states = self._generate_encoded_grid_states()\n\n        # If the grid is a list of strings this will turn it into the correct np format\n        np_grid = grid_utils.ascii_to_numpy(encoded_grid)\n        spawn_points = np.where(np_grid == constants.GridConstants.Spawn)\n        np_grid[spawn_points] = constants.GridConstants.FreeSpace\n        self.spawn_points = list(zip(*spawn_points))\n        grid_encoding = np.stack([np_grid, states], axis=0)\n        self.grid, _ = grid.Grid.decode(grid_encoding, scope=self.scope)\n\n    def _generate_encoded_grid_states(self) -&gt; tuple[np.ndarray, np.ndarray]:\n        \"\"\"Generate grid and state arrays from config layout or layout_fn.\"\"\"\n        grid_config: dict = self.config.get(\"grid\", {})\n        layout_name = grid_config.get(\"layout\", None)\n        layout_fn = grid_config.get(\"layout_fn\", None)\n\n        if layout_name is None and layout_fn is None:\n            raise ValueError(\n                \"Must provide either a `layout` name or layout-generating\"\n                \" function in config['grid']\"\n            )\n        elif layout_name is not None:\n            layout, state_encoding = layouts.get_layout(layout_name)\n            self.current_layout_id = layout_name\n        elif layout_fn is not None:\n            layout_name, layout, state_encoding = layout_fn(**grid_config)\n            self.current_layout_id = layout_name\n\n        return layout, state_encoding\n\n    @staticmethod\n    def _set_np_random(\n        seed: int | None = None,\n    ) -&gt; tuple[RandomNumberGenerator, int]:\n        \"\"\"Create a PCG64-backed Generator from an optional integer seed.\"\"\"\n        if seed is not None and not (isinstance(seed, int) and 0 &lt;= seed):\n            if isinstance(seed, int) is False:\n                raise ValueError(f\"Seed must be a python integer, actual type: {type(seed)}\")\n            else:\n                raise ValueError(f\"Seed must be greater or equal to zero, actual value: {seed}\")\n\n        seed_seq = np.random.SeedSequence(seed)\n        np_seed = seed_seq.entropy\n        rng = RandomNumberGenerator(np.random.PCG64(seed_seq))\n        return rng, np_seed\n\n    @property\n    def np_random(self) -&gt; np.random.Generator:\n        \"\"\"Lazily initialize and return the numpy RNG.\"\"\"\n        if self._np_random is None:\n            self._np_random, _ = self._set_np_random()\n\n        return self._np_random\n\n    def action_space(self, agent: typing.AgentID) -&gt; spaces.Space:\n        \"\"\"Return the action space for the given agent.\"\"\"\n        return self.action_spaces[agent]\n\n    def set_terminated_fn(self, fn):\n        \"\"\"Set a per-agent termination function.\n\n        Must be called before the first ``reset()`` so the function\n        is closed over by the JIT-compiled step pipeline.\n\n        ``fn(prev_state, state, reward_config) -&gt; (n_agents,) bool``\n        \"\"\"\n        self._terminated_fn = fn\n\n    def reset(\n        self,\n        *,\n        seed: int | None = 42,\n        options: dict[str, typing.Any] | None = None,\n    ) -&gt; tuple[dict[typing.AgentID, typing.ObsType], dict[str, typing.Any]]:\n        \"\"\"Reset the environment and return initial observations.\n\n        Builds step/reset pipeline on first call, then delegates to\n        the functional reset.\n        \"\"\"\n        self._reset_agents(seed)\n        self._build_state()\n        layout_arrays, spawn_positions, action_set_name = self._build_layout_arrays()\n        obs = self._build_pipeline(layout_arrays, spawn_positions, action_set_name, seed)\n\n        if self.render_mode is not None:\n            self._sync_objects_from_state()\n            self.render()\n\n        return obs, {agent_id: {} for agent_id in self.agent_ids}\n\n    def _reset_agents(self, seed):\n        \"\"\"Reset RNG, regenerate grid, and re-initialize agents.\"\"\"\n        if seed is not None:\n            self._np_random, _ = self._set_np_random(seed=seed)\n\n        self.agents = copy.copy(self.possible_agents)\n        self._gen_grid()\n\n        self.env_agents = {}\n        self.setup_agents()\n\n        self.prev_actions = {a_id: grid_actions.Actions.Noop for a_id in self.agent_ids}\n\n        self.t = 0\n        self.on_reset()\n        self.update_grid_agents()\n\n    def _build_state(self):\n        \"\"\"Build array state from grid layout, extra state, and agent arrays.\"\"\"\n        self._state = layout_to_state(self.grid, scope=self.scope, scope_config=self._scope_config)\n\n        extra_state_builder = self._scope_config.get(\"extra_state_builder\")\n        if extra_state_builder is not None:\n            extra = extra_state_builder(self._state, self.scope)\n            scope_prefix = f\"{self.scope}.\"\n            stripped = {\n                (k[len(scope_prefix) :] if k.startswith(scope_prefix) else k): v\n                for k, v in extra.items()\n            }\n            self._state.update(stripped)\n\n        agent_arrays = create_agent_arrays(self.env_agents, scope=self.scope)\n        self._state.update(agent_arrays)\n        self.cumulative_score = 0\n\n    def _build_layout_arrays(self):\n        \"\"\"Convert array state to typed layout arrays for the active backend.\"\"\"\n        if self._backend == \"jax\":\n            import jax.numpy as jnp\n\n            xp = jnp\n        else:\n            xp = np\n\n        skip_keys = {\"agent_pos\", \"agent_dir\", \"agent_inv\", \"spawn_points\"}\n        layout_arrays = {}\n        for key, val in self._state.items():\n            if key in skip_keys:\n                continue\n            if isinstance(val, list):\n                val = (\n                    np.array(val, dtype=np.int32)\n                    if len(val) &gt; 0\n                    else np.zeros((0, 2), dtype=np.int32)\n                )\n            layout_arrays[key] = xp.array(val, dtype=xp.int32)\n\n        spawn_positions = xp.array(self._state[\"agent_pos\"], dtype=xp.int32)\n\n        if self.action_set == grid_actions.ActionSets.CardinalActions:\n            action_set_name = \"cardinal\"\n        else:\n            action_set_name = \"rotation\"\n\n        return layout_arrays, spawn_positions, action_set_name\n\n    def _build_pipeline(self, layout_arrays, spawn_positions, action_set_name, seed):\n        \"\"\"Build feature/step/reset pipeline and run initial reset.\"\"\"\n        from cogrid.core.autowire import build_feature_config_from_components\n        from cogrid.core.component_registry import get_layout_index\n        from cogrid.core.step_pipeline import build_reset_fn, build_step_fn\n\n        n_agents = self.config[\"num_agents\"]\n        _layout_idx = get_layout_index(self.scope, self.current_layout_id)\n\n        feature_config = build_feature_config_from_components(\n            self.scope,\n            self.config[\"features\"],\n            n_agents=n_agents,\n            layout_idx=_layout_idx,\n        )\n        self._feature_fn = feature_config[\"feature_fn\"]\n\n        self._reset_fn = build_reset_fn(\n            layout_arrays,\n            spawn_positions,\n            n_agents,\n            self._feature_fn,\n            self._scope_config,\n            action_set_name,\n        )\n\n        self._step_fn = build_step_fn(\n            self._scope_config,\n            self._lookup_tables,\n            self._feature_fn,\n            self._reward_config,\n            self._action_pickup_drop_idx,\n            self._action_toggle_idx,\n            self.max_steps,\n            terminated_fn=self._terminated_fn,\n        )\n\n        if self._backend == \"jax\":\n            import jax\n\n            rng = jax.random.key(seed if seed is not None else 42)\n        else:\n            rng = seed if seed is not None else 42\n\n        self._env_state, obs_arr = self._reset_fn(rng)\n\n        obs = {aid: np.array(obs_arr[i]) for i, aid in enumerate(self._agent_id_order)}\n\n        self.per_agent_reward = self.get_empty_reward_dict()\n        self.per_component_reward = {}\n        return obs\n\n    def _action_idx_to_str(\n        self, actions: dict[typing.AgentID, int | str]\n    ) -&gt; dict[typing.AgentID, str]:\n        \"\"\"Convert action indices to their string names.\"\"\"\n        str_actions = {\n            a_id: (self.action_set[action] if not isinstance(action, str) else action)\n            for a_id, action in actions.items()\n        }\n\n        return str_actions\n\n    def step(\n        self, actions: dict[typing.AgentID, typing.ActionType]\n    ) -&gt; tuple[\n        dict[typing.AgentID, typing.ObsType],\n        dict[typing.AgentID, float],\n        dict[typing.AgentID, bool],\n        dict[typing.AgentID, bool],\n        dict[typing.AgentID, dict[typing.Any, typing.Any]],\n    ]:\n        \"\"\"Advance one timestep via the unified step pipeline.\n\n        Converts dict actions to an ordered array, delegates to\n        ``self._step_fn``, and converts outputs back to PettingZoo dicts.\n        \"\"\"\n        # Select array module\n        if self._backend == \"jax\":\n            import jax.numpy as jnp\n\n            xp = jnp\n        else:\n            xp = np\n\n        # Convert action dict to ordered array\n        actions_arr = xp.array(\n            [actions[aid] for aid in self._agent_id_order],\n            dtype=xp.int32,\n        )\n\n        # Delegate to the unified step pipeline\n        self._env_state, obs_arr, rewards_arr, terminateds_arr, truncateds_arr, infos = (\n            self._step_fn(self._env_state, actions_arr)\n        )\n\n        # Convert to PettingZoo dict format\n        obs = {aid: np.array(obs_arr[i]) for i, aid in enumerate(self._agent_id_order)}\n        rewards = {aid: float(rewards_arr[i]) for i, aid in enumerate(self._agent_id_order)}\n\n        terminateds = {aid: bool(terminateds_arr[i]) for i, aid in enumerate(self._agent_id_order)}\n        truncateds = {aid: bool(truncateds_arr[i]) for i, aid in enumerate(self._agent_id_order)}\n\n        if any(terminateds.values()) or any(truncateds.values()):\n            self.agents = []\n\n        infos = {aid: {} for aid in self._agent_id_order}\n\n        # Increment PettingZoo timestep counter\n        self.t += 1\n\n        self.cumulative_score += sum(rewards.values())\n\n        # Sync rendering objects from state if needed\n        if self.render_mode is not None:\n            self._sync_objects_from_state()\n            self.render()\n\n        # Custom hook if a subclass wants to make any updates\n        self.on_step()\n\n        return obs, rewards, terminateds, truncateds, infos\n\n    def get_state(self) -&gt; dict:\n        \"\"\"Export a JSON-serializable snapshot of the full environment state.\n\n        Returns plain Python lists/scalars suitable for ``json.dumps()``.\n        Restorable via :meth:`set_state`. Must be called after :meth:`reset`.\n        \"\"\"\n        if self._env_state is None:\n            raise RuntimeError(\"Must call reset() before get_state()\")\n\n        state = self._env_state\n        snapshot = {\n            \"agent_pos\": np.array(state.agent_pos).tolist(),\n            \"agent_dir\": np.array(state.agent_dir).tolist(),\n            \"agent_inv\": np.array(state.agent_inv).tolist(),\n            \"wall_map\": np.array(state.wall_map).tolist(),\n            \"object_type_map\": np.array(state.object_type_map).tolist(),\n            \"object_state_map\": np.array(state.object_state_map).tolist(),\n            \"extra_state\": {k: np.array(v).tolist() for k, v in state.extra_state.items()},\n            \"rng_key\": np.array(state.rng_key).tolist() if state.rng_key is not None else None,\n            \"time\": int(state.time),\n            \"done\": np.array(state.done).tolist(),\n            \"n_agents\": state.n_agents,\n            \"height\": state.height,\n            \"width\": state.width,\n            \"action_set\": state.action_set,\n            \"t\": self.t,\n            \"cumulative_score\": float(self.cumulative_score),\n        }\n        return snapshot\n\n    def set_state(self, snapshot: dict) -&gt; None:\n        \"\"\"Restore from a dict produced by :meth:`get_state`.\n\n        Must be called after :meth:`reset` (pipeline must be initialized).\n        Arrays are converted to the active backend's type.\n        \"\"\"\n        if self._step_fn is None:\n            raise RuntimeError(\"Must call reset() before set_state()\")\n\n        from cogrid.backend.env_state import create_env_state\n\n        if self._backend == \"jax\":\n            import jax.numpy as jnp\n\n            xp = jnp\n        else:\n            xp = np\n\n        extra_state = {k: xp.array(v, dtype=xp.int32) for k, v in snapshot[\"extra_state\"].items()}\n\n        rng_key = snapshot[\"rng_key\"]\n        if rng_key is not None:\n            if self._backend == \"jax\":\n                import jax\n\n                rng_key = jax.numpy.array(rng_key, dtype=jax.numpy.uint32)\n            else:\n                rng_key = np.array(rng_key)\n\n        self._env_state = create_env_state(\n            agent_pos=xp.array(snapshot[\"agent_pos\"], dtype=xp.int32),\n            agent_dir=xp.array(snapshot[\"agent_dir\"], dtype=xp.int32),\n            agent_inv=xp.array(snapshot[\"agent_inv\"], dtype=xp.int32),\n            wall_map=xp.array(snapshot[\"wall_map\"], dtype=xp.int32),\n            object_type_map=xp.array(snapshot[\"object_type_map\"], dtype=xp.int32),\n            object_state_map=xp.array(snapshot[\"object_state_map\"], dtype=xp.int32),\n            extra_state=extra_state,\n            rng_key=rng_key,\n            time=xp.int32(snapshot[\"time\"]),\n            done=xp.array(snapshot[\"done\"], dtype=xp.bool_),\n            n_agents=snapshot[\"n_agents\"],\n            height=snapshot[\"height\"],\n            width=snapshot[\"width\"],\n            action_set=snapshot[\"action_set\"],\n        )\n\n        self.t = snapshot[\"t\"]\n        self.cumulative_score = snapshot[\"cumulative_score\"]\n\n        if self.render_mode is not None:\n            self._sync_objects_from_state()\n\n    def _sync_objects_from_state(self) -&gt; None:\n        \"\"\"Sync Agent/Grid objects from EnvState arrays for rendering.\n\n        Writes array state back to Agent/Grid objects so the tile renderer\n        reflects current simulation state. Scope-specific rendering is\n        delegated to the ``render_sync`` hook in scope_config.\n\n        Only called when render_mode is not None.\n        \"\"\"\n        if self._env_state is None:\n            return\n\n        state = self._env_state\n        from cogrid.core.grid_object import idx_to_object, make_object\n\n        # --- Sync agent positions, directions, and inventory ---\n        for i, aid in enumerate(self._agent_id_order):\n            if aid not in self.env_agents or self.env_agents[aid] is None:\n                continue\n            agent_obj = self.env_agents[aid]\n            pos = np.array(state.agent_pos[i])\n            agent_obj.pos = (int(pos[0]), int(pos[1]))\n            agent_obj.dir = int(np.array(state.agent_dir[i]))\n\n            inv_type_id = int(np.array(state.agent_inv[i, 0]))\n            if inv_type_id &lt;= 0:\n                agent_obj.inventory = []\n            else:\n                obj_id = idx_to_object(inv_type_id, scope=self.scope)\n                agent_obj.inventory = [make_object(obj_id, scope=self.scope)] if obj_id else []\n\n        # --- Sync grid cells from object_type_map / object_state_map ---\n        otm = np.array(state.object_type_map)\n        osm = np.array(state.object_state_map)\n\n        for r in range(self.grid.height):\n            for c in range(self.grid.width):\n                type_id = int(otm[r, c])\n                state_val = int(osm[r, c])\n\n                if type_id == 0:\n                    self.grid.set(r, c, None)\n                    continue\n\n                obj_id = idx_to_object(type_id, scope=self.scope)\n                if obj_id is None or obj_id == \"free_space\":\n                    self.grid.set(r, c, None)\n                    continue\n\n                existing = self.grid.get(r, c)\n                if existing is not None and existing.object_id == obj_id:\n                    existing.state = state_val\n                else:\n                    new_obj = make_object(obj_id, scope=self.scope, state=state_val)\n                    if new_obj is not None:\n                        new_obj.pos = (r, c)\n                    self.grid.set(r, c, new_obj)\n\n        # --- Delegate scope-specific rendering sync ---\n        render_sync = self._scope_config.get(\"render_sync\")\n        if render_sync is not None:\n            render_sync(self.grid, state, self.scope)\n\n        # Rebuild GridAgent wrappers for rendering\n        self.update_grid_agents()\n\n    def update_grid_agents(self) -&gt; None:\n        \"\"\"Update the grid agents to reflect the current state of each Agent.\"\"\"\n        self.grid.grid_agents = {\n            a_id: grid_object.GridAgent(agent, n_agents=self.config[\"num_agents\"], scope=self.scope)\n            for a_id, agent in self.env_agents.items()\n        }\n\n    @property\n    def jax_step(self):\n        \"\"\"Raw JIT-compiled step function for direct JIT/vmap usage.\n\n        ``(EnvState, actions) -&gt; (EnvState, obs, rewards, terminateds, truncateds, infos)``\n        \"\"\"\n        if self._backend != \"jax\":\n            raise RuntimeError(\"jax_step is only available with backend='jax'\")\n        if self._step_fn is None:\n            raise RuntimeError(\"Must call reset() before accessing jax_step\")\n        return self._step_fn\n\n    @property\n    def jax_reset(self):\n        \"\"\"Raw JIT-compiled reset function for direct JIT/vmap usage.\n\n        ``(rng_key) -&gt; (EnvState, obs)``\n        \"\"\"\n        if self._backend != \"jax\":\n            raise RuntimeError(\"jax_reset is only available with backend='jax'\")\n        if self._reset_fn is None:\n            raise RuntimeError(\"Must call reset() before accessing jax_reset\")\n        return self._reset_fn\n\n    def setup_agents(self):\n        \"\"\"Set up agents using the default agent factory.\"\"\"\n        self._setup_agents()\n\n    def _setup_agents(self):\n        for agent_id in range(self.config[\"num_agents\"]):\n            agent = self.agent_class(\n                agent_id=agent_id,\n                start_position=self.select_spawn_point(),\n                start_direction=self.np_random.choice(directions.Directions),\n            )\n            self.env_agents[agent_id] = agent\n\n    # ------------------------------------------------------------------\n    # Hooks for subclass customization\n    # ------------------------------------------------------------------\n\n    def on_interact(self, actions: dict[typing.AgentID, typing.ActionType]) -&gt; None:\n        \"\"\"Hook for subclass logic after agents interact with the environment.\"\"\"\n        pass\n\n    def on_toggle(self, agent_id: typing.AgentID) -&gt; None:\n        \"\"\"Hook for subclass logic after an agent toggles an object.\"\"\"\n        pass\n\n    def on_pickup_drop(self, agent_id: typing.AgentID) -&gt; None:\n        \"\"\"Hook for subclass logic after an agent picks up or drops an object.\"\"\"\n        pass\n\n    def on_reset(self) -&gt; None:\n        \"\"\"Hook for subclasses to implement custom logic after the environment is reset.\"\"\"\n        pass\n\n    def on_step(self) -&gt; None:\n        \"\"\"Hook for subclasses to implement custom logic after each step.\"\"\"\n        pass\n\n    def on_move(self, agent_id: typing.AgentID) -&gt; None:\n        \"\"\"Hook for subclass logic after an agent moves.\"\"\"\n        pass\n\n    # ------------------------------------------------------------------\n    # Observation and reward helpers\n    # ------------------------------------------------------------------\n\n    def get_infos(self, **kwargs) -&gt; dict[typing.AgentID, dict[typing.Any, typing.Any]]:\n        \"\"\"Build per-agent info dicts from keyword argument dicts.\"\"\"\n        infos = {agent_id: {} for agent_id in self._agent_ids}\n        for info_key, info_dict in kwargs.items():\n            for agent_id, val in info_dict.items():\n                assert agent_id in self._agent_ids, (\n                    f\"Must pass dicts keyed by AgentIDs to get_infos(), got invalid key: {agent_id}\"\n                )\n                infos[agent_id][info_key] = val\n        return infos\n\n    def get_empty_reward_dict(self) -&gt; dict[typing.AgentID, float]:\n        \"\"\"Return a reward dict with all agents set to 0.\"\"\"\n        return {a_id: 0 for a_id in self.agent_ids}\n\n    @property\n    def map_with_agents(self) -&gt; np.ndarray:\n        \"\"\"Return the encoded grid with agents overlaid as numeric IDs.\"\"\"\n        grid_encoding = self.grid.encode(encode_char=True, scope=self.scope)\n        grid = grid_encoding[:, :, 0]\n\n        for a_id, ag in self.env_agents.items():\n            if ag is not None:  # will be None before being set by subclassed env\n                grid[ag.pos[0], ag.pos[1]] = self.id_to_numeric(a_id)\n\n        return grid\n\n    def select_spawn_point(self) -&gt; tuple[int, int]:\n        \"\"\"Pop a spawn point from the queue, or pick a random free cell.\"\"\"\n        if self.spawn_points:\n            return self.spawn_points.pop(0)\n\n        available_spawns = self.available_positions\n        return self.np_random.choice(available_spawns)\n\n    @property\n    def available_positions(self) -&gt; list[tuple[int, int]]:\n        \"\"\"Return grid cells that are empty and not occupied by an agent.\"\"\"\n        spawns = []\n        for r in range(self.grid.height):\n            for c in range(self.grid.width):\n                cell = self.grid.get(row=r, col=c)\n                if (r, c) not in self.agent_pos and (not cell or cell.object_id == \"floor\"):\n                    spawns.append((r, c))\n        return spawns\n\n    def put_obj(self, obj: grid_object.GridObj, row: int, col: int):\n        \"\"\"Place an object at (row, col) and set its init_pos.\"\"\"\n        self.grid.set(row=row, col=col, obj=obj)\n        obj.pos = (row, col)\n        obj.init_pos = (row, col)\n\n    def get_view_exts(\n        self, agent_id: typing.AgentID, agent_view_size: int = None\n    ) -&gt; tuple[int, int, int, int]:\n        \"\"\"Return (topX, topY, botX, botY) of the agent's visible tile square.\n\n        Bottom extent indices are exclusive.\n        \"\"\"\n        agent = self.env_agents[agent_id]\n        agent_view_size = agent_view_size or self.agent_view_size\n\n        if agent.dir == directions.Directions.Right:\n            topY = agent.pos[0] - agent_view_size // 2\n            topX = agent.pos[1]\n        elif agent.dir == directions.Directions.Down:\n            topY = agent.pos[0]\n            topX = agent.pos[1] - agent_view_size // 2\n        elif agent.dir == directions.Directions.Left:\n            topY = agent.pos[0] - agent_view_size // 2\n            topX = agent.pos[1] - agent_view_size + 1\n        elif agent.dir == directions.Directions.Up:\n            topY = agent.pos[0] - agent_view_size + 1\n            topX = agent.pos[1] - agent_view_size // 2\n        else:\n            raise ValueError(\"Invalid agent direction.\")\n\n        botX = topX + agent_view_size\n        botY = topY + agent_view_size\n\n        return topX, topY, botX, botY\n\n    def gen_obs_grid(self, agent_id: typing.AgentID, agent_view_size: int = None) -&gt; grid.Grid:\n        \"\"\"Return the rotated sub-grid and visibility mask for an agent's POV.\"\"\"\n        topX, topY, *_ = self.get_view_exts(agent_id, agent_view_size)\n\n        agent_view_size = agent_view_size or self.agent_view_size\n\n        grid = self.grid.slice(topX, topY, agent_view_size, agent_view_size)\n\n        assert agent_id in grid.grid_agents\n\n        agent = self.env_agents[agent_id]\n        for i in range(agent.dir + 1):\n            grid = grid.rotate_left()\n\n        if not self.metadata.get(\"see_through_walls\", True):\n            # Mask view from the agents position at the bottom-center of the grid view\n            vis_mask = grid.process_vis(agent_pos=(-1, grid.width // 2))\n        else:\n            vis_mask = np.ones(shape=(grid.height, grid.width), dtype=bool)\n\n        assert len(grid.grid_agents) &gt;= 1\n        assert grid.grid_agents[agent_id].dir == directions.Directions.Up\n\n        # NOTE: In Minigrid, they replace the agent's position with the item\n        #   they're carrying. We don't do that here. Rather, we'll provide an\n        #   additional observation space that represents the item(s) in inventory.\n\n        return grid, vis_mask\n\n    def get_pov_render(\n        self,\n        agent_id: typing.AgentID,\n        tile_size: int = CoreConstants.TilePixels,\n    ) -&gt; np.ndarray:\n        \"\"\"Render a specific agent's POV as an RGB array.\"\"\"\n        grid, vis_mask = self.gen_obs_grid(agent_id)\n        img = grid.render(\n            tile_size,\n            highlight_mask=vis_mask,\n        )\n        return img\n\n    def get_full_render(\n        self, highlight: bool = False, tile_size: int = CoreConstants.TilePixels\n    ) -&gt; np.ndarray:\n        \"\"\"Render the full grid, optionally highlighting each agent's visible region.\"\"\"\n        if highlight:\n            highlight_mask = np.zeros(shape=(self.grid.height, self.grid.width), dtype=bool)\n            for a_id, agent in self.env_agents.items():\n                # Determine cell visibility for the agent\n                _, vis_mask = self.gen_obs_grid(a_id)\n\n                # compute the world coordinates of the bottom-left corner of the agent's view area\n                f_vec = agent.dir_vec\n                r_vec = agent.right_vec\n                top_left = (\n                    agent.pos\n                    + f_vec * (self.agent_view_size - 1)\n                    - r_vec * (self.agent_view_size // 2)\n                )\n\n                # identify the cells to highlight as visible in the render\n                for vis_row in range(self.agent_view_size):\n                    for vis_col in range(self.agent_view_size):\n                        if not vis_mask[vis_row, vis_col]:\n                            continue\n\n                        # compute world coordinates of agent view\n                        abs_row, abs_col = top_left - (f_vec * vis_row) + (r_vec * vis_col)\n\n                        if abs_row &lt; 0 or abs_row &gt;= self.grid.height:\n                            continue\n                        if abs_col &lt; 0 or abs_col &gt;= self.grid.width:\n                            continue\n\n                        highlight_mask[abs_row, abs_col] = True\n        else:\n            highlight_mask = None\n\n        img = self.grid.render(tile_size=tile_size, highlight_mask=highlight_mask)\n        return img\n\n    def get_frame(\n        self,\n        highlight: bool = True,\n        tile_size: int = CoreConstants.TilePixels,\n        agent_pov: typing.AgentID | None = None,\n    ) -&gt; np.ndarray:\n        \"\"\"Return RGB image of the full environment or a single agent's POV.\"\"\"\n        if agent_pov:\n            frame = self.get_pov_render(agent_id=self.agent_pov, tile_size=tile_size)\n        else:\n            frame = self.get_full_render(highlight=highlight, tile_size=tile_size)\n\n        return frame\n\n    def render(self) -&gt; None | np.ndarray:\n        \"\"\"Render the environment (human window or rgb_array return).\"\"\"\n        if self.visualizer is not None:\n            orientations = {\n                self.id_to_numeric(a_id): agent.orientation\n                for a_id, agent in self.env_agents.items()\n            }\n            inventories = {\n                self.id_to_numeric(a_id): agent.inventory\n                for a_id, agent in self.env_agents.items()\n                if len(agent.inventory) &gt; 0\n            }\n            self.visualizer.render(\n                self.map_with_agents,\n                self.t,\n                orientations=orientations,\n                subitems=inventories,\n            )\n\n        if self.render_mode is None:\n            return\n\n        img = self.get_frame(\n            self.metadata.get(\"highlight\", False),\n            self.tile_size,\n            self.metadata.get(\"agent_pov\", None),\n        )\n\n        if self.render_mode == \"human\":\n            self._renderer.render_human(img, self.cumulative_score, self.render_message)\n        elif self.render_mode == \"rgb_array\":\n            return img\n\n    def close(self):\n        \"\"\"Close the renderer if active.\"\"\"\n        if self._renderer is not None:\n            self._renderer.close()\n\n    def get_action_mask(self, agent_id):\n        \"\"\"Return action mask for the given agent (not implemented).\"\"\"\n        raise NotImplementedError\n\n    @property\n    def agent_ids(self) -&gt; list:\n        \"\"\"Return list of active agent IDs.\"\"\"\n        return list(self.env_agents.keys())\n\n    @property\n    def agent_pos(self) -&gt; list:\n        \"\"\"Return list of agent positions.\"\"\"\n        return [tuple(agent.pos) for agent in self.env_agents.values() if agent is not None]\n\n    def id_to_numeric(self, agent_id) -&gt; str:\n        \"\"\"Convert agent id to its numeric string representation.\n\n        For example, agent-0 -&gt; 1, agent-1 -&gt; 2, etc.\n        \"\"\"\n        agent = self.env_agents[agent_id]\n        return str(agent.agent_number)\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.np_random","title":"<code>np_random</code>  <code>property</code>","text":"<p>Lazily initialize and return the numpy RNG.</p>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.jax_step","title":"<code>jax_step</code>  <code>property</code>","text":"<p>Raw JIT-compiled step function for direct JIT/vmap usage.</p> <p><code>(EnvState, actions) -&gt; (EnvState, obs, rewards, terminateds, truncateds, infos)</code></p>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.jax_reset","title":"<code>jax_reset</code>  <code>property</code>","text":"<p>Raw JIT-compiled reset function for direct JIT/vmap usage.</p> <p><code>(rng_key) -&gt; (EnvState, obs)</code></p>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.map_with_agents","title":"<code>map_with_agents</code>  <code>property</code>","text":"<p>Return the encoded grid with agents overlaid as numeric IDs.</p>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.available_positions","title":"<code>available_positions</code>  <code>property</code>","text":"<p>Return grid cells that are empty and not occupied by an agent.</p>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.agent_ids","title":"<code>agent_ids</code>  <code>property</code>","text":"<p>Return list of active agent IDs.</p>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.agent_pos","title":"<code>agent_pos</code>  <code>property</code>","text":"<p>Return list of agent positions.</p>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.__init__","title":"<code>__init__(config, render_mode=None, agent_class=None, backend='numpy', **kwargs)</code>","text":"<p>Initialize the CoGrid environment.</p> <p>The first environment created sets the global backend; subsequent envs must use the same backend or a RuntimeError is raised.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def __init__(\n    self,\n    config: dict,\n    render_mode: str | None = None,\n    agent_class: agent.Agent | None = None,\n    backend: str = \"numpy\",\n    **kwargs,\n):\n    \"\"\"Initialize the CoGrid environment.\n\n    The first environment created sets the global backend; subsequent\n    envs must use the same backend or a RuntimeError is raised.\n    \"\"\"\n    super().__init__()\n    self._np_random: np.random.Generator | None = None  # set in reset()\n\n    set_backend(backend)\n    self._backend = backend\n    self.config = config\n    self.name = config[\"name\"]\n    self.cumulative_score = 0\n    self.max_steps = config[\"max_steps\"]\n    self.roles = config.get(\"roles\", True)\n    self.agent_class = agent_class or agent.Agent\n    self.t = 0\n\n    if \"features\" not in config or not isinstance(config[\"features\"], list):\n        raise ValueError(\"config['features'] must be a list of feature names.\")\n\n    self._init_rendering(render_mode, kwargs)\n    self._init_grid(config)\n    self._init_agents(config)\n    self._init_action_space(config)\n    self._init_vectorized_infrastructure()\n    self._init_jax_arrays()\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.action_space","title":"<code>action_space(agent)</code>","text":"<p>Return the action space for the given agent.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def action_space(self, agent: typing.AgentID) -&gt; spaces.Space:\n    \"\"\"Return the action space for the given agent.\"\"\"\n    return self.action_spaces[agent]\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.set_terminated_fn","title":"<code>set_terminated_fn(fn)</code>","text":"<p>Set a per-agent termination function.</p> <p>Must be called before the first <code>reset()</code> so the function is closed over by the JIT-compiled step pipeline.</p> <p><code>fn(prev_state, state, reward_config) -&gt; (n_agents,) bool</code></p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def set_terminated_fn(self, fn):\n    \"\"\"Set a per-agent termination function.\n\n    Must be called before the first ``reset()`` so the function\n    is closed over by the JIT-compiled step pipeline.\n\n    ``fn(prev_state, state, reward_config) -&gt; (n_agents,) bool``\n    \"\"\"\n    self._terminated_fn = fn\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.reset","title":"<code>reset(*, seed=42, options=None)</code>","text":"<p>Reset the environment and return initial observations.</p> <p>Builds step/reset pipeline on first call, then delegates to the functional reset.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def reset(\n    self,\n    *,\n    seed: int | None = 42,\n    options: dict[str, typing.Any] | None = None,\n) -&gt; tuple[dict[typing.AgentID, typing.ObsType], dict[str, typing.Any]]:\n    \"\"\"Reset the environment and return initial observations.\n\n    Builds step/reset pipeline on first call, then delegates to\n    the functional reset.\n    \"\"\"\n    self._reset_agents(seed)\n    self._build_state()\n    layout_arrays, spawn_positions, action_set_name = self._build_layout_arrays()\n    obs = self._build_pipeline(layout_arrays, spawn_positions, action_set_name, seed)\n\n    if self.render_mode is not None:\n        self._sync_objects_from_state()\n        self.render()\n\n    return obs, {agent_id: {} for agent_id in self.agent_ids}\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.step","title":"<code>step(actions)</code>","text":"<p>Advance one timestep via the unified step pipeline.</p> <p>Converts dict actions to an ordered array, delegates to <code>self._step_fn</code>, and converts outputs back to PettingZoo dicts.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def step(\n    self, actions: dict[typing.AgentID, typing.ActionType]\n) -&gt; tuple[\n    dict[typing.AgentID, typing.ObsType],\n    dict[typing.AgentID, float],\n    dict[typing.AgentID, bool],\n    dict[typing.AgentID, bool],\n    dict[typing.AgentID, dict[typing.Any, typing.Any]],\n]:\n    \"\"\"Advance one timestep via the unified step pipeline.\n\n    Converts dict actions to an ordered array, delegates to\n    ``self._step_fn``, and converts outputs back to PettingZoo dicts.\n    \"\"\"\n    # Select array module\n    if self._backend == \"jax\":\n        import jax.numpy as jnp\n\n        xp = jnp\n    else:\n        xp = np\n\n    # Convert action dict to ordered array\n    actions_arr = xp.array(\n        [actions[aid] for aid in self._agent_id_order],\n        dtype=xp.int32,\n    )\n\n    # Delegate to the unified step pipeline\n    self._env_state, obs_arr, rewards_arr, terminateds_arr, truncateds_arr, infos = (\n        self._step_fn(self._env_state, actions_arr)\n    )\n\n    # Convert to PettingZoo dict format\n    obs = {aid: np.array(obs_arr[i]) for i, aid in enumerate(self._agent_id_order)}\n    rewards = {aid: float(rewards_arr[i]) for i, aid in enumerate(self._agent_id_order)}\n\n    terminateds = {aid: bool(terminateds_arr[i]) for i, aid in enumerate(self._agent_id_order)}\n    truncateds = {aid: bool(truncateds_arr[i]) for i, aid in enumerate(self._agent_id_order)}\n\n    if any(terminateds.values()) or any(truncateds.values()):\n        self.agents = []\n\n    infos = {aid: {} for aid in self._agent_id_order}\n\n    # Increment PettingZoo timestep counter\n    self.t += 1\n\n    self.cumulative_score += sum(rewards.values())\n\n    # Sync rendering objects from state if needed\n    if self.render_mode is not None:\n        self._sync_objects_from_state()\n        self.render()\n\n    # Custom hook if a subclass wants to make any updates\n    self.on_step()\n\n    return obs, rewards, terminateds, truncateds, infos\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.get_state","title":"<code>get_state()</code>","text":"<p>Export a JSON-serializable snapshot of the full environment state.</p> <p>Returns plain Python lists/scalars suitable for <code>json.dumps()</code>. Restorable via :meth:<code>set_state</code>. Must be called after :meth:<code>reset</code>.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def get_state(self) -&gt; dict:\n    \"\"\"Export a JSON-serializable snapshot of the full environment state.\n\n    Returns plain Python lists/scalars suitable for ``json.dumps()``.\n    Restorable via :meth:`set_state`. Must be called after :meth:`reset`.\n    \"\"\"\n    if self._env_state is None:\n        raise RuntimeError(\"Must call reset() before get_state()\")\n\n    state = self._env_state\n    snapshot = {\n        \"agent_pos\": np.array(state.agent_pos).tolist(),\n        \"agent_dir\": np.array(state.agent_dir).tolist(),\n        \"agent_inv\": np.array(state.agent_inv).tolist(),\n        \"wall_map\": np.array(state.wall_map).tolist(),\n        \"object_type_map\": np.array(state.object_type_map).tolist(),\n        \"object_state_map\": np.array(state.object_state_map).tolist(),\n        \"extra_state\": {k: np.array(v).tolist() for k, v in state.extra_state.items()},\n        \"rng_key\": np.array(state.rng_key).tolist() if state.rng_key is not None else None,\n        \"time\": int(state.time),\n        \"done\": np.array(state.done).tolist(),\n        \"n_agents\": state.n_agents,\n        \"height\": state.height,\n        \"width\": state.width,\n        \"action_set\": state.action_set,\n        \"t\": self.t,\n        \"cumulative_score\": float(self.cumulative_score),\n    }\n    return snapshot\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.set_state","title":"<code>set_state(snapshot)</code>","text":"<p>Restore from a dict produced by :meth:<code>get_state</code>.</p> <p>Must be called after :meth:<code>reset</code> (pipeline must be initialized). Arrays are converted to the active backend's type.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def set_state(self, snapshot: dict) -&gt; None:\n    \"\"\"Restore from a dict produced by :meth:`get_state`.\n\n    Must be called after :meth:`reset` (pipeline must be initialized).\n    Arrays are converted to the active backend's type.\n    \"\"\"\n    if self._step_fn is None:\n        raise RuntimeError(\"Must call reset() before set_state()\")\n\n    from cogrid.backend.env_state import create_env_state\n\n    if self._backend == \"jax\":\n        import jax.numpy as jnp\n\n        xp = jnp\n    else:\n        xp = np\n\n    extra_state = {k: xp.array(v, dtype=xp.int32) for k, v in snapshot[\"extra_state\"].items()}\n\n    rng_key = snapshot[\"rng_key\"]\n    if rng_key is not None:\n        if self._backend == \"jax\":\n            import jax\n\n            rng_key = jax.numpy.array(rng_key, dtype=jax.numpy.uint32)\n        else:\n            rng_key = np.array(rng_key)\n\n    self._env_state = create_env_state(\n        agent_pos=xp.array(snapshot[\"agent_pos\"], dtype=xp.int32),\n        agent_dir=xp.array(snapshot[\"agent_dir\"], dtype=xp.int32),\n        agent_inv=xp.array(snapshot[\"agent_inv\"], dtype=xp.int32),\n        wall_map=xp.array(snapshot[\"wall_map\"], dtype=xp.int32),\n        object_type_map=xp.array(snapshot[\"object_type_map\"], dtype=xp.int32),\n        object_state_map=xp.array(snapshot[\"object_state_map\"], dtype=xp.int32),\n        extra_state=extra_state,\n        rng_key=rng_key,\n        time=xp.int32(snapshot[\"time\"]),\n        done=xp.array(snapshot[\"done\"], dtype=xp.bool_),\n        n_agents=snapshot[\"n_agents\"],\n        height=snapshot[\"height\"],\n        width=snapshot[\"width\"],\n        action_set=snapshot[\"action_set\"],\n    )\n\n    self.t = snapshot[\"t\"]\n    self.cumulative_score = snapshot[\"cumulative_score\"]\n\n    if self.render_mode is not None:\n        self._sync_objects_from_state()\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.update_grid_agents","title":"<code>update_grid_agents()</code>","text":"<p>Update the grid agents to reflect the current state of each Agent.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def update_grid_agents(self) -&gt; None:\n    \"\"\"Update the grid agents to reflect the current state of each Agent.\"\"\"\n    self.grid.grid_agents = {\n        a_id: grid_object.GridAgent(agent, n_agents=self.config[\"num_agents\"], scope=self.scope)\n        for a_id, agent in self.env_agents.items()\n    }\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.setup_agents","title":"<code>setup_agents()</code>","text":"<p>Set up agents using the default agent factory.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def setup_agents(self):\n    \"\"\"Set up agents using the default agent factory.\"\"\"\n    self._setup_agents()\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.on_interact","title":"<code>on_interact(actions)</code>","text":"<p>Hook for subclass logic after agents interact with the environment.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def on_interact(self, actions: dict[typing.AgentID, typing.ActionType]) -&gt; None:\n    \"\"\"Hook for subclass logic after agents interact with the environment.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.on_toggle","title":"<code>on_toggle(agent_id)</code>","text":"<p>Hook for subclass logic after an agent toggles an object.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def on_toggle(self, agent_id: typing.AgentID) -&gt; None:\n    \"\"\"Hook for subclass logic after an agent toggles an object.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.on_pickup_drop","title":"<code>on_pickup_drop(agent_id)</code>","text":"<p>Hook for subclass logic after an agent picks up or drops an object.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def on_pickup_drop(self, agent_id: typing.AgentID) -&gt; None:\n    \"\"\"Hook for subclass logic after an agent picks up or drops an object.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.on_reset","title":"<code>on_reset()</code>","text":"<p>Hook for subclasses to implement custom logic after the environment is reset.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def on_reset(self) -&gt; None:\n    \"\"\"Hook for subclasses to implement custom logic after the environment is reset.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.on_step","title":"<code>on_step()</code>","text":"<p>Hook for subclasses to implement custom logic after each step.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def on_step(self) -&gt; None:\n    \"\"\"Hook for subclasses to implement custom logic after each step.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.on_move","title":"<code>on_move(agent_id)</code>","text":"<p>Hook for subclass logic after an agent moves.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def on_move(self, agent_id: typing.AgentID) -&gt; None:\n    \"\"\"Hook for subclass logic after an agent moves.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.get_infos","title":"<code>get_infos(**kwargs)</code>","text":"<p>Build per-agent info dicts from keyword argument dicts.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def get_infos(self, **kwargs) -&gt; dict[typing.AgentID, dict[typing.Any, typing.Any]]:\n    \"\"\"Build per-agent info dicts from keyword argument dicts.\"\"\"\n    infos = {agent_id: {} for agent_id in self._agent_ids}\n    for info_key, info_dict in kwargs.items():\n        for agent_id, val in info_dict.items():\n            assert agent_id in self._agent_ids, (\n                f\"Must pass dicts keyed by AgentIDs to get_infos(), got invalid key: {agent_id}\"\n            )\n            infos[agent_id][info_key] = val\n    return infos\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.get_empty_reward_dict","title":"<code>get_empty_reward_dict()</code>","text":"<p>Return a reward dict with all agents set to 0.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def get_empty_reward_dict(self) -&gt; dict[typing.AgentID, float]:\n    \"\"\"Return a reward dict with all agents set to 0.\"\"\"\n    return {a_id: 0 for a_id in self.agent_ids}\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.select_spawn_point","title":"<code>select_spawn_point()</code>","text":"<p>Pop a spawn point from the queue, or pick a random free cell.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def select_spawn_point(self) -&gt; tuple[int, int]:\n    \"\"\"Pop a spawn point from the queue, or pick a random free cell.\"\"\"\n    if self.spawn_points:\n        return self.spawn_points.pop(0)\n\n    available_spawns = self.available_positions\n    return self.np_random.choice(available_spawns)\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.put_obj","title":"<code>put_obj(obj, row, col)</code>","text":"<p>Place an object at (row, col) and set its init_pos.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def put_obj(self, obj: grid_object.GridObj, row: int, col: int):\n    \"\"\"Place an object at (row, col) and set its init_pos.\"\"\"\n    self.grid.set(row=row, col=col, obj=obj)\n    obj.pos = (row, col)\n    obj.init_pos = (row, col)\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.get_view_exts","title":"<code>get_view_exts(agent_id, agent_view_size=None)</code>","text":"<p>Return (topX, topY, botX, botY) of the agent's visible tile square.</p> <p>Bottom extent indices are exclusive.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def get_view_exts(\n    self, agent_id: typing.AgentID, agent_view_size: int = None\n) -&gt; tuple[int, int, int, int]:\n    \"\"\"Return (topX, topY, botX, botY) of the agent's visible tile square.\n\n    Bottom extent indices are exclusive.\n    \"\"\"\n    agent = self.env_agents[agent_id]\n    agent_view_size = agent_view_size or self.agent_view_size\n\n    if agent.dir == directions.Directions.Right:\n        topY = agent.pos[0] - agent_view_size // 2\n        topX = agent.pos[1]\n    elif agent.dir == directions.Directions.Down:\n        topY = agent.pos[0]\n        topX = agent.pos[1] - agent_view_size // 2\n    elif agent.dir == directions.Directions.Left:\n        topY = agent.pos[0] - agent_view_size // 2\n        topX = agent.pos[1] - agent_view_size + 1\n    elif agent.dir == directions.Directions.Up:\n        topY = agent.pos[0] - agent_view_size + 1\n        topX = agent.pos[1] - agent_view_size // 2\n    else:\n        raise ValueError(\"Invalid agent direction.\")\n\n    botX = topX + agent_view_size\n    botY = topY + agent_view_size\n\n    return topX, topY, botX, botY\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.gen_obs_grid","title":"<code>gen_obs_grid(agent_id, agent_view_size=None)</code>","text":"<p>Return the rotated sub-grid and visibility mask for an agent's POV.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def gen_obs_grid(self, agent_id: typing.AgentID, agent_view_size: int = None) -&gt; grid.Grid:\n    \"\"\"Return the rotated sub-grid and visibility mask for an agent's POV.\"\"\"\n    topX, topY, *_ = self.get_view_exts(agent_id, agent_view_size)\n\n    agent_view_size = agent_view_size or self.agent_view_size\n\n    grid = self.grid.slice(topX, topY, agent_view_size, agent_view_size)\n\n    assert agent_id in grid.grid_agents\n\n    agent = self.env_agents[agent_id]\n    for i in range(agent.dir + 1):\n        grid = grid.rotate_left()\n\n    if not self.metadata.get(\"see_through_walls\", True):\n        # Mask view from the agents position at the bottom-center of the grid view\n        vis_mask = grid.process_vis(agent_pos=(-1, grid.width // 2))\n    else:\n        vis_mask = np.ones(shape=(grid.height, grid.width), dtype=bool)\n\n    assert len(grid.grid_agents) &gt;= 1\n    assert grid.grid_agents[agent_id].dir == directions.Directions.Up\n\n    # NOTE: In Minigrid, they replace the agent's position with the item\n    #   they're carrying. We don't do that here. Rather, we'll provide an\n    #   additional observation space that represents the item(s) in inventory.\n\n    return grid, vis_mask\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.get_pov_render","title":"<code>get_pov_render(agent_id, tile_size=CoreConstants.TilePixels)</code>","text":"<p>Render a specific agent's POV as an RGB array.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def get_pov_render(\n    self,\n    agent_id: typing.AgentID,\n    tile_size: int = CoreConstants.TilePixels,\n) -&gt; np.ndarray:\n    \"\"\"Render a specific agent's POV as an RGB array.\"\"\"\n    grid, vis_mask = self.gen_obs_grid(agent_id)\n    img = grid.render(\n        tile_size,\n        highlight_mask=vis_mask,\n    )\n    return img\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.get_full_render","title":"<code>get_full_render(highlight=False, tile_size=CoreConstants.TilePixels)</code>","text":"<p>Render the full grid, optionally highlighting each agent's visible region.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def get_full_render(\n    self, highlight: bool = False, tile_size: int = CoreConstants.TilePixels\n) -&gt; np.ndarray:\n    \"\"\"Render the full grid, optionally highlighting each agent's visible region.\"\"\"\n    if highlight:\n        highlight_mask = np.zeros(shape=(self.grid.height, self.grid.width), dtype=bool)\n        for a_id, agent in self.env_agents.items():\n            # Determine cell visibility for the agent\n            _, vis_mask = self.gen_obs_grid(a_id)\n\n            # compute the world coordinates of the bottom-left corner of the agent's view area\n            f_vec = agent.dir_vec\n            r_vec = agent.right_vec\n            top_left = (\n                agent.pos\n                + f_vec * (self.agent_view_size - 1)\n                - r_vec * (self.agent_view_size // 2)\n            )\n\n            # identify the cells to highlight as visible in the render\n            for vis_row in range(self.agent_view_size):\n                for vis_col in range(self.agent_view_size):\n                    if not vis_mask[vis_row, vis_col]:\n                        continue\n\n                    # compute world coordinates of agent view\n                    abs_row, abs_col = top_left - (f_vec * vis_row) + (r_vec * vis_col)\n\n                    if abs_row &lt; 0 or abs_row &gt;= self.grid.height:\n                        continue\n                    if abs_col &lt; 0 or abs_col &gt;= self.grid.width:\n                        continue\n\n                    highlight_mask[abs_row, abs_col] = True\n    else:\n        highlight_mask = None\n\n    img = self.grid.render(tile_size=tile_size, highlight_mask=highlight_mask)\n    return img\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.get_frame","title":"<code>get_frame(highlight=True, tile_size=CoreConstants.TilePixels, agent_pov=None)</code>","text":"<p>Return RGB image of the full environment or a single agent's POV.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def get_frame(\n    self,\n    highlight: bool = True,\n    tile_size: int = CoreConstants.TilePixels,\n    agent_pov: typing.AgentID | None = None,\n) -&gt; np.ndarray:\n    \"\"\"Return RGB image of the full environment or a single agent's POV.\"\"\"\n    if agent_pov:\n        frame = self.get_pov_render(agent_id=self.agent_pov, tile_size=tile_size)\n    else:\n        frame = self.get_full_render(highlight=highlight, tile_size=tile_size)\n\n    return frame\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.render","title":"<code>render()</code>","text":"<p>Render the environment (human window or rgb_array return).</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def render(self) -&gt; None | np.ndarray:\n    \"\"\"Render the environment (human window or rgb_array return).\"\"\"\n    if self.visualizer is not None:\n        orientations = {\n            self.id_to_numeric(a_id): agent.orientation\n            for a_id, agent in self.env_agents.items()\n        }\n        inventories = {\n            self.id_to_numeric(a_id): agent.inventory\n            for a_id, agent in self.env_agents.items()\n            if len(agent.inventory) &gt; 0\n        }\n        self.visualizer.render(\n            self.map_with_agents,\n            self.t,\n            orientations=orientations,\n            subitems=inventories,\n        )\n\n    if self.render_mode is None:\n        return\n\n    img = self.get_frame(\n        self.metadata.get(\"highlight\", False),\n        self.tile_size,\n        self.metadata.get(\"agent_pov\", None),\n    )\n\n    if self.render_mode == \"human\":\n        self._renderer.render_human(img, self.cumulative_score, self.render_message)\n    elif self.render_mode == \"rgb_array\":\n        return img\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.close","title":"<code>close()</code>","text":"<p>Close the renderer if active.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def close(self):\n    \"\"\"Close the renderer if active.\"\"\"\n    if self._renderer is not None:\n        self._renderer.close()\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.get_action_mask","title":"<code>get_action_mask(agent_id)</code>","text":"<p>Return action mask for the given agent (not implemented).</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def get_action_mask(self, agent_id):\n    \"\"\"Return action mask for the given agent (not implemented).\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/cogrid/cogrid_env/#cogrid.cogrid_env.CoGridEnv.id_to_numeric","title":"<code>id_to_numeric(agent_id)</code>","text":"<p>Convert agent id to its numeric string representation.</p> <p>For example, agent-0 -&gt; 1, agent-1 -&gt; 2, etc.</p> Source code in <code>cogrid/cogrid_env.py</code> <pre><code>def id_to_numeric(self, agent_id) -&gt; str:\n    \"\"\"Convert agent id to its numeric string representation.\n\n    For example, agent-0 -&gt; 1, agent-1 -&gt; 2, etc.\n    \"\"\"\n    agent = self.env_agents[agent_id]\n    return str(agent.agent_number)\n</code></pre>"},{"location":"reference/cogrid/constants/","title":"constants","text":""},{"location":"reference/cogrid/constants/#cogrid.constants","title":"<code>cogrid.constants</code>","text":"<p>Grid-level constants (free space, padding, obscured, spawn chars).</p>"},{"location":"reference/cogrid/constants/#cogrid.constants.GridConstants","title":"<code>GridConstants</code>  <code>dataclass</code>","text":"<p>Character constants for grid cell types.</p> Source code in <code>cogrid/constants.py</code> <pre><code>@dataclasses.dataclass\nclass GridConstants:\n    \"\"\"Character constants for grid cell types.\"\"\"\n\n    FreeSpace = \" \"\n    Padding = \"0\"\n    Obscured = \".\"\n    Spawn = \"+\"\n</code></pre>"},{"location":"reference/cogrid/run_interactive/","title":"run_interactive","text":""},{"location":"reference/cogrid/run_interactive/#cogrid.run_interactive","title":"<code>cogrid.run_interactive</code>","text":"<p>Interactive human-play interface using pygame.</p>"},{"location":"reference/cogrid/run_interactive/#cogrid.run_interactive.HumanPlay","title":"<code>HumanPlay</code>","text":"<p>Interactive human-controlled environment player.</p> Source code in <code>cogrid/run_interactive.py</code> <pre><code>class HumanPlay:\n    \"\"\"Interactive human-controlled environment player.\"\"\"\n\n    def __init__(\n        self,\n        env: CoGridEnv,\n        human_agent_id: typing.AgentID = None,\n        seed: int = None,\n    ) -&gt; None:\n        \"\"\"Initialize with environment, human agent ID, and seed.\"\"\"\n        self.env = env\n        self.seed = seed\n        self.closed = False\n        self.human_agent_id = human_agent_id\n        self.obs = None\n        self.cumulative_reward = 0\n\n    def run(self):\n        \"\"\"Run the main game loop until window is closed.\"\"\"\n        self.reset(self.seed)\n        while not self.closed:\n            actions = {agent_id: Actions.Noop for agent_id in self.env.agent_ids}\n\n            for a_id, obs in self.obs.items():\n                if a_id == self.human_agent_id:\n                    continue\n                actions[a_id] = self.env.action_spaces[a_id].sample()\n\n            for event in pygame.event.get():\n                if event.type == pygame.QUIT:\n                    self.env.close()\n                    return\n                if event.type == pygame.KEYDOWN:\n                    event.key = pygame.key.name(int(event.key))\n\n                    if event.key == \"escape\":\n                        self.env.close()\n                        return\n\n                    if event.key == \"backspace\":\n                        self.reset(self.seed)\n                        return\n\n                    if self.human_agent_id is not None and event.key in KEY_TO_ACTION.keys():\n                        actions[self.human_agent_id] = KEY_TO_ACTION[event.key]\n                    else:\n                        print(f\"Invalid action: {event.key}\")\n\n            self.step(actions)\n\n    def step(self, actions: dict[str, Actions]):\n        \"\"\"Execute one step with the given actions.\"\"\"\n        # Convert action enum strings to integer indices\n        action_set = self.env.action_set\n        int_actions = {\n            aid: action_set.index(a) if isinstance(a, str) else int(a) for aid, a in actions.items()\n        }\n        self.obs, rewards, terminateds, truncateds, _ = self.env.step(int_actions)\n        self.cumulative_reward += [*rewards.values()][0]\n\n        if not self.env.agents:\n            print(\"All agents done!\")\n            REWARDS.append(self.cumulative_reward)\n            if len(REWARDS) == 50:\n                print(REWARDS)\n            self.reset(self.seed)\n        else:\n            self.env.render()\n\n    def reset(self, seed):\n        \"\"\"Reset the environment with the given seed.\"\"\"\n        self.obs, _ = self.env.reset(seed=seed)\n        self.cumulative_reward = 0\n        self.env.render()\n</code></pre>"},{"location":"reference/cogrid/run_interactive/#cogrid.run_interactive.HumanPlay.__init__","title":"<code>__init__(env, human_agent_id=None, seed=None)</code>","text":"<p>Initialize with environment, human agent ID, and seed.</p> Source code in <code>cogrid/run_interactive.py</code> <pre><code>def __init__(\n    self,\n    env: CoGridEnv,\n    human_agent_id: typing.AgentID = None,\n    seed: int = None,\n) -&gt; None:\n    \"\"\"Initialize with environment, human agent ID, and seed.\"\"\"\n    self.env = env\n    self.seed = seed\n    self.closed = False\n    self.human_agent_id = human_agent_id\n    self.obs = None\n    self.cumulative_reward = 0\n</code></pre>"},{"location":"reference/cogrid/run_interactive/#cogrid.run_interactive.HumanPlay.run","title":"<code>run()</code>","text":"<p>Run the main game loop until window is closed.</p> Source code in <code>cogrid/run_interactive.py</code> <pre><code>def run(self):\n    \"\"\"Run the main game loop until window is closed.\"\"\"\n    self.reset(self.seed)\n    while not self.closed:\n        actions = {agent_id: Actions.Noop for agent_id in self.env.agent_ids}\n\n        for a_id, obs in self.obs.items():\n            if a_id == self.human_agent_id:\n                continue\n            actions[a_id] = self.env.action_spaces[a_id].sample()\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                self.env.close()\n                return\n            if event.type == pygame.KEYDOWN:\n                event.key = pygame.key.name(int(event.key))\n\n                if event.key == \"escape\":\n                    self.env.close()\n                    return\n\n                if event.key == \"backspace\":\n                    self.reset(self.seed)\n                    return\n\n                if self.human_agent_id is not None and event.key in KEY_TO_ACTION.keys():\n                    actions[self.human_agent_id] = KEY_TO_ACTION[event.key]\n                else:\n                    print(f\"Invalid action: {event.key}\")\n\n        self.step(actions)\n</code></pre>"},{"location":"reference/cogrid/run_interactive/#cogrid.run_interactive.HumanPlay.step","title":"<code>step(actions)</code>","text":"<p>Execute one step with the given actions.</p> Source code in <code>cogrid/run_interactive.py</code> <pre><code>def step(self, actions: dict[str, Actions]):\n    \"\"\"Execute one step with the given actions.\"\"\"\n    # Convert action enum strings to integer indices\n    action_set = self.env.action_set\n    int_actions = {\n        aid: action_set.index(a) if isinstance(a, str) else int(a) for aid, a in actions.items()\n    }\n    self.obs, rewards, terminateds, truncateds, _ = self.env.step(int_actions)\n    self.cumulative_reward += [*rewards.values()][0]\n\n    if not self.env.agents:\n        print(\"All agents done!\")\n        REWARDS.append(self.cumulative_reward)\n        if len(REWARDS) == 50:\n            print(REWARDS)\n        self.reset(self.seed)\n    else:\n        self.env.render()\n</code></pre>"},{"location":"reference/cogrid/run_interactive/#cogrid.run_interactive.HumanPlay.reset","title":"<code>reset(seed)</code>","text":"<p>Reset the environment with the given seed.</p> Source code in <code>cogrid/run_interactive.py</code> <pre><code>def reset(self, seed):\n    \"\"\"Reset the environment with the given seed.\"\"\"\n    self.obs, _ = self.env.reset(seed=seed)\n    self.cumulative_reward = 0\n    self.env.render()\n</code></pre>"},{"location":"reference/cogrid/run_interactive/#cogrid.run_interactive.sample_action_via_softmax","title":"<code>sample_action_via_softmax(logits)</code>","text":"<p>Given logits sample an action via softmax.</p> Source code in <code>cogrid/run_interactive.py</code> <pre><code>def sample_action_via_softmax(logits: np.ndarray) -&gt; int:\n    \"\"\"Given logits sample an action via softmax.\"\"\"\n    action_distribution = special.softmax(logits)\n    action = np.random.choice(np.arange(len(action_distribution)), p=action_distribution)\n    return action\n</code></pre>"},{"location":"reference/cogrid/run_interactive/#cogrid.run_interactive.inference_onnx_model","title":"<code>inference_onnx_model(input_dict, model_path)</code>","text":"<p>Given an input dict and path to an ONNX model, return the model outputs.</p> Source code in <code>cogrid/run_interactive.py</code> <pre><code>def inference_onnx_model(\n    input_dict: dict[str, np.ndarray],\n    model_path: str,\n) -&gt; np.ndarray:\n    \"\"\"Given an input dict and path to an ONNX model, return the model outputs.\"\"\"\n    outputs = ORT_SESSIONS[model_path].run([\"output\"], input_dict)\n    return outputs\n</code></pre>"},{"location":"reference/cogrid/run_interactive/#cogrid.run_interactive.onnx_model_inference_fn","title":"<code>onnx_model_inference_fn(observation, onnx_model_path)</code>","text":"<p>Run inference on an ONNX model and sample an action via softmax.</p> Source code in <code>cogrid/run_interactive.py</code> <pre><code>def onnx_model_inference_fn(observation: dict[str, np.ndarray] | np.ndarray, onnx_model_path: str):\n    \"\"\"Run inference on an ONNX model and sample an action via softmax.\"\"\"\n    # if it's a dictionary observation, the onnx model expects a flattened input array\n    if isinstance(observation, dict):\n        observation = np.hstack(list(observation.values())).reshape((1, -1))\n\n    model_outputs = inference_onnx_model(\n        {\n            \"obs\": observation.astype(np.float32),\n            \"state_ins\": np.array([0.0], dtype=np.float32),  # rllib artifact\n        },\n        model_path=onnx_model_path,\n    )[0].reshape(-1)  # outputs list of a batch. batch size always 1 so index list and reshape\n\n    action = sample_action_via_softmax(model_outputs)\n\n    return action\n</code></pre>"},{"location":"reference/cogrid/run_interactive/#cogrid.run_interactive.load_onnx_policy_fn","title":"<code>load_onnx_policy_fn(onnx_model_path)</code>","text":"<p>Initialize the ORT session and return the string to access it.</p> Source code in <code>cogrid/run_interactive.py</code> <pre><code>def load_onnx_policy_fn(onnx_model_path: str) -&gt; str:\n    \"\"\"Initialize the ORT session and return the string to access it.\"\"\"\n    if ORT_SESSIONS.get(onnx_model_path) is None:\n        ORT_SESSIONS[onnx_model_path] = ort.InferenceSession(onnx_model_path, None)\n\n    return onnx_model_path\n</code></pre>"},{"location":"reference/cogrid/run_interactive/#cogrid.run_interactive.env_creator","title":"<code>env_creator(render_mode=None, render_message='')</code>","text":"<p>Create an Overcooked environment instance.</p> Source code in <code>cogrid/run_interactive.py</code> <pre><code>def env_creator(render_mode: str | None = None, render_message=\"\") -&gt; CoGridEnv:\n    \"\"\"Create an Overcooked environment instance.\"\"\"\n    return registry.make(\n        \"Overcooked-CrampedRoom-V0\",\n        highlight=False,\n        render_mode=render_mode,\n        screen_size=args.screen_size,\n        render_message=render_message,\n    )\n</code></pre>"},{"location":"reference/cogrid/backend/","title":"backend","text":""},{"location":"reference/cogrid/backend/#cogrid.backend","title":"<code>cogrid.backend</code>","text":"<p>cogrid.backend -- Array backend dispatch.</p> <p>Provides a single array API that resolves to numpy or jax.numpy:</p> <pre><code>from cogrid.backend import xp\narr = xp.zeros((3, 3))\n</code></pre> <p>The backend defaults to numpy. Call set_backend('jax') before any other cogrid imports to switch to JAX.</p> <p>The <code>xp</code> name is resolved lazily via <code>__getattr__</code> so that <code>from cogrid.backend import xp</code> always returns the current backend module, even if <code>set_backend()</code> was called after the initial import of this package.</p>"},{"location":"reference/cogrid/backend/#cogrid.backend.get_backend","title":"<code>get_backend()</code>","text":"<p>Return the currently active backend name ('numpy' or 'jax').</p> Source code in <code>cogrid/backend/_dispatch.py</code> <pre><code>def get_backend() -&gt; str:\n    \"\"\"Return the currently active backend name ('numpy' or 'jax').\"\"\"\n    return _backend_name\n</code></pre>"},{"location":"reference/cogrid/backend/#cogrid.backend.set_backend","title":"<code>set_backend(name)</code>","text":"<p>Set the active array backend ('numpy' or 'jax').</p> <p>Must be called before any simulation code accesses <code>xp</code>. Once set, the backend cannot be changed within the same process.</p> Source code in <code>cogrid/backend/_dispatch.py</code> <pre><code>def set_backend(name: str) -&gt; None:\n    \"\"\"Set the active array backend ('numpy' or 'jax').\n\n    Must be called before any simulation code accesses ``xp``. Once set,\n    the backend cannot be changed within the same process.\n    \"\"\"\n    global _backend_name, _backend_set, xp_module\n\n    if _backend_set and name != _backend_name:\n        raise RuntimeError(\n            f\"Backend already set to '{_backend_name}'. \"\n            \"Cannot change backend after first environment creation.\"\n        )\n\n    if name == \"numpy\":\n        xp_module = numpy\n    elif name == \"jax\":\n        try:\n            import jax.numpy as jnp\n\n            xp_module = jnp\n        except ImportError:\n            raise ImportError(\n                \"Backend 'jax' requested but JAX is not installed.\\n\"\n                \"Install JAX with: pip install jax jaxlib\\n\"\n                \"Or use the numpy backend (default): CoGridEnv(config)\"\n            )\n    else:\n        raise ValueError(f\"Unknown backend: {name}. Use 'numpy' or 'jax'.\")\n\n    _backend_set = True\n    _backend_name = name\n</code></pre>"},{"location":"reference/cogrid/backend/array_ops/","title":"array_ops","text":""},{"location":"reference/cogrid/backend/array_ops/#cogrid.backend.array_ops","title":"<code>cogrid.backend.array_ops</code>","text":"<p>Backend-aware array mutation helpers.</p> <p>This is the ONLY module that branches on numpy vs JAX for mutation. All other code uses <code>xp</code> for operations that work identically.</p>"},{"location":"reference/cogrid/backend/array_ops/#cogrid.backend.array_ops.set_at","title":"<code>set_at(arr, idx, value)</code>","text":"<p>Return new array with arr[idx] = value.</p> <p>idx can be a single index, a tuple, or any valid numpy/jax indexing. numpy: copies then assigns. JAX: uses .at[idx].set(value).</p> Source code in <code>cogrid/backend/array_ops.py</code> <pre><code>def set_at(arr, idx, value):\n    \"\"\"Return new array with arr[idx] = value.\n\n    idx can be a single index, a tuple, or any valid numpy/jax indexing.\n    numpy: copies then assigns. JAX: uses .at[idx].set(value).\n    \"\"\"\n    if get_backend() == \"jax\":\n        return arr.at[idx].set(value)\n    out = arr.copy()\n    out[idx] = value\n    return out\n</code></pre>"},{"location":"reference/cogrid/backend/array_ops/#cogrid.backend.array_ops.set_at_2d","title":"<code>set_at_2d(arr, row, col, value)</code>","text":"<p>Return new array with arr[row, col] = value. Convenience wrapper.</p> Source code in <code>cogrid/backend/array_ops.py</code> <pre><code>def set_at_2d(arr, row, col, value):\n    \"\"\"Return new array with arr[row, col] = value. Convenience wrapper.\"\"\"\n    return set_at(arr, (row, col), value)\n</code></pre>"},{"location":"reference/cogrid/backend/env_state/","title":"env_state","text":""},{"location":"reference/cogrid/backend/env_state/#cogrid.backend.env_state","title":"<code>cogrid.backend.env_state</code>","text":"<p>Immutable environment state container.</p> <p>Defines :class:<code>EnvState</code>, a frozen dataclass that bundles all environment state arrays into a single object.  On the numpy backend it is a plain data container; on the JAX backend it is registered as a pytree so it can flow through <code>jax.jit</code>, <code>jax.vmap</code>, etc.</p> <p>State transitions use <code>dataclasses.replace</code>::</p> <pre><code>new_state = dataclasses.replace(state, agent_pos=new_pos)\n</code></pre> <p>Direct attribute assignment is forbidden (frozen=True).</p> <p>The <code>extra_state</code> field holds a dict of scope-specific arrays keyed by scope-prefixed strings (e.g. <code>\"overcooked.pot_contents\"</code>).  This replaces the former pot-specific fields and allows any environment to attach its own state arrays without modifying the core dataclass.</p> <p>Access helpers::</p> <pre><code>from cogrid.backend.env_state import get_extra, replace_extra\n\ntimer = get_extra(state, \"pot_timer\", scope=\"overcooked\")\nstate = replace_extra(state, \"pot_timer\", new_timer, scope=\"overcooked\")\n</code></pre> <p>Usage::</p> <pre><code>from cogrid.backend.env_state import EnvState, create_env_state\n\nstate = create_env_state(\n    agent_pos=np.zeros((2, 2), dtype=np.int32),\n    ...\n    extra_state={\"overcooked.pot_timer\": np.zeros(2, dtype=np.int32)},\n)\n</code></pre>"},{"location":"reference/cogrid/backend/env_state/#cogrid.backend.env_state.EnvState","title":"<code>EnvState</code>  <code>dataclass</code>","text":"<p>Immutable environment state.</p> <p>All dynamic fields are fixed-shape arrays (numpy or JAX depending on the active backend).  Static fields are Python scalars used as compile-time constants under JIT (JAX recompiles for each distinct combination of static values).</p> <p>Dynamic fields (traced through JIT):     agent_pos:        (n_agents, 2) int32 -- row, col positions     agent_dir:        (n_agents,) int32   -- direction enum values     agent_inv:        (n_agents, 1) int32 -- held item type IDs, -1 = empty     wall_map:         (H, W) int32        -- 1 where walls exist     object_type_map:  (H, W) int32        -- object type IDs per cell     object_state_map: (H, W) int32        -- object state per cell     extra_state:      dict[str, array]    -- scope-prefixed env-specific arrays     rng_key:          (2,) uint32 or None -- JAX PRNG key (None on numpy backend)     time:             () int32            -- scalar timestep     done:             (n_agents,) bool    -- True for agents whose episode ended</p> <p>Static fields (compile-time constants, not traced):     n_agents:   int -- number of agents     height:     int -- grid height     width:      int -- grid width     action_set: str -- \"cardinal\" or \"rotation\"</p> Source code in <code>cogrid/backend/env_state.py</code> <pre><code>@dataclass(frozen=True)\nclass EnvState:\n    \"\"\"Immutable environment state.\n\n    All dynamic fields are fixed-shape arrays (numpy or JAX depending on\n    the active backend).  Static fields are Python scalars used as\n    compile-time constants under JIT (JAX recompiles for each distinct\n    combination of static values).\n\n    Dynamic fields (traced through JIT):\n        agent_pos:        (n_agents, 2) int32 -- row, col positions\n        agent_dir:        (n_agents,) int32   -- direction enum values\n        agent_inv:        (n_agents, 1) int32 -- held item type IDs, -1 = empty\n        wall_map:         (H, W) int32        -- 1 where walls exist\n        object_type_map:  (H, W) int32        -- object type IDs per cell\n        object_state_map: (H, W) int32        -- object state per cell\n        extra_state:      dict[str, array]    -- scope-prefixed env-specific arrays\n        rng_key:          (2,) uint32 or None -- JAX PRNG key (None on numpy backend)\n        time:             () int32            -- scalar timestep\n        done:             (n_agents,) bool    -- True for agents whose episode ended\n\n    Static fields (compile-time constants, not traced):\n        n_agents:   int -- number of agents\n        height:     int -- grid height\n        width:      int -- grid width\n        action_set: str -- \"cardinal\" or \"rotation\"\n    \"\"\"\n\n    # --- Dynamic fields (JAX arrays when on jax backend, numpy otherwise) ---\n    agent_pos: object  # (n_agents, 2) int32\n    agent_dir: object  # (n_agents,) int32\n    agent_inv: object  # (n_agents, 1) int32, -1 sentinel for empty\n    wall_map: object  # (H, W) int32\n    object_type_map: object  # (H, W) int32\n    object_state_map: object  # (H, W) int32\n    extra_state: object  # dict[str, array], scope-prefixed keys\n    rng_key: object  # (2,) uint32 JAX PRNG key, or None on numpy\n    time: object  # () int32 scalar timestep\n    done: object  # (n_agents,) bool -- True once terminated/truncated\n\n    # --- Static fields (compile-time constants, not traced) ---\n    n_agents: int = field(metadata=dict(static=True), default=2)\n    height: int = field(metadata=dict(static=True), default=7)\n    width: int = field(metadata=dict(static=True), default=7)\n    action_set: str = field(metadata=dict(static=True), default=\"cardinal\")\n</code></pre>"},{"location":"reference/cogrid/backend/env_state/#cogrid.backend.env_state.register_envstate_pytree","title":"<code>register_envstate_pytree()</code>","text":"<p>Register :class:<code>EnvState</code> as a JAX pytree node.</p> <p>Imports <code>jax.tree_util.register_dataclass</code> and calls it on :class:<code>EnvState</code>.  Safe to call multiple times (idempotent). Must only be called when the JAX backend is active.</p> Source code in <code>cogrid/backend/env_state.py</code> <pre><code>def register_envstate_pytree() -&gt; None:\n    \"\"\"Register :class:`EnvState` as a JAX pytree node.\n\n    Imports ``jax.tree_util.register_dataclass`` and calls it on\n    :class:`EnvState`.  Safe to call multiple times (idempotent).\n    Must only be called when the JAX backend is active.\n    \"\"\"\n    global _pytree_registered\n    if _pytree_registered:\n        return\n\n    import jax.tree_util\n\n    jax.tree_util.register_dataclass(EnvState)\n    _pytree_registered = True\n</code></pre>"},{"location":"reference/cogrid/backend/env_state/#cogrid.backend.env_state.create_env_state","title":"<code>create_env_state(**kwargs)</code>","text":"<p>Create an EnvState, ensuring JAX pytree registration if needed.</p> Source code in <code>cogrid/backend/env_state.py</code> <pre><code>def create_env_state(**kwargs) -&gt; EnvState:\n    \"\"\"Create an EnvState, ensuring JAX pytree registration if needed.\"\"\"\n    from cogrid.backend import get_backend\n\n    if get_backend() == \"jax\":\n        register_envstate_pytree()\n        from cogrid.backend.state_view import register_stateview_pytree\n\n        register_stateview_pytree()\n\n    return EnvState(**kwargs)\n</code></pre>"},{"location":"reference/cogrid/backend/env_state/#cogrid.backend.env_state.get_extra","title":"<code>get_extra(state, key, scope=None)</code>","text":"<p>Get a value from state.extra_state with optional scope prefixing.</p> Source code in <code>cogrid/backend/env_state.py</code> <pre><code>def get_extra(state, key, scope=None):\n    \"\"\"Get a value from state.extra_state with optional scope prefixing.\"\"\"\n    full_key = f\"{scope}.{key}\" if scope else key\n    if full_key not in state.extra_state:\n        raise KeyError(\n            f\"extra_state key '{full_key}' not found. Available: {list(state.extra_state.keys())}\"\n        )\n    return state.extra_state[full_key]\n</code></pre>"},{"location":"reference/cogrid/backend/env_state/#cogrid.backend.env_state.replace_extra","title":"<code>replace_extra(state, key, value, scope=None)</code>","text":"<p>Return new EnvState with one extra_state value replaced.</p> Source code in <code>cogrid/backend/env_state.py</code> <pre><code>def replace_extra(state, key, value, scope=None):\n    \"\"\"Return new EnvState with one extra_state value replaced.\"\"\"\n    full_key = f\"{scope}.{key}\" if scope else key\n    new_extra = {**state.extra_state, full_key: value}\n    return dataclasses.replace(state, extra_state=new_extra)\n</code></pre>"},{"location":"reference/cogrid/backend/env_state/#cogrid.backend.env_state.validate_extra_state","title":"<code>validate_extra_state(extra_state, schema)</code>","text":"<p>Validate extra_state keys/shapes against a schema dict.</p> <p>Schema maps <code>key -&gt; {\"shape\": tuple, \"dtype\": str}</code>. Symbolic dims (strings) are checked for ndim consistency only.</p> Source code in <code>cogrid/backend/env_state.py</code> <pre><code>def validate_extra_state(extra_state, schema):\n    \"\"\"Validate extra_state keys/shapes against a schema dict.\n\n    Schema maps ``key -&gt; {\"shape\": tuple, \"dtype\": str}``. Symbolic\n    dims (strings) are checked for ndim consistency only.\n    \"\"\"\n    for key, spec in schema.items():\n        if key not in extra_state:\n            raise ValueError(f\"Missing required extra_state key: '{key}'\")\n        arr = extra_state[key]\n        expected_ndim = len(spec[\"shape\"])\n        if len(arr.shape) != expected_ndim:\n            raise ValueError(\n                f\"extra_state['{key}'] has {len(arr.shape)} dims, expected {expected_ndim}\"\n            )\n</code></pre>"},{"location":"reference/cogrid/backend/state_view/","title":"state_view","text":""},{"location":"reference/cogrid/backend/state_view/#cogrid.backend.state_view","title":"<code>cogrid.backend.state_view</code>","text":"<p>Dot-accessible view of environment state arrays.</p> <p>:class:<code>StateView</code> is a frozen dataclass that replaces the plain <code>dict</code> returned by :func:<code>~cogrid.core.step_pipeline.envstate_to_dict</code>.  It provides IDE-friendly dot access for the six core fields that every feature / reward / termination function uses, plus <code>__getattr__</code> fallthrough to an <code>extra</code> dict for scope-specific arrays (e.g. <code>state.pot_timer</code>).</p> <p>On the JAX backend the class is registered as a pytree so it flows through <code>jax.jit</code> and <code>jax.vmap</code> without issue.</p> <p>Usage::</p> <pre><code>state = StateView(\n    agent_pos=...,\n    agent_dir=...,\n    agent_inv=...,\n    wall_map=...,\n    object_type_map=...,\n    object_state_map=...,\n    extra={\"pot_timer\": ...},\n)\nstate.agent_pos  # core field  \u2013 full autocomplete\nstate.pot_timer  # extra field \u2013 resolved via __getattr__\nstate.nonexistent  # raises AttributeError\n</code></pre>"},{"location":"reference/cogrid/backend/state_view/#cogrid.backend.state_view.StateView","title":"<code>StateView</code>  <code>dataclass</code>","text":"<p>Immutable, dot-accessible view of environment state arrays.</p> <p>Core fields (IDE-discoverable):     agent_pos:        (n_agents, 2) int32     agent_dir:        (n_agents,)   int32     agent_inv:        (n_agents, 1) int32     wall_map:         (H, W) int32     object_type_map:  (H, W) int32     object_state_map: (H, W) int32</p> <p>Extra fields (scope-specific, resolved via getattr):     Stored in <code>extra</code> dict.  Access as <code>state.&lt;key&gt;</code>.</p> Source code in <code>cogrid/backend/state_view.py</code> <pre><code>@dataclass(frozen=True)\nclass StateView:\n    \"\"\"Immutable, dot-accessible view of environment state arrays.\n\n    Core fields (IDE-discoverable):\n        agent_pos:        (n_agents, 2) int32\n        agent_dir:        (n_agents,)   int32\n        agent_inv:        (n_agents, 1) int32\n        wall_map:         (H, W) int32\n        object_type_map:  (H, W) int32\n        object_state_map: (H, W) int32\n\n    Extra fields (scope-specific, resolved via __getattr__):\n        Stored in ``extra`` dict.  Access as ``state.&lt;key&gt;``.\n    \"\"\"\n\n    agent_pos: object  # (n_agents, 2) int32\n    agent_dir: object  # (n_agents,) int32\n    agent_inv: object  # (n_agents, 1) int32\n    wall_map: object  # (H, W) int32\n    object_type_map: object  # (H, W) int32\n    object_state_map: object  # (H, W) int32\n    extra: dict = field(default_factory=dict)\n\n    def __getattr__(self, name):\n        \"\"\"Look up extra-state fields by name via the extra dict.\"\"\"\n        # Only called for attributes not found by normal lookup.\n        # Frozen dataclass stores fields in __dict__, so core fields\n        # never reach here.\n        try:\n            return self.extra[name]\n        except KeyError:\n            raise AttributeError(f\"StateView has no field '{name}'\")\n</code></pre>"},{"location":"reference/cogrid/backend/state_view/#cogrid.backend.state_view.StateView.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Look up extra-state fields by name via the extra dict.</p> Source code in <code>cogrid/backend/state_view.py</code> <pre><code>def __getattr__(self, name):\n    \"\"\"Look up extra-state fields by name via the extra dict.\"\"\"\n    # Only called for attributes not found by normal lookup.\n    # Frozen dataclass stores fields in __dict__, so core fields\n    # never reach here.\n    try:\n        return self.extra[name]\n    except KeyError:\n        raise AttributeError(f\"StateView has no field '{name}'\")\n</code></pre>"},{"location":"reference/cogrid/backend/state_view/#cogrid.backend.state_view.register_stateview_pytree","title":"<code>register_stateview_pytree()</code>","text":"<p>Register :class:<code>StateView</code> as a JAX pytree node (idempotent).</p> Source code in <code>cogrid/backend/state_view.py</code> <pre><code>def register_stateview_pytree() -&gt; None:\n    \"\"\"Register :class:`StateView` as a JAX pytree node (idempotent).\"\"\"\n    global _stateview_pytree_registered\n    if _stateview_pytree_registered:\n        return\n\n    import jax.tree_util\n\n    jax.tree_util.register_dataclass(StateView)\n    _stateview_pytree_registered = True\n</code></pre>"},{"location":"reference/cogrid/core/","title":"core","text":""},{"location":"reference/cogrid/core/#cogrid.core","title":"<code>cogrid.core</code>","text":"<p>Core environment engine components.</p>"},{"location":"reference/cogrid/core/actions/","title":"actions","text":""},{"location":"reference/cogrid/core/actions/#cogrid.core.actions","title":"<code>cogrid.core.actions</code>","text":"<p>Action definitions and action set groupings.</p>"},{"location":"reference/cogrid/core/actions/#cogrid.core.actions.Actions","title":"<code>Actions</code>  <code>dataclass</code>","text":"<p>Available agent actions (movement, interaction, no-op).</p> Source code in <code>cogrid/core/actions.py</code> <pre><code>@dataclasses.dataclass\nclass Actions:\n    \"\"\"Available agent actions (movement, interaction, no-op).\"\"\"\n\n    # Common\n    PickupDrop = \"pick_up_or_drop\"  # Pick up an object\n    Toggle = \"toggle\"  # Interact with/toggle/activate an object\n    Noop = \"no-op\"\n\n    # Rotation\n    Forward = \"move_forward\"  # Move forward\n    RotateLeft = \"rotate_left\"  # Turn Left\n    RotateRight = \"rotate_right\"  # Turn Right\n\n    # Cardinal Movement\n    MoveLeft = \"move_left\"\n    MoveRight = \"move_right\"\n    MoveUp = \"move_up\"\n    MoveDown = \"move_down\"\n</code></pre>"},{"location":"reference/cogrid/core/actions/#cogrid.core.actions.ActionSets","title":"<code>ActionSets</code>  <code>dataclass</code>","text":"<p>Predefined tuples of actions for rotation and cardinal control modes.</p> Source code in <code>cogrid/core/actions.py</code> <pre><code>@dataclasses.dataclass\nclass ActionSets:\n    \"\"\"Predefined tuples of actions for rotation and cardinal control modes.\"\"\"\n\n    RotationActions = (\n        Actions.Forward,\n        Actions.PickupDrop,\n        Actions.Toggle,\n        Actions.Noop,\n        Actions.RotateLeft,\n        Actions.RotateRight,\n    )\n    CardinalActions = (\n        Actions.MoveUp,\n        Actions.MoveDown,\n        Actions.MoveLeft,\n        Actions.MoveRight,\n        Actions.PickupDrop,\n        Actions.Toggle,\n        Actions.Noop,\n    )\n</code></pre>"},{"location":"reference/cogrid/core/agent/","title":"agent","text":""},{"location":"reference/cogrid/core/agent/#cogrid.core.agent","title":"<code>cogrid.core.agent</code>","text":"<p>Agent class and array-based agent utilities.</p>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.Agent","title":"<code>Agent</code>","text":"<p>A single agent in the environment with position, direction, and inventory.</p> Source code in <code>cogrid/core/agent.py</code> <pre><code>class Agent:\n    \"\"\"A single agent in the environment with position, direction, and inventory.\"\"\"\n\n    def __init__(self, agent_id, start_position, start_direction, **kwargs):\n        \"\"\"Initialize agent with ID, spawn position, and direction.\"\"\"\n        self.id: str = agent_id\n        self.pos: tuple[int, int] = start_position\n        self.dir: Directions = start_direction\n        self.role: str = None\n        self.role_idx: int = None\n        self.inventory_capacity: int = kwargs.get(\"inventory_capacity\", 1)\n\n        self.terminated: bool = False\n\n        self.collision: bool = (\n            False  # Some envs track if an agent crashed into another agent/object\n        )\n\n        self.orientation: str = \"down\"\n        self.inventory: list[GridObj] = []\n        self.cell_toggled: GridObj | None = None\n        self.cell_placed_on: GridObj | None = None\n        self.cell_picked_up_from: GridObj | None = None\n        self.cell_overlapped: GridObj | None = None\n\n    def rotate_left(self):\n        \"\"\"Rotate the agent's direction counter-clockwise.\"\"\"\n        self.dir -= 1\n        if self.dir &lt; 0:\n            self.dir += 4\n\n    def rotate_right(self):\n        \"\"\"Rotate the agent's direction clockwise.\"\"\"\n        self.dir = (self.dir + 1) % 4\n\n    @property\n    def front_pos(self):\n        \"\"\"Return the position directly in front of the agent.\"\"\"\n        return self.pos + self.dir_vec\n\n    @property\n    def dir_vec(self):\n        \"\"\"Return the (delta_row, delta_col) vector for the current direction.\"\"\"\n        dir_to_vec = {\n            Directions.Right: np.array((0, 1)),\n            Directions.Down: np.array((1, 0)),\n            Directions.Left: np.array((0, -1)),\n            Directions.Up: np.array((-1, 0)),\n        }\n        return dir_to_vec[self.dir]\n\n    @property\n    def right_vec(self):\n        \"\"\"Return the vector perpendicular to the right of the agent.\"\"\"\n        dy, dx = self.dir_vec\n        return np.array((dx, -dy))\n\n    def set_orientation(self):\n        \"\"\"Set the orientation string from the current direction.\"\"\"\n        self.orientation = {\n            Directions.Up: \"up\",\n            Directions.Down: \"down\",\n            Directions.Left: \"left\",\n            Directions.Right: \"right\",\n        }[self.dir]\n\n    def can_pickup(self, grid_object: GridObj) -&gt; bool:\n        \"\"\"Return True if the agent has room in inventory.\"\"\"\n        return len(self.inventory) &lt; self.inventory_capacity\n\n    def pick_up_object(self, grid_object: GridObj):\n        \"\"\"Add an object to the agent's inventory.\"\"\"\n        self.inventory.append(grid_object)\n\n    @property\n    def agent_number(self) -&gt; int:\n        \"\"\"Convert agent id to integer, beginning with 1.\n\n        For example, agent-0 -&gt; 1, agent-1 -&gt; 2, etc.\n        \"\"\"\n        return int(self.id[-1]) + 1 if isinstance(self.id, str) else self.id + 1\n</code></pre>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.Agent.front_pos","title":"<code>front_pos</code>  <code>property</code>","text":"<p>Return the position directly in front of the agent.</p>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.Agent.dir_vec","title":"<code>dir_vec</code>  <code>property</code>","text":"<p>Return the (delta_row, delta_col) vector for the current direction.</p>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.Agent.right_vec","title":"<code>right_vec</code>  <code>property</code>","text":"<p>Return the vector perpendicular to the right of the agent.</p>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.Agent.agent_number","title":"<code>agent_number</code>  <code>property</code>","text":"<p>Convert agent id to integer, beginning with 1.</p> <p>For example, agent-0 -&gt; 1, agent-1 -&gt; 2, etc.</p>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.Agent.__init__","title":"<code>__init__(agent_id, start_position, start_direction, **kwargs)</code>","text":"<p>Initialize agent with ID, spawn position, and direction.</p> Source code in <code>cogrid/core/agent.py</code> <pre><code>def __init__(self, agent_id, start_position, start_direction, **kwargs):\n    \"\"\"Initialize agent with ID, spawn position, and direction.\"\"\"\n    self.id: str = agent_id\n    self.pos: tuple[int, int] = start_position\n    self.dir: Directions = start_direction\n    self.role: str = None\n    self.role_idx: int = None\n    self.inventory_capacity: int = kwargs.get(\"inventory_capacity\", 1)\n\n    self.terminated: bool = False\n\n    self.collision: bool = (\n        False  # Some envs track if an agent crashed into another agent/object\n    )\n\n    self.orientation: str = \"down\"\n    self.inventory: list[GridObj] = []\n    self.cell_toggled: GridObj | None = None\n    self.cell_placed_on: GridObj | None = None\n    self.cell_picked_up_from: GridObj | None = None\n    self.cell_overlapped: GridObj | None = None\n</code></pre>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.Agent.rotate_left","title":"<code>rotate_left()</code>","text":"<p>Rotate the agent's direction counter-clockwise.</p> Source code in <code>cogrid/core/agent.py</code> <pre><code>def rotate_left(self):\n    \"\"\"Rotate the agent's direction counter-clockwise.\"\"\"\n    self.dir -= 1\n    if self.dir &lt; 0:\n        self.dir += 4\n</code></pre>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.Agent.rotate_right","title":"<code>rotate_right()</code>","text":"<p>Rotate the agent's direction clockwise.</p> Source code in <code>cogrid/core/agent.py</code> <pre><code>def rotate_right(self):\n    \"\"\"Rotate the agent's direction clockwise.\"\"\"\n    self.dir = (self.dir + 1) % 4\n</code></pre>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.Agent.set_orientation","title":"<code>set_orientation()</code>","text":"<p>Set the orientation string from the current direction.</p> Source code in <code>cogrid/core/agent.py</code> <pre><code>def set_orientation(self):\n    \"\"\"Set the orientation string from the current direction.\"\"\"\n    self.orientation = {\n        Directions.Up: \"up\",\n        Directions.Down: \"down\",\n        Directions.Left: \"left\",\n        Directions.Right: \"right\",\n    }[self.dir]\n</code></pre>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.Agent.can_pickup","title":"<code>can_pickup(grid_object)</code>","text":"<p>Return True if the agent has room in inventory.</p> Source code in <code>cogrid/core/agent.py</code> <pre><code>def can_pickup(self, grid_object: GridObj) -&gt; bool:\n    \"\"\"Return True if the agent has room in inventory.\"\"\"\n    return len(self.inventory) &lt; self.inventory_capacity\n</code></pre>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.Agent.pick_up_object","title":"<code>pick_up_object(grid_object)</code>","text":"<p>Add an object to the agent's inventory.</p> Source code in <code>cogrid/core/agent.py</code> <pre><code>def pick_up_object(self, grid_object: GridObj):\n    \"\"\"Add an object to the agent's inventory.\"\"\"\n    self.inventory.append(grid_object)\n</code></pre>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.get_dir_vec_table","title":"<code>get_dir_vec_table()</code>","text":"<p>Return the (4, 2) direction vector lookup table, creating it lazily.</p> <p>The table is indexed by the direction integer (Right=0, Down=1, Left=2, Up=3). Each row is <code>[delta_row, delta_col]</code>, matching the existing <code>Agent.dir_vec</code> property.</p> Source code in <code>cogrid/core/agent.py</code> <pre><code>def get_dir_vec_table():\n    \"\"\"Return the (4, 2) direction vector lookup table, creating it lazily.\n\n    The table is indexed by the direction integer (Right=0, Down=1, Left=2,\n    Up=3). Each row is ``[delta_row, delta_col]``, matching the existing\n    ``Agent.dir_vec`` property.\n    \"\"\"\n    global DIR_VEC_TABLE\n    if DIR_VEC_TABLE is None:\n        DIR_VEC_TABLE = xp.array(\n            [\n                [0, 1],  # Right (0) -- increase col\n                [1, 0],  # Down  (1) -- increase row\n                [0, -1],  # Left  (2) -- decrease col\n                [-1, 0],  # Up    (3) -- decrease row\n            ],\n            dtype=xp.int32,\n        )\n    return DIR_VEC_TABLE\n</code></pre>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.create_agent_arrays","title":"<code>create_agent_arrays(env_agents, scope='global')</code>","text":"<p>Convert Agent objects to parallel arrays (pos, dir, inv).</p> <p>Returns dict with <code>agent_pos</code> (n_agents, 2), <code>agent_dir</code> (n_agents,), <code>agent_inv</code> (n_agents, 1) with -1 sentinel for empty, <code>agent_ids</code>, and <code>n_agents</code>. Agents are sorted by ID for deterministic ordering.</p> Source code in <code>cogrid/core/agent.py</code> <pre><code>def create_agent_arrays(env_agents: dict, scope: str = \"global\") -&gt; dict:\n    \"\"\"Convert Agent objects to parallel arrays (pos, dir, inv).\n\n    Returns dict with ``agent_pos`` (n_agents, 2), ``agent_dir`` (n_agents,),\n    ``agent_inv`` (n_agents, 1) with -1 sentinel for empty, ``agent_ids``,\n    and ``n_agents``. Agents are sorted by ID for deterministic ordering.\n    \"\"\"\n    import numpy as _np\n\n    from cogrid.core.grid_object import object_to_idx\n\n    # Sort by agent_id for deterministic array ordering\n    sorted_items = sorted(env_agents.items(), key=lambda x: x[0])\n    n_agents = len(sorted_items)\n\n    # Always use numpy for mutable agent array construction.\n    # Callers convert to JAX arrays when needed.\n    agent_pos = _np.zeros((n_agents, 2), dtype=_np.int32)\n    agent_dir = _np.zeros((n_agents,), dtype=_np.int32)\n    agent_inv = _np.full((n_agents, 1), -1, dtype=_np.int32)\n    agent_ids = []\n\n    for i, (a_id, agent) in enumerate(sorted_items):\n        agent_ids.append(a_id)\n        agent_pos[i, 0] = agent.pos[0]\n        agent_pos[i, 1] = agent.pos[1]\n        agent_dir[i] = int(agent.dir)\n\n        if len(agent.inventory) &gt; 0:\n            agent_inv[i, 0] = object_to_idx(agent.inventory[0].object_id, scope=scope)\n\n    return {\n        \"agent_pos\": agent_pos,\n        \"agent_dir\": agent_dir,\n        \"agent_inv\": agent_inv,\n        \"agent_ids\": agent_ids,\n        \"n_agents\": n_agents,\n    }\n</code></pre>"},{"location":"reference/cogrid/core/agent/#cogrid.core.agent.sync_arrays_to_agents","title":"<code>sync_arrays_to_agents(agent_arrays, env_agents)</code>","text":"<p>Write array-state pos/dir back to Agent objects (inverse of create_agent_arrays).</p> Source code in <code>cogrid/core/agent.py</code> <pre><code>def sync_arrays_to_agents(agent_arrays: dict, env_agents: dict) -&gt; None:\n    \"\"\"Write array-state pos/dir back to Agent objects (inverse of create_agent_arrays).\"\"\"\n    sorted_items = sorted(env_agents.items(), key=lambda x: x[0])\n\n    for i, (a_id, agent) in enumerate(sorted_items):\n        agent.pos = (\n            int(agent_arrays[\"agent_pos\"][i, 0]),\n            int(agent_arrays[\"agent_pos\"][i, 1]),\n        )\n        agent.dir = int(agent_arrays[\"agent_dir\"][i])\n</code></pre>"},{"location":"reference/cogrid/core/autowire/","title":"autowire","text":""},{"location":"reference/cogrid/core/autowire/#cogrid.core.autowire","title":"<code>cogrid.core.autowire</code>","text":"<p>Auto-wire scope and reward configuration from component registries.</p> <p>Reads component metadata populated by <code>@register_object_type</code> and <code>@register_reward_type</code> and produces complete <code>scope_config</code> and <code>reward_config</code> dicts matching the shapes consumed by <code>step_pipeline.step()</code>, <code>layout_parser.parse_layout()</code>, and <code>interactions.process_interactions()</code>.</p> <p>Composes scope_config, reward_config, and feature_config automatically from registered components. This is the sole environment configuration path.</p>"},{"location":"reference/cogrid/core/autowire/#cogrid.core.autowire.build_feature_config_from_components","title":"<code>build_feature_config_from_components(scope, feature_names, n_agents, layout_idx=0)</code>","text":"<p>Build feature_config from registered Feature subclasses.</p> <p>Composes features listed in feature_names into a single <code>feature_fn(state, agent_idx) -&gt; (obs_dim,) float32</code>.</p> Source code in <code>cogrid/core/autowire.py</code> <pre><code>def build_feature_config_from_components(\n    scope: str,\n    feature_names: list[str],\n    n_agents: int,\n    layout_idx: int = 0,\n) -&gt; dict:\n    \"\"\"Build feature_config from registered Feature subclasses.\n\n    Composes features listed in *feature_names* into a single\n    ``feature_fn(state, agent_idx) -&gt; (obs_dim,) float32``.\n    \"\"\"\n    # Ensure global Feature subclasses are registered\n    import cogrid.feature_space.features  # noqa: F401\n    from cogrid.core.component_registry import get_pre_compose_hook\n    from cogrid.core.features import compose_feature_fns, obs_dim_for_features\n\n    # Run scope-specific pre-compose hook (e.g. set layout index state\n    # before feature closures capture it).\n    pre_hook = get_pre_compose_hook(scope)\n    if pre_hook is not None:\n        pre_hook(layout_idx=layout_idx, scope=scope)\n\n    lookup_scopes = [scope, \"global\"]\n\n    composed_fn = compose_feature_fns(\n        feature_names,\n        scope,\n        n_agents,\n        scopes=lookup_scopes,\n        preserve_order=True,\n    )\n\n    total_dim = obs_dim_for_features(\n        feature_names,\n        scope,\n        n_agents,\n        scopes=lookup_scopes,\n    )\n\n    return {\n        \"feature_fn\": composed_fn,\n        \"obs_dim\": total_dim,\n        \"feature_names\": feature_names,\n    }\n</code></pre>"},{"location":"reference/cogrid/core/autowire/#cogrid.core.autowire.build_scope_config_from_components","title":"<code>build_scope_config_from_components(scope, *, tick_handler=None, interaction_tables=None, state_extractor=None)</code>","text":"<p>Build a complete scope_config from registered component metadata.</p> <p>Assembles type_ids, symbol_table, extra_state_schema, static_tables, tick_handler, and render_sync automatically from GridObject classmethods registered in the given scope (plus global).</p> <p>Pass-through kwargs override auto-composed handlers.</p> Source code in <code>cogrid/core/autowire.py</code> <pre><code>def build_scope_config_from_components(\n    scope: str,\n    *,\n    tick_handler=None,\n    interaction_tables=None,\n    state_extractor=None,\n) -&gt; dict:\n    \"\"\"Build a complete scope_config from registered component metadata.\n\n    Assembles type_ids, symbol_table, extra_state_schema, static_tables,\n    tick_handler, and render_sync automatically from GridObject classmethods\n    registered in the given scope (plus global).\n\n    Pass-through kwargs override auto-composed handlers.\n    \"\"\"\n    from cogrid.core.component_registry import (\n        get_all_components,\n        get_components_with_extra_state,\n        get_tickable_components,\n    )\n    from cogrid.core.grid_object import (\n        build_lookup_tables,\n        get_object_names,\n        object_to_idx,\n    )\n\n    # -- Collect all components for this scope (reused below) --\n    all_components = get_all_components(scope)\n\n    # -- type_ids: map object names to integer indices --\n    type_ids = {\n        name: object_to_idx(name, scope)\n        for name in get_object_names(scope=scope)\n        if name is not None\n    }\n\n    # -- symbol_table: char -&gt; {\"object_id\": str, ...} --\n    symbol_table = _build_symbol_table(scope, get_all_components)\n\n    # -- extra_state_schema: merged from all components, scope-prefixed, sorted --\n    extra_state_schema = _build_extra_state_schema(scope, get_components_with_extra_state)\n\n    # -- static_tables: CAN_PICKUP, CAN_OVERLAP, etc. from build_lookup_tables --\n    static_tables = build_lookup_tables(scope=scope)\n\n    # -- Compose tick_handler from tickable components (if not overridden) --\n    if tick_handler is None:\n        tickable = get_tickable_components(scope)\n        if len(tickable) == 1:\n            tick_handler = tickable[0].methods[\"build_tick_fn\"]()\n        elif len(tickable) &gt; 1:\n            tick_fns = [m.methods[\"build_tick_fn\"]() for m in tickable]\n\n            def _composed_tick(state, scope_config, _fns=tick_fns):\n                for fn in _fns:\n                    state = fn(state, scope_config)\n                return state\n\n            tick_handler = _composed_tick\n\n    # -- Compose extra_state_builder from components --\n    extra_state_builder = None\n    builders = [m for m in all_components if \"extra_state_builder\" in m.methods]\n    if builders:\n        builder_fns = [m.methods[\"extra_state_builder\"]() for m in builders]\n        if len(builder_fns) == 1:\n            extra_state_builder = builder_fns[0]\n        else:\n\n            def _composed_builder(parsed_arrays, scope=scope, _fns=builder_fns):\n                merged = {}\n                for fn in _fns:\n                    merged.update(fn(parsed_arrays, scope))\n                return merged\n\n            extra_state_builder = _composed_builder\n\n    # -- Merge component-specific static_tables --\n    for meta in all_components:\n        if meta.has_static_tables:\n            extra_tables = meta.methods[\"build_static_tables\"]()\n            static_tables.update(extra_tables)\n\n    # -- Compose render_sync from components (global + scope) --\n    render_sync = None\n    global_renderers = [m for m in get_all_components(\"global\") if m.has_render_sync]\n    scope_renderers = [m for m in all_components if m.has_render_sync] if scope != \"global\" else []\n    all_renderers = global_renderers + scope_renderers\n    if all_renderers:\n        render_fns = [m.methods[\"build_render_sync_fn\"]() for m in all_renderers]\n        if len(render_fns) == 1:\n            render_sync = render_fns[0]\n        else:\n\n            def _composed_render_sync(grid, env_state, scope, _fns=render_fns):\n                for fn in _fns:\n                    fn(grid, env_state, scope)\n\n            render_sync = _composed_render_sync\n\n    return {\n        \"scope\": scope,\n        \"interaction_tables\": interaction_tables,\n        \"type_ids\": type_ids,\n        \"state_extractor\": state_extractor,\n        \"tick_handler\": tick_handler,\n        \"static_tables\": static_tables,\n        \"symbol_table\": symbol_table,\n        \"extra_state_schema\": extra_state_schema,\n        \"extra_state_builder\": extra_state_builder,\n        \"render_sync\": render_sync,\n    }\n</code></pre>"},{"location":"reference/cogrid/core/autowire/#cogrid.core.autowire.build_reward_config_from_components","title":"<code>build_reward_config_from_components(scope, n_agents, type_ids, action_pickup_drop_idx=4)</code>","text":"<p>Build reward_config from registered Reward subclasses.</p> <p>Composes a single <code>compute_fn</code> that sums all registered rewards. Each reward's <code>compute()</code> returns final (n_agents,) float32 values -- the composition layer just sums them.</p> Source code in <code>cogrid/core/autowire.py</code> <pre><code>def build_reward_config_from_components(\n    scope: str,\n    n_agents: int,\n    type_ids: dict,\n    action_pickup_drop_idx: int = 4,\n) -&gt; dict:\n    \"\"\"Build reward_config from registered Reward subclasses.\n\n    Composes a single ``compute_fn`` that sums all registered rewards.\n    Each reward's ``compute()`` returns final (n_agents,) float32 values --\n    the composition layer just sums them.\n    \"\"\"\n    from cogrid.core.component_registry import get_reward_types\n\n    # Collect reward metadata from scope-specific and global registries\n    reward_metas = get_reward_types(scope)\n    if scope != \"global\":\n        reward_metas = reward_metas + get_reward_types(\"global\")\n\n    instances = [meta.cls() for meta in reward_metas]\n\n    def compute_fn(prev_state, state, actions, reward_config):\n        \"\"\"Composed reward function that sums all registered rewards.\"\"\"\n        total = xp.zeros(n_agents, dtype=xp.float32)\n        for inst in instances:\n            total = total + inst.compute(prev_state, state, actions, reward_config)\n        return total\n\n    return {\n        \"compute_fn\": compute_fn,\n        \"type_ids\": type_ids,\n        \"n_agents\": n_agents,\n        \"action_pickup_drop_idx\": action_pickup_drop_idx,\n    }\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/","title":"component_registry","text":""},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry","title":"<code>cogrid.core.component_registry</code>","text":"<p>Component metadata registry for GridObject, Reward, and Feature type registration.</p> <p>Stores metadata about GridObject subclasses (discovered classmethods, static properties), Reward subclasses, and Feature subclasses. Populated at import time by the <code>@register_object_type</code>, <code>@register_reward_type</code>, and <code>@register_feature_type</code> decorators.</p> <p>This module must NOT import from <code>cogrid.core.grid_object</code> at module level to avoid circular imports. The decorator in grid_object.py uses a lazy import to call into this module.</p>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.ComponentMetadata","title":"<code>ComponentMetadata</code>  <code>dataclass</code>","text":"<p>Metadata for a registered GridObject subclass.</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>@dataclass(frozen=True)\nclass ComponentMetadata:\n    \"\"\"Metadata for a registered GridObject subclass.\"\"\"\n\n    scope: str\n    object_id: str\n    cls: type\n    char: str\n    properties: dict[str, bool]\n    methods: dict[str, Any] = field(default_factory=dict)\n\n    @property\n    def has_tick(self) -&gt; bool:\n        \"\"\"True if this component provides a tick function.\"\"\"\n        return \"build_tick_fn\" in self.methods\n\n    @property\n    def has_extra_state(self) -&gt; bool:\n        \"\"\"True if this component defines extra state schema.\"\"\"\n        return \"extra_state_schema\" in self.methods\n\n    @property\n    def has_static_tables(self) -&gt; bool:\n        \"\"\"True if this component provides static lookup tables.\"\"\"\n        return \"build_static_tables\" in self.methods\n\n    @property\n    def has_render_sync(self) -&gt; bool:\n        \"\"\"True if this component provides a render sync function.\"\"\"\n        return \"build_render_sync_fn\" in self.methods\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.ComponentMetadata.has_tick","title":"<code>has_tick</code>  <code>property</code>","text":"<p>True if this component provides a tick function.</p>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.ComponentMetadata.has_extra_state","title":"<code>has_extra_state</code>  <code>property</code>","text":"<p>True if this component defines extra state schema.</p>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.ComponentMetadata.has_static_tables","title":"<code>has_static_tables</code>  <code>property</code>","text":"<p>True if this component provides static lookup tables.</p>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.ComponentMetadata.has_render_sync","title":"<code>has_render_sync</code>  <code>property</code>","text":"<p>True if this component provides a render sync function.</p>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.RewardMetadata","title":"<code>RewardMetadata</code>  <code>dataclass</code>","text":"<p>Metadata for a registered Reward subclass.</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>@dataclass(frozen=True)\nclass RewardMetadata:\n    \"\"\"Metadata for a registered Reward subclass.\"\"\"\n\n    scope: str\n    reward_id: str\n    cls: type\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.FeatureMetadata","title":"<code>FeatureMetadata</code>  <code>dataclass</code>","text":"<p>Metadata for a registered Feature subclass.</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>@dataclass(frozen=True)\nclass FeatureMetadata:\n    \"\"\"Metadata for a registered Feature subclass.\"\"\"\n\n    scope: str\n    feature_id: str\n    cls: type\n    per_agent: bool\n    obs_dim: int\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.register_component_metadata","title":"<code>register_component_metadata(scope, object_id, cls, properties, methods)</code>","text":"<p>Store :class:<code>ComponentMetadata</code> for a GridObject subclass.</p> <p>Called by the <code>@register_object_type</code> decorator. This function only stores metadata -- it does NOT validate completeness (e.g. schema without builder is allowed).</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def register_component_metadata(\n    scope: str,\n    object_id: str,\n    cls: type,\n    properties: dict[str, bool],\n    methods: dict[str, Any],\n) -&gt; None:\n    \"\"\"Store :class:`ComponentMetadata` for a GridObject subclass.\n\n    Called by the ``@register_object_type`` decorator. This function only\n    stores metadata -- it does NOT validate completeness (e.g. schema\n    without builder is allowed).\n    \"\"\"\n    meta = ComponentMetadata(\n        scope=scope,\n        object_id=object_id,\n        cls=cls,\n        char=cls.char,\n        properties=properties,\n        methods=methods,\n    )\n    _COMPONENT_METADATA[(scope, object_id)] = meta\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.register_reward_type","title":"<code>register_reward_type(reward_id, scope='global')</code>","text":"<p>Decorator that registers a Reward subclass.</p> <p>Usage::</p> <pre><code>@register_reward_type(\"delivery\", scope=\"overcooked\")\nclass DeliveryReward(Reward):\n    def compute(self, prev_state, state, actions, reward_config):\n        ...\n        return rewards  # (n_agents,) float32\n</code></pre> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def register_reward_type(\n    reward_id: str,\n    scope: str = \"global\",\n):\n    \"\"\"Decorator that registers a Reward subclass.\n\n    Usage::\n\n        @register_reward_type(\"delivery\", scope=\"overcooked\")\n        class DeliveryReward(Reward):\n            def compute(self, prev_state, state, actions, reward_config):\n                ...\n                return rewards  # (n_agents,) float32\n    \"\"\"\n\n    def decorator(cls):\n        # Must have a compute method\n        if not hasattr(cls, \"compute\") or not callable(getattr(cls, \"compute\")):\n            raise TypeError(\n                f\"{cls.__name__} must define a callable 'compute' method \"\n                f\"to be registered as a reward type.\"\n            )\n\n        _validate_reward_compute_signature(cls)\n\n        key = (scope, reward_id)\n        if key in _REWARD_TYPE_REGISTRY:\n            existing = _REWARD_TYPE_REGISTRY[key]\n            # Allow re-registration from module reload (same class name and\n            # module). Reject genuinely different classes claiming the same ID.\n            same_class = existing.cls.__name__ == cls.__name__ and getattr(\n                existing.cls, \"__module__\", None\n            ) == getattr(cls, \"__module__\", None)\n            if not same_class:\n                raise ValueError(\n                    f\"Duplicate reward type '{reward_id}' in scope '{scope}': \"\n                    f\"{existing.cls.__name__} and {cls.__name__}\"\n                )\n\n        _REWARD_TYPE_REGISTRY[key] = RewardMetadata(\n            scope=scope,\n            reward_id=reward_id,\n            cls=cls,\n        )\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.register_feature_type","title":"<code>register_feature_type(feature_id, scope='global')</code>","text":"<p>Decorator that registers a Feature subclass.</p> <p>Usage::</p> <pre><code>@register_feature_type(\"agent_dir\", scope=\"global\")\nclass AgentDir(Feature):\n    per_agent = True\n    obs_dim = 4\n\n    @classmethod\n    def build_feature_fn(cls, scope): ...\n</code></pre> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def register_feature_type(feature_id: str, scope: str = \"global\"):\n    \"\"\"Decorator that registers a Feature subclass.\n\n    Usage::\n\n        @register_feature_type(\"agent_dir\", scope=\"global\")\n        class AgentDir(Feature):\n            per_agent = True\n            obs_dim = 4\n\n            @classmethod\n            def build_feature_fn(cls, scope): ...\n    \"\"\"\n\n    def decorator(cls):\n        # Validate cls has per_agent (bool) and obs_dim (int) class attributes\n        if not hasattr(cls, \"per_agent\") or not isinstance(cls.per_agent, bool):\n            raise TypeError(f\"{cls.__name__} must define 'per_agent' as a bool class attribute.\")\n        if not hasattr(cls, \"obs_dim\") or not isinstance(cls.obs_dim, int):\n            raise TypeError(f\"{cls.__name__} must define 'obs_dim' as an int class attribute.\")\n\n        # Validate build_feature_fn exists and has correct signature\n        if not hasattr(cls, \"build_feature_fn\") or not callable(getattr(cls, \"build_feature_fn\")):\n            raise TypeError(\n                f\"{cls.__name__} must define a callable 'build_feature_fn' classmethod.\"\n            )\n\n        # Feature.build_feature_fn takes (cls, scope) -- validate the\n        # scope parameter directly (not via _EXPECTED_SIGNATURES which holds\n        # the old GridObject convention of no params).\n        sig = inspect.signature(cls.build_feature_fn)\n        actual = list(sig.parameters.keys())\n        if actual != [\"scope\"]:\n            raise TypeError(\n                f\"{cls.__name__}.build_feature_fn() has params {actual}, \"\n                f\"expected ['scope']. \"\n                f\"Ensure it is a @classmethod with signature \"\n                f\"def build_feature_fn(cls, scope).\"\n            )\n\n        # Check for duplicate registration\n        key = (scope, feature_id)\n        if key in _FEATURE_TYPE_REGISTRY:\n            existing = _FEATURE_TYPE_REGISTRY[key]\n            same_class = existing.cls.__name__ == cls.__name__ and getattr(\n                existing.cls, \"__module__\", None\n            ) == getattr(cls, \"__module__\", None)\n            if not same_class:\n                raise ValueError(\n                    f\"Duplicate feature type '{feature_id}' in scope '{scope}': \"\n                    f\"{existing.cls.__name__} and {cls.__name__}\"\n                )\n\n        _FEATURE_TYPE_REGISTRY[key] = FeatureMetadata(\n            scope=scope,\n            feature_id=feature_id,\n            cls=cls,\n            per_agent=cls.per_agent,\n            obs_dim=cls.obs_dim,\n        )\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.get_component_metadata","title":"<code>get_component_metadata(object_id, scope='global')</code>","text":"<p>Look up component metadata by (scope, object_id). Returns None if not found.</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def get_component_metadata(object_id: str, scope: str = \"global\") -&gt; ComponentMetadata | None:\n    \"\"\"Look up component metadata by (scope, object_id). Returns None if not found.\"\"\"\n    return _COMPONENT_METADATA.get((scope, object_id))\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.get_all_components","title":"<code>get_all_components(scope='global')</code>","text":"<p>Return all ComponentMetadata entries for scope, sorted by object_id.</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def get_all_components(scope: str = \"global\") -&gt; list[ComponentMetadata]:\n    \"\"\"Return all ComponentMetadata entries for *scope*, sorted by object_id.\"\"\"\n    return sorted(\n        [m for m in _COMPONENT_METADATA.values() if m.scope == scope],\n        key=lambda m: m.object_id,\n    )\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.get_reward_types","title":"<code>get_reward_types(scope='global')</code>","text":"<p>Return all RewardMetadata entries for scope, sorted by reward_id.</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def get_reward_types(scope: str = \"global\") -&gt; list[RewardMetadata]:\n    \"\"\"Return all RewardMetadata entries for *scope*, sorted by reward_id.\"\"\"\n    return sorted(\n        [m for m in _REWARD_TYPE_REGISTRY.values() if m.scope == scope],\n        key=lambda m: m.reward_id,\n    )\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.get_feature_types","title":"<code>get_feature_types(scope='global')</code>","text":"<p>Return all FeatureMetadata entries for scope, sorted by feature_id.</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def get_feature_types(scope: str = \"global\") -&gt; list[FeatureMetadata]:\n    \"\"\"Return all FeatureMetadata entries for *scope*, sorted by feature_id.\"\"\"\n    return sorted(\n        [m for m in _FEATURE_TYPE_REGISTRY.values() if m.scope == scope],\n        key=lambda m: m.feature_id,\n    )\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.get_tickable_components","title":"<code>get_tickable_components(scope='global')</code>","text":"<p>Return components that have a <code>build_tick_fn</code> classmethod.</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def get_tickable_components(scope: str = \"global\") -&gt; list[ComponentMetadata]:\n    \"\"\"Return components that have a ``build_tick_fn`` classmethod.\"\"\"\n    return [m for m in get_all_components(scope) if m.has_tick]\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.get_components_with_extra_state","title":"<code>get_components_with_extra_state(scope='global')</code>","text":"<p>Return components that have an <code>extra_state_schema</code> classmethod.</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def get_components_with_extra_state(scope: str = \"global\") -&gt; list[ComponentMetadata]:\n    \"\"\"Return components that have an ``extra_state_schema`` classmethod.\"\"\"\n    return [m for m in get_all_components(scope) if m.has_extra_state]\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.register_pre_compose_hook","title":"<code>register_pre_compose_hook(scope, hook)</code>","text":"<p>Register a hook called before feature composition.</p> <p><code>hook(layout_idx: int, scope: str) -&gt; None</code></p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def register_pre_compose_hook(scope: str, hook: callable) -&gt; None:\n    \"\"\"Register a hook called before feature composition.\n\n    ``hook(layout_idx: int, scope: str) -&gt; None``\n    \"\"\"\n    _PRE_COMPOSE_HOOKS[scope] = hook\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.get_pre_compose_hook","title":"<code>get_pre_compose_hook(scope)</code>","text":"<p>Return the registered pre-compose hook for scope, or None.</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def get_pre_compose_hook(scope: str) -&gt; callable | None:\n    \"\"\"Return the registered pre-compose hook for *scope*, or None.\"\"\"\n    return _PRE_COMPOSE_HOOKS.get(scope)\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.register_layout_indices","title":"<code>register_layout_indices(scope, layout_map)</code>","text":"<p>Register a layout-name-to-index mapping for a scope.</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def register_layout_indices(scope: str, layout_map: dict[str, int]) -&gt; None:\n    \"\"\"Register a layout-name-to-index mapping for a scope.\"\"\"\n    _LAYOUT_INDEX_REGISTRY[scope] = dict(layout_map)\n</code></pre>"},{"location":"reference/cogrid/core/component_registry/#cogrid.core.component_registry.get_layout_index","title":"<code>get_layout_index(scope, layout_id)</code>","text":"<p>Return the integer index for layout_id in scope, or 0.</p> <p>Returns 0 if layout_id is None, scope has no registered mapping, or layout_id is not found in the mapping.</p> Source code in <code>cogrid/core/component_registry.py</code> <pre><code>def get_layout_index(scope: str, layout_id: str | None) -&gt; int:\n    \"\"\"Return the integer index for *layout_id* in *scope*, or 0.\n\n    Returns 0 if *layout_id* is None, *scope* has no registered mapping,\n    or *layout_id* is not found in the mapping.\n    \"\"\"\n    if layout_id is None:\n        return 0\n    mapping = _LAYOUT_INDEX_REGISTRY.get(scope)\n    if mapping is None:\n        return 0\n    return mapping.get(layout_id, 0)\n</code></pre>"},{"location":"reference/cogrid/core/constants/","title":"constants","text":""},{"location":"reference/cogrid/core/constants/#cogrid.core.constants","title":"<code>cogrid.core.constants</code>","text":"<p>Core rendering and color constants.</p>"},{"location":"reference/cogrid/core/constants/#cogrid.core.constants.CoreConstants","title":"<code>CoreConstants</code>  <code>dataclass</code>","text":"<p>Core rendering constants.</p> Source code in <code>cogrid/core/constants.py</code> <pre><code>@dataclasses.dataclass\nclass CoreConstants:\n    \"\"\"Core rendering constants.\"\"\"\n\n    TilePixels = 32\n</code></pre>"},{"location":"reference/cogrid/core/constants/#cogrid.core.constants.Colors","title":"<code>Colors</code>  <code>dataclass</code>","text":"<p>RGB color palette for grid objects.</p> Source code in <code>cogrid/core/constants.py</code> <pre><code>@dataclasses.dataclass\nclass Colors:\n    \"\"\"RGB color palette for grid objects.\"\"\"\n\n    Red = [255, 0, 0]\n    Green = [0, 255, 0]\n    Blue = [0, 0, 255]\n    Purple = [112, 39, 195]\n    Yellow = [255, 255, 0]\n    Grey = [100, 100, 100]\n    DarkGrey = [70, 70, 70]\n    LightBrown = [181, 132, 0]\n    PukeGreen = [191, 155, 0]\n    Brown = [143, 106, 35]\n    Cyan = [0, 234, 255]\n    Lavender = [220, 185, 237]\n    YellowGrey = [231, 233, 185]\n    LightPink = [237, 185, 185]\n    Orange = [245, 130, 200]\n    PaleBlue = [0, 0, 127]\n    White = [255, 255, 255]\n    Black = [0, 0, 0]\n</code></pre>"},{"location":"reference/cogrid/core/constants/#cogrid.core.constants.ObjectColors","title":"<code>ObjectColors</code>  <code>dataclass</code>","text":"<p>Per-agent color assignments.</p> Source code in <code>cogrid/core/constants.py</code> <pre><code>@dataclasses.dataclass\nclass ObjectColors:\n    \"\"\"Per-agent color assignments.\"\"\"\n\n    AgentOne = Colors.Cyan\n    AgentTwo = Colors.Lavender\n    AgentThree = Colors.YellowGrey\n    AgentFour = Colors.PukeGreen\n    AgentFive = Colors.LightPink\n    AgentSix = Colors.Orange\n    AgentSeven = Colors.PaleBlue\n    AgentEight = Colors.Blue\n    AgentNine = Colors.LightBrown\n</code></pre>"},{"location":"reference/cogrid/core/directions/","title":"directions","text":""},{"location":"reference/cogrid/core/directions/#cogrid.core.directions","title":"<code>cogrid.core.directions</code>","text":"<p>Cardinal direction enumeration.</p>"},{"location":"reference/cogrid/core/directions/#cogrid.core.directions.Directions","title":"<code>Directions</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Cardinal direction enum (Right=0, Down=1, Left=2, Up=3).</p> Source code in <code>cogrid/core/directions.py</code> <pre><code>class Directions(IntEnum):\n    \"\"\"Cardinal direction enum (Right=0, Down=1, Left=2, Up=3).\"\"\"\n\n    Right = 0\n    Down = 1\n    Left = 2\n    Up = 3\n</code></pre>"},{"location":"reference/cogrid/core/features/","title":"features","text":""},{"location":"reference/cogrid/core/features/#cogrid.core.features","title":"<code>cogrid.core.features</code>","text":"<p>Feature base class for feature components.</p> <p>Each feature is a subclass with class attributes <code>per_agent</code> and <code>obs_dim</code>, and a <code>build_feature_fn</code> classmethod that returns a pure function.</p> <p>Per-agent features: <code>fn(state, agent_idx) -&gt; ndarray</code> Global features: <code>fn(state) -&gt; ndarray</code></p> <p>Feature composition is handled by <code>compose_feature_fns()</code> in this module.</p> <p>Environment-specific features live in their respective envs/ modules.</p>"},{"location":"reference/cogrid/core/features/#cogrid.core.features.Feature","title":"<code>Feature</code>","text":"<p>Base class for feature extractors.</p> Subclasses MUST define <ul> <li><code>per_agent</code>: bool class attribute. True if feature is per-agent,   False if global.</li> <li><code>obs_dim</code>: int class attribute. Dimensionality of the feature   output after ravel().</li> <li><code>build_feature_fn(cls, scope)</code>: classmethod that returns a pure   function. For per_agent=True: fn(state, agent_idx) -&gt; ndarray.   For per_agent=False: fn(state) -&gt; ndarray.</li> </ul> <p><code>state</code> is a :class:<code>~cogrid.backend.state_view.StateView</code> \u2014 a frozen dataclass with dot access for core fields (<code>agent_pos</code>, <code>agent_dir</code>, etc.) and <code>__getattr__</code> fallthrough for extras.</p> <p>Usage::</p> <pre><code>@register_feature_type(\"agent_dir\", scope=\"global\")\nclass AgentDir(Feature):\n    per_agent = True\n    obs_dim = 4\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        def fn(state, agent_idx):\n            from cogrid.backend import xp\n\n            return (xp.arange(4) == state.agent_dir[agent_idx]).astype(xp.int32)\n\n        return fn\n</code></pre> Source code in <code>cogrid/core/features.py</code> <pre><code>class Feature:\n    \"\"\"Base class for feature extractors.\n\n    Subclasses MUST define:\n        - ``per_agent``: bool class attribute. True if feature is per-agent,\n          False if global.\n        - ``obs_dim``: int class attribute. Dimensionality of the feature\n          output after ravel().\n        - ``build_feature_fn(cls, scope)``: classmethod that returns a pure\n          function. For per_agent=True: fn(state, agent_idx) -&gt; ndarray.\n          For per_agent=False: fn(state) -&gt; ndarray.\n\n    ``state`` is a :class:`~cogrid.backend.state_view.StateView` \u2014\n    a frozen dataclass with dot access for core fields (``agent_pos``,\n    ``agent_dir``, etc.) and ``__getattr__`` fallthrough for extras.\n\n    Usage::\n\n        @register_feature_type(\"agent_dir\", scope=\"global\")\n        class AgentDir(Feature):\n            per_agent = True\n            obs_dim = 4\n\n            @classmethod\n            def build_feature_fn(cls, scope):\n                def fn(state, agent_idx):\n                    from cogrid.backend import xp\n\n                    return (xp.arange(4) == state.agent_dir[agent_idx]).astype(xp.int32)\n\n                return fn\n    \"\"\"\n\n    per_agent: bool\n    obs_dim: int\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build and return the feature extraction function.\n\n        Must return ``fn(state, agent_idx) -&gt; ndarray`` for per-agent\n        features, or ``fn(state) -&gt; ndarray`` for global features.\n        \"\"\"\n        raise NotImplementedError(\n            f\"{cls.__name__}.build_feature_fn() is not implemented. \"\n            f\"Subclasses must override build_feature_fn().\"\n        )\n</code></pre>"},{"location":"reference/cogrid/core/features/#cogrid.core.features.Feature.build_feature_fn","title":"<code>build_feature_fn(scope)</code>  <code>classmethod</code>","text":"<p>Build and return the feature extraction function.</p> <p>Must return <code>fn(state, agent_idx) -&gt; ndarray</code> for per-agent features, or <code>fn(state) -&gt; ndarray</code> for global features.</p> Source code in <code>cogrid/core/features.py</code> <pre><code>@classmethod\ndef build_feature_fn(cls, scope):\n    \"\"\"Build and return the feature extraction function.\n\n    Must return ``fn(state, agent_idx) -&gt; ndarray`` for per-agent\n    features, or ``fn(state) -&gt; ndarray`` for global features.\n    \"\"\"\n    raise NotImplementedError(\n        f\"{cls.__name__}.build_feature_fn() is not implemented. \"\n        f\"Subclasses must override build_feature_fn().\"\n    )\n</code></pre>"},{"location":"reference/cogrid/core/features/#cogrid.core.features.obs_dim_for_features","title":"<code>obs_dim_for_features(feature_names, scope, n_agents, scopes=None)</code>","text":"<p>Compute total observation dimension for a list of feature names.</p> <p>Per-agent features contribute <code>obs_dim * n_agents</code> (one block per agent in ego-centric order). Global features contribute <code>obs_dim</code> once.</p> Source code in <code>cogrid/core/features.py</code> <pre><code>def obs_dim_for_features(feature_names, scope, n_agents, scopes=None):\n    \"\"\"Compute total observation dimension for a list of feature names.\n\n    Per-agent features contribute ``obs_dim * n_agents`` (one block per\n    agent in ego-centric order). Global features contribute ``obs_dim`` once.\n    \"\"\"\n    meta_by_id = _resolve_feature_metas(feature_names, scope, scopes=scopes)\n\n    total = 0\n    for name in feature_names:\n        meta = meta_by_id[name]\n        if meta.per_agent:\n            total += meta.obs_dim * n_agents\n        else:\n            total += meta.obs_dim\n    return total\n</code></pre>"},{"location":"reference/cogrid/core/features/#cogrid.core.features.compose_feature_fns","title":"<code>compose_feature_fns(feature_names, scope, n_agents, scopes=None, preserve_order=False)</code>","text":"<p>Compose registered features into a single ego-centric observation function.</p> <p>Concatenation order:</p> <ol> <li>Focal agent's per-agent features</li> <li>Other agents' per-agent features (ascending index, skipping focal)</li> <li>Global features</li> </ol> <p>By default, names within each group are sorted alphabetically. Set <code>preserve_order=True</code> to keep the caller-provided order.</p> <p>Returns <code>fn(state, agent_idx) -&gt; (obs_dim,) float32</code>.</p> Source code in <code>cogrid/core/features.py</code> <pre><code>def compose_feature_fns(feature_names, scope, n_agents, scopes=None, preserve_order=False):\n    \"\"\"Compose registered features into a single ego-centric observation function.\n\n    Concatenation order:\n\n    1. Focal agent's per-agent features\n    2. Other agents' per-agent features (ascending index, skipping focal)\n    3. Global features\n\n    By default, names within each group are sorted alphabetically.\n    Set ``preserve_order=True`` to keep the caller-provided order.\n\n    Returns ``fn(state, agent_idx) -&gt; (obs_dim,) float32``.\n    \"\"\"\n    meta_by_id = _resolve_feature_metas(feature_names, scope, scopes=scopes)\n\n    # Separate per-agent and global\n    if preserve_order:\n        per_agent_names = [n for n in feature_names if meta_by_id[n].per_agent]\n        global_names = [n for n in feature_names if not meta_by_id[n].per_agent]\n    else:\n        per_agent_names = sorted(n for n in feature_names if meta_by_id[n].per_agent)\n        global_names = sorted(n for n in feature_names if not meta_by_id[n].per_agent)\n\n    # Build feature functions once at compose time (not per call)\n    per_agent_fns = [meta_by_id[name].cls.build_feature_fn(scope) for name in per_agent_names]\n    global_fns = [meta_by_id[name].cls.build_feature_fn(scope) for name in global_names]\n\n    def composed_fn(state, agent_idx):\n        parts = []\n\n        # 1. Focal agent's per-agent features\n        for fn in per_agent_fns:\n            parts.append(fn(state, agent_idx).ravel().astype(xp.float32))\n\n        # 2. Other agents in ascending index order (skip focal)\n        for i in range(n_agents):\n            if i == agent_idx:\n                continue\n            for fn in per_agent_fns:\n                parts.append(fn(state, i).ravel().astype(xp.float32))\n\n        # 3. Global features\n        for fn in global_fns:\n            parts.append(fn(state).ravel().astype(xp.float32))\n\n        return xp.concatenate(parts)\n\n    return composed_fn\n</code></pre>"},{"location":"reference/cogrid/core/grid/","title":"grid","text":""},{"location":"reference/cogrid/core/grid/#cogrid.core.grid","title":"<code>cogrid.core.grid</code>","text":"<p>Grid representation derived from Minigrid.</p> <p>See https://github.com/Farama-Foundation/Minigrid/minigrid/core/grid.py</p>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid","title":"<code>Grid</code>","text":"<p>The Grid class is a 2D HxW grid of GridObjs.</p> <p>:param height: Height of the grid. :type height: int :param width: Width of the grid. :type width: int</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>class Grid:\n    \"\"\"The Grid class is a 2D HxW grid of GridObjs.\n\n    :param height: Height of the grid.\n    :type height: int\n    :param width: Width of the grid.\n    :type width: int\n    \"\"\"\n\n    tile_cache: dict[tuple[Any], Any] = {}\n\n    def __init__(self, height: int, width: int):\n        \"\"\"Generator method for Grid class.\"\"\"\n        assert height &gt;= 3 and width &gt;= 3, \"Both dimensions must be &gt;= 3.\"\n\n        self.height: int = height\n        self.width: int = width\n\n        self.grid: list[GridObj | None] = [None] * (height * width)\n        self.grid_agents: dict[str, GridAgent] = {}\n\n    def __contains__(self, item: Any) -&gt; bool:\n        \"\"\"Check if an item is in the grid.\n\n        :param item: The item to check for.\n        :type item: Any\n        :return: Whether the item is in the grid.\n        :rtype: bool\n        \"\"\"\n        if isinstance(item, GridObj):\n            for grid_obj in self.grid:\n                if grid_obj is item:\n                    return True\n        return False\n\n    def __eq__(self, other_grid: Grid) -&gt; bool:\n        \"\"\"Check if two grids are equal.\n\n        :param other_grid: The other grid to compare.\n        :type other_grid: Grid\n        :return: Whether the two grids are equal.\n        :rtype: bool\n        \"\"\"\n        g1 = self.encode()\n        g2 = other_grid.encode()\n        return np.array_equal(g1, g2)\n\n    def __ne__(self, other: Grid) -&gt; bool:\n        \"\"\"Check if two grids are not equal.\n\n        :param other: The other grid to compare.\n        :type other: Grid\n        :return: Whether the two grids are not equal.\n        :rtype: bool\n        \"\"\"\n        return not self == other\n\n    def copy(self) -&gt; Grid:\n        \"\"\"Return a deep copy of the grid.\n\n        :return: A deep copy of the grid.\n        :rtype: Grid\n        \"\"\"\n        return deepcopy(self)\n\n    def set(self, row: int, col: int, obj: GridObj | None) -&gt; None:\n        \"\"\"Set a GridObj at a given position in the grid.\n\n        :param row: The row index.\n        :type row: int\n        :param col: The column index.\n        :type col: int\n        :param obj: The GridObj (or None) to set.\n        :type obj: GridObj | None\n        \"\"\"\n        assert 0 &lt;= col &lt; self.width, f\"column index {col} outside of grid of width {self.width}\"\n        assert 0 &lt;= row &lt; self.height, f\"row index {row} outside of grid of height {self.height}\"\n        self.grid[row * self.width + col] = obj\n\n    def get(self, row: int, col: int) -&gt; GridObj | None:\n        \"\"\"Get the GridObj at a given position in the grid.\n\n        :param row: The row index.\n        :type row: int\n        :param col: The column index.\n        :type col: int\n        :return: The GridObj at the given position, if any.\n        :rtype: GridObj | None\n        \"\"\"\n        assert 0 &lt;= col &lt; self.width, f\"column index {col} outside of grid of width {self.width}\"\n        assert 0 &lt;= row &lt; self.height, f\"row index {row} outside of grid of height {self.height}\"\n        assert self.grid is not None\n        return self.grid[row * self.width + col]\n\n    def tick(self):\n        \"\"\"Advance all GridObjs by one timestep.\"\"\"\n        for grid_obj in self.grid:\n            if grid_obj is not None:\n                grid_obj.tick()\n\n    def horz_wall(\n        self,\n        col: int,\n        row: int,\n        length: int | None = None,\n        obj_type: GridObj = Wall,\n    ) -&gt; None:\n        \"\"\"Create a horizontal wall of obj_type in the grid.\n\n        :param col: The column index.\n        :type col: int\n        :param row: The row index.\n        :type row: int\n        :param length: The length of the wall, defaults to maximum.\n        :type length: int | None, optional\n        :param obj_type: GridObj to construct a wall from, defaults to Wall.\n        :type obj_type: Callable[[], GridObj], optional\n        \"\"\"\n        if length is None:\n            length = self.width - col\n        for i in range(length):\n            self.set(row=row, col=col + i, obj=obj_type())\n\n    def vert_wall(\n        self,\n        col: int,\n        row: int,\n        length: int | None = None,\n        obj_type: GridObj = Wall,\n    ) -&gt; None:\n        \"\"\"Create a vertical wall of obj_type in the grid.\n\n        :param col: The column index.\n        :type col: int\n        :param row: The row index.\n        :type row: int\n        :param length: The length of the wall, defaults to maximum.\n        :type length: int | None, optional\n        :param obj_type: GridObj to construct a wall from, defaults to Wall\n        :type obj_type: Callable[[], GridObj], optional\n        \"\"\"\n        if length is None:\n            length = self.height - row\n        for j in range(length):\n            self.set(row=row + j, col=col, obj=obj_type())\n\n    def wall_rect(self, col: int, row: int, w: int, h: int, grid_obj: GridObj = Wall):\n        \"\"\"Create a rectangle of walls in the grid.\n\n        :param col: Initial column index.\n        :type col: int\n        :param row: Initial row index.\n        :type row: int\n        :param w: Width of the rectangle.\n        :type w: int\n        :param h: Height of the rectangle.\n        :type h: int\n        :param grid_obj: GridObj to construct a wall from, defaults to Wall.\n        :type grid_obj: GridObj, optional\n        \"\"\"\n        self.horz_wall(row=row, col=col, length=w, obj_type=grid_obj)\n        self.horz_wall(row=row, col=col + h - 1, length=w, obj_type=grid_obj)\n        self.vert_wall(row=row, col=col, length=h, obj_type=grid_obj)\n        self.vert_wall(row=row + w - 1, col=col, length=h, obj_type=grid_obj)\n\n    def rotate_left(self) -&gt; Grid:\n        \"\"\"Rotate the grid to the left (counter-clockwise).\"\"\"\n        grid = Grid(width=self.height, height=self.width)\n\n        for col in range(self.width):\n            for row in range(self.height):\n                v = self.get(row=row, col=col)\n                if v:\n                    v.rotate_left()\n\n                new_row = grid.height - 1 - col\n                new_col = row\n                grid.set(row=new_row, col=new_col, obj=v)\n\n                agent = get_grid_agent_at_position(self, (row, col))\n                if agent:\n                    rotated_agent = deepcopy(agent)\n                    rotated_agent.rotate_left()\n                    rotated_agent.pos = (new_row, new_col)\n                    grid.grid_agents[rotated_agent.agent_id] = rotated_agent\n\n        return grid\n\n    def slice(self, topX: int, topY: int, width: int, height: int) -&gt; Grid:\n        \"\"\"Get a subset of the grid.\"\"\"\n        grid = Grid(height=height, width=width)\n        for row in range(height):\n            for col in range(width):\n                x = topX + col\n                y = topY + row\n                if 0 &lt;= x &lt; self.width and 0 &lt;= y &lt; self.height:\n                    v = self.get(row=y, col=x)\n\n                    agent = get_grid_agent_at_position(grid=self, position=(y, x))\n                    if agent is not None:\n                        grid_slice_agent = deepcopy(agent)\n                        grid_slice_agent.pos = (row, col)\n                        grid.grid_agents[grid_slice_agent.agent_id] = grid_slice_agent\n                else:\n                    v = Wall()\n\n                grid.set(row=row, col=col, obj=v)\n\n        return grid\n\n    def render_tile(\n        self,\n        obj: GridObj | None,\n        highlight: bool = False,\n        position: tuple[int, int] | None = None,\n        tile_size: int = CoreConstants.TilePixels,\n        subdivs: int = 3,\n    ) -&gt; np.ndarray:\n        \"\"\"Render a tile and cache the result.\n\n        :param obj: The GridObj to render on the tile, defaults to None.\n        :type obj: GridObj | None\n        :param highlight: If the cell should be highlighted, defaults to False\n        :type highlight: bool, optional\n        :param position: Position of the GridObj (useful for retrieving GridAgent), defaults to None\n        :type position: tuple[int, int] | None, optional\n        :param tile_size: Rendered size of the tile, defaults to CoreConstants.TilePixels\n        :type tile_size: int, optional\n        :param subdivs: Number of sub-divisions of the tile, defaults to 3\n        :type subdivs: int, optional\n        :return: An RGB image of the rendered tile.\n        :rtype: np.ndarray\n        \"\"\"\n        grid_agent = get_grid_agent_at_position(grid=self, position=position)\n        agent_dir = grid_agent.dir if grid_agent else None\n        agent_color = grid_agent.agent_id if grid_agent else None\n        agent_inventory_names = (\n            tuple([obj.object_id for obj in grid_agent.inventory]) if grid_agent else None\n        )\n        key: tuple[Any, ...] = (\n            (agent_dir, agent_color, agent_inventory_names),\n            highlight,\n            tile_size,\n        )\n        key = obj.encode() + key if obj else key\n\n        if key in self.__class__.tile_cache:\n            return self.__class__.tile_cache[key]\n\n        tile_img = np.zeros(shape=(tile_size * subdivs, tile_size * subdivs, 3), dtype=np.uint8)\n\n        # Draw grid lines (separating each tile)\n        fill_coords(tile_img, point_in_rect(0, 0.031, 0, 1), (100, 100, 100))\n        fill_coords(tile_img, point_in_rect(0, 1, 0, 0.031), (100, 100, 100))\n\n        # Render the object itself onto the tile\n        if obj is not None:\n            obj.render(tile_img)\n\n        if grid_agent is not None:\n            grid_agent.render(tile_img)\n\n        if highlight:\n            highlight_img(tile_img)\n\n        tile_img = downsample(tile_img, subdivs)\n\n        # Cache the rendered tile\n        self.__class__.tile_cache[key] = tile_img\n\n        return tile_img\n\n    def render(\n        self,\n        tile_size: int,\n        highlight_mask: np.ndarray | None = None,\n    ) -&gt; np.ndarray:\n        \"\"\"Render a tile and cache the result.\n\n        :param tile_size: The size of the tile (pixels).\n        :type tile_size: int\n        :param highlight_mask: Array mask to indicate which cells are highlighted, defaults to None\n        :type highlight_mask: np.ndarray | None, optional\n        :return: An RGB image of the rendered grid.\n        :rtype: np.ndarray\n        \"\"\"\n        if highlight_mask is None:\n            highlight_mask = np.zeros(shape=(self.width, self.height), dtype=bool)\n\n        # Compute total size\n        width_px = self.width * tile_size\n        height_px = self.height * tile_size\n\n        img = np.zeros(shape=(height_px, width_px, 3), dtype=np.uint8)\n\n        # render the grid\n        assert highlight_mask is not None\n        for row in range(self.height):\n            for col in range(self.width):\n                cell = self.get(row=row, col=col)\n\n                tile_img = self.render_tile(\n                    cell,\n                    highlight=highlight_mask.T[row, col],\n                    position=(row, col),\n                    tile_size=tile_size,\n                )\n                ymin = row * tile_size\n                ymax = (row + 1) * tile_size\n                xmin = col * tile_size\n                xmax = (col + 1) * tile_size\n\n                img[ymin:ymax, xmin:xmax, :] = tile_img\n\n        return img\n\n    def encode(\n        self,\n        vis_mask: np.ndarray | None = None,\n        encode_char=False,\n        scope: str = \"global\",\n    ) -&gt; np.ndarray:\n        \"\"\"Produce an ASCII/int representation of the grid.\"\"\"\n        if vis_mask is None:\n            vis_mask = np.ones((self.height, self.width), dtype=bool)\n\n        array = np.empty((self.height, self.width, 3), dtype=object)\n\n        assert vis_mask is not None\n        for col in range(self.width):\n            for row in range(self.height):\n                if not vis_mask[row, col]:\n                    continue\n\n                v = self.get(row=row, col=col)\n                if v is None:\n                    encoding = (\n                        (\n                            GridConstants.FreeSpace\n                            if encode_char\n                            else object_to_idx(None, scope=scope)\n                        ),\n                        0,\n                        0,\n                    )\n                else:\n                    encoding = v.encode(encode_char=encode_char, scope=scope)\n\n                array[row, col] = encoding\n\n        for grid_agent in self.grid_agents.values():\n            row, col = grid_agent.pos\n            array[row, col] = grid_agent.encode(encode_char=encode_char)\n\n        if not encode_char:\n            array = array.astype(np.int8)\n\n        return array\n\n    @staticmethod\n    def decode(array: np.ndarray, scope: str = \"global\") -&gt; tuple[Grid, np.ndarray]:\n        \"\"\"Decode ASCII encoding back into a Grid.\"\"\"\n        channels, height, width = array.shape\n        assert channels == 2\n\n        vis_mask = np.ones(shape=(height, width), dtype=bool)\n\n        grid = Grid(height=height, width=width)\n        agent_count = 0\n        for col in range(width):\n            for row in range(height):\n                char, state = array[:, row, col]\n                state = int(float(state))\n                v = GridObj.decode(char, state, scope=scope)\n                if v:\n                    v.pos = v.init_pos = (row, col)\n                    vis_mask[row, col] = v.visible()\n\n                if isinstance(v, GridAgent):\n                    grid.grid_agents[agent_count] = v\n                    agent_count += 1\n                else:\n                    grid.set(row=row, col=col, obj=v)\n\n        return grid, vis_mask\n\n    def get_obj_count(self, grid_obj: GridObj | None) -&gt; int:\n        \"\"\"Get the number of a particular object that exists in the grid.\n\n        :param grid_obj: The GridObj to count.\n        :type grid_obj: GridObj | None\n        :return: The number of the GridObj in the grid.\n        :rtype: int\n        \"\"\"\n        count = 0\n        for obj in self.grid:\n            if isinstance(obj, grid_obj):\n                count += 1\n        return count\n\n    def process_vis(self, agent_pos: tuple[int, int]) -&gt; np.ndarray:\n        \"\"\"Compute visibility mask from the agent's position.\"\"\"\n        mask = np.zeros(shape=(self.width, self.height), dtype=bool)\n\n        mask[agent_pos[1], agent_pos[0]] = True\n\n        for j in reversed(range(0, self.height)):\n            for i in range(0, self.width - 1):\n                if not mask[i, j]:\n                    continue\n\n                cell = self.get(j, i)\n                if cell and not cell.see_behind():\n                    continue\n\n                mask[i + 1, j] = True\n                if j &gt; 0:\n                    mask[i + 1, j - 1] = True\n                    mask[i, j - 1] = True\n\n            for i in reversed(range(1, self.width)):\n                if not mask[i, j]:\n                    continue\n\n                cell = self.get(j, i)\n                if cell and not cell.see_behind():\n                    continue\n\n                mask[i - 1, j] = True\n                if j &gt; 0:\n                    mask[i - 1, j - 1] = True\n                    mask[i, j - 1] = True\n\n        for j in range(0, self.height):\n            for i in range(0, self.width):\n                if not mask[i, j]:\n                    self.set(j, i, None)\n\n        mask = np.transpose(mask, axes=(1, 0))\n        return mask\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.__init__","title":"<code>__init__(height, width)</code>","text":"<p>Generator method for Grid class.</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def __init__(self, height: int, width: int):\n    \"\"\"Generator method for Grid class.\"\"\"\n    assert height &gt;= 3 and width &gt;= 3, \"Both dimensions must be &gt;= 3.\"\n\n    self.height: int = height\n    self.width: int = width\n\n    self.grid: list[GridObj | None] = [None] * (height * width)\n    self.grid_agents: dict[str, GridAgent] = {}\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.__contains__","title":"<code>__contains__(item)</code>","text":"<p>Check if an item is in the grid.</p> <p>:param item: The item to check for. :type item: Any :return: Whether the item is in the grid. :rtype: bool</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def __contains__(self, item: Any) -&gt; bool:\n    \"\"\"Check if an item is in the grid.\n\n    :param item: The item to check for.\n    :type item: Any\n    :return: Whether the item is in the grid.\n    :rtype: bool\n    \"\"\"\n    if isinstance(item, GridObj):\n        for grid_obj in self.grid:\n            if grid_obj is item:\n                return True\n    return False\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.__eq__","title":"<code>__eq__(other_grid)</code>","text":"<p>Check if two grids are equal.</p> <p>:param other_grid: The other grid to compare. :type other_grid: Grid :return: Whether the two grids are equal. :rtype: bool</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def __eq__(self, other_grid: Grid) -&gt; bool:\n    \"\"\"Check if two grids are equal.\n\n    :param other_grid: The other grid to compare.\n    :type other_grid: Grid\n    :return: Whether the two grids are equal.\n    :rtype: bool\n    \"\"\"\n    g1 = self.encode()\n    g2 = other_grid.encode()\n    return np.array_equal(g1, g2)\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.__ne__","title":"<code>__ne__(other)</code>","text":"<p>Check if two grids are not equal.</p> <p>:param other: The other grid to compare. :type other: Grid :return: Whether the two grids are not equal. :rtype: bool</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def __ne__(self, other: Grid) -&gt; bool:\n    \"\"\"Check if two grids are not equal.\n\n    :param other: The other grid to compare.\n    :type other: Grid\n    :return: Whether the two grids are not equal.\n    :rtype: bool\n    \"\"\"\n    return not self == other\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.copy","title":"<code>copy()</code>","text":"<p>Return a deep copy of the grid.</p> <p>:return: A deep copy of the grid. :rtype: Grid</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def copy(self) -&gt; Grid:\n    \"\"\"Return a deep copy of the grid.\n\n    :return: A deep copy of the grid.\n    :rtype: Grid\n    \"\"\"\n    return deepcopy(self)\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.set","title":"<code>set(row, col, obj)</code>","text":"<p>Set a GridObj at a given position in the grid.</p> <p>:param row: The row index. :type row: int :param col: The column index. :type col: int :param obj: The GridObj (or None) to set. :type obj: GridObj | None</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def set(self, row: int, col: int, obj: GridObj | None) -&gt; None:\n    \"\"\"Set a GridObj at a given position in the grid.\n\n    :param row: The row index.\n    :type row: int\n    :param col: The column index.\n    :type col: int\n    :param obj: The GridObj (or None) to set.\n    :type obj: GridObj | None\n    \"\"\"\n    assert 0 &lt;= col &lt; self.width, f\"column index {col} outside of grid of width {self.width}\"\n    assert 0 &lt;= row &lt; self.height, f\"row index {row} outside of grid of height {self.height}\"\n    self.grid[row * self.width + col] = obj\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.get","title":"<code>get(row, col)</code>","text":"<p>Get the GridObj at a given position in the grid.</p> <p>:param row: The row index. :type row: int :param col: The column index. :type col: int :return: The GridObj at the given position, if any. :rtype: GridObj | None</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def get(self, row: int, col: int) -&gt; GridObj | None:\n    \"\"\"Get the GridObj at a given position in the grid.\n\n    :param row: The row index.\n    :type row: int\n    :param col: The column index.\n    :type col: int\n    :return: The GridObj at the given position, if any.\n    :rtype: GridObj | None\n    \"\"\"\n    assert 0 &lt;= col &lt; self.width, f\"column index {col} outside of grid of width {self.width}\"\n    assert 0 &lt;= row &lt; self.height, f\"row index {row} outside of grid of height {self.height}\"\n    assert self.grid is not None\n    return self.grid[row * self.width + col]\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.tick","title":"<code>tick()</code>","text":"<p>Advance all GridObjs by one timestep.</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def tick(self):\n    \"\"\"Advance all GridObjs by one timestep.\"\"\"\n    for grid_obj in self.grid:\n        if grid_obj is not None:\n            grid_obj.tick()\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.horz_wall","title":"<code>horz_wall(col, row, length=None, obj_type=Wall)</code>","text":"<p>Create a horizontal wall of obj_type in the grid.</p> <p>:param col: The column index. :type col: int :param row: The row index. :type row: int :param length: The length of the wall, defaults to maximum. :type length: int | None, optional :param obj_type: GridObj to construct a wall from, defaults to Wall. :type obj_type: Callable[[], GridObj], optional</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def horz_wall(\n    self,\n    col: int,\n    row: int,\n    length: int | None = None,\n    obj_type: GridObj = Wall,\n) -&gt; None:\n    \"\"\"Create a horizontal wall of obj_type in the grid.\n\n    :param col: The column index.\n    :type col: int\n    :param row: The row index.\n    :type row: int\n    :param length: The length of the wall, defaults to maximum.\n    :type length: int | None, optional\n    :param obj_type: GridObj to construct a wall from, defaults to Wall.\n    :type obj_type: Callable[[], GridObj], optional\n    \"\"\"\n    if length is None:\n        length = self.width - col\n    for i in range(length):\n        self.set(row=row, col=col + i, obj=obj_type())\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.vert_wall","title":"<code>vert_wall(col, row, length=None, obj_type=Wall)</code>","text":"<p>Create a vertical wall of obj_type in the grid.</p> <p>:param col: The column index. :type col: int :param row: The row index. :type row: int :param length: The length of the wall, defaults to maximum. :type length: int | None, optional :param obj_type: GridObj to construct a wall from, defaults to Wall :type obj_type: Callable[[], GridObj], optional</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def vert_wall(\n    self,\n    col: int,\n    row: int,\n    length: int | None = None,\n    obj_type: GridObj = Wall,\n) -&gt; None:\n    \"\"\"Create a vertical wall of obj_type in the grid.\n\n    :param col: The column index.\n    :type col: int\n    :param row: The row index.\n    :type row: int\n    :param length: The length of the wall, defaults to maximum.\n    :type length: int | None, optional\n    :param obj_type: GridObj to construct a wall from, defaults to Wall\n    :type obj_type: Callable[[], GridObj], optional\n    \"\"\"\n    if length is None:\n        length = self.height - row\n    for j in range(length):\n        self.set(row=row + j, col=col, obj=obj_type())\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.wall_rect","title":"<code>wall_rect(col, row, w, h, grid_obj=Wall)</code>","text":"<p>Create a rectangle of walls in the grid.</p> <p>:param col: Initial column index. :type col: int :param row: Initial row index. :type row: int :param w: Width of the rectangle. :type w: int :param h: Height of the rectangle. :type h: int :param grid_obj: GridObj to construct a wall from, defaults to Wall. :type grid_obj: GridObj, optional</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def wall_rect(self, col: int, row: int, w: int, h: int, grid_obj: GridObj = Wall):\n    \"\"\"Create a rectangle of walls in the grid.\n\n    :param col: Initial column index.\n    :type col: int\n    :param row: Initial row index.\n    :type row: int\n    :param w: Width of the rectangle.\n    :type w: int\n    :param h: Height of the rectangle.\n    :type h: int\n    :param grid_obj: GridObj to construct a wall from, defaults to Wall.\n    :type grid_obj: GridObj, optional\n    \"\"\"\n    self.horz_wall(row=row, col=col, length=w, obj_type=grid_obj)\n    self.horz_wall(row=row, col=col + h - 1, length=w, obj_type=grid_obj)\n    self.vert_wall(row=row, col=col, length=h, obj_type=grid_obj)\n    self.vert_wall(row=row + w - 1, col=col, length=h, obj_type=grid_obj)\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.rotate_left","title":"<code>rotate_left()</code>","text":"<p>Rotate the grid to the left (counter-clockwise).</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def rotate_left(self) -&gt; Grid:\n    \"\"\"Rotate the grid to the left (counter-clockwise).\"\"\"\n    grid = Grid(width=self.height, height=self.width)\n\n    for col in range(self.width):\n        for row in range(self.height):\n            v = self.get(row=row, col=col)\n            if v:\n                v.rotate_left()\n\n            new_row = grid.height - 1 - col\n            new_col = row\n            grid.set(row=new_row, col=new_col, obj=v)\n\n            agent = get_grid_agent_at_position(self, (row, col))\n            if agent:\n                rotated_agent = deepcopy(agent)\n                rotated_agent.rotate_left()\n                rotated_agent.pos = (new_row, new_col)\n                grid.grid_agents[rotated_agent.agent_id] = rotated_agent\n\n    return grid\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.slice","title":"<code>slice(topX, topY, width, height)</code>","text":"<p>Get a subset of the grid.</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def slice(self, topX: int, topY: int, width: int, height: int) -&gt; Grid:\n    \"\"\"Get a subset of the grid.\"\"\"\n    grid = Grid(height=height, width=width)\n    for row in range(height):\n        for col in range(width):\n            x = topX + col\n            y = topY + row\n            if 0 &lt;= x &lt; self.width and 0 &lt;= y &lt; self.height:\n                v = self.get(row=y, col=x)\n\n                agent = get_grid_agent_at_position(grid=self, position=(y, x))\n                if agent is not None:\n                    grid_slice_agent = deepcopy(agent)\n                    grid_slice_agent.pos = (row, col)\n                    grid.grid_agents[grid_slice_agent.agent_id] = grid_slice_agent\n            else:\n                v = Wall()\n\n            grid.set(row=row, col=col, obj=v)\n\n    return grid\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.render_tile","title":"<code>render_tile(obj, highlight=False, position=None, tile_size=CoreConstants.TilePixels, subdivs=3)</code>","text":"<p>Render a tile and cache the result.</p> <p>:param obj: The GridObj to render on the tile, defaults to None. :type obj: GridObj | None :param highlight: If the cell should be highlighted, defaults to False :type highlight: bool, optional :param position: Position of the GridObj (useful for retrieving GridAgent), defaults to None :type position: tuple[int, int] | None, optional :param tile_size: Rendered size of the tile, defaults to CoreConstants.TilePixels :type tile_size: int, optional :param subdivs: Number of sub-divisions of the tile, defaults to 3 :type subdivs: int, optional :return: An RGB image of the rendered tile. :rtype: np.ndarray</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def render_tile(\n    self,\n    obj: GridObj | None,\n    highlight: bool = False,\n    position: tuple[int, int] | None = None,\n    tile_size: int = CoreConstants.TilePixels,\n    subdivs: int = 3,\n) -&gt; np.ndarray:\n    \"\"\"Render a tile and cache the result.\n\n    :param obj: The GridObj to render on the tile, defaults to None.\n    :type obj: GridObj | None\n    :param highlight: If the cell should be highlighted, defaults to False\n    :type highlight: bool, optional\n    :param position: Position of the GridObj (useful for retrieving GridAgent), defaults to None\n    :type position: tuple[int, int] | None, optional\n    :param tile_size: Rendered size of the tile, defaults to CoreConstants.TilePixels\n    :type tile_size: int, optional\n    :param subdivs: Number of sub-divisions of the tile, defaults to 3\n    :type subdivs: int, optional\n    :return: An RGB image of the rendered tile.\n    :rtype: np.ndarray\n    \"\"\"\n    grid_agent = get_grid_agent_at_position(grid=self, position=position)\n    agent_dir = grid_agent.dir if grid_agent else None\n    agent_color = grid_agent.agent_id if grid_agent else None\n    agent_inventory_names = (\n        tuple([obj.object_id for obj in grid_agent.inventory]) if grid_agent else None\n    )\n    key: tuple[Any, ...] = (\n        (agent_dir, agent_color, agent_inventory_names),\n        highlight,\n        tile_size,\n    )\n    key = obj.encode() + key if obj else key\n\n    if key in self.__class__.tile_cache:\n        return self.__class__.tile_cache[key]\n\n    tile_img = np.zeros(shape=(tile_size * subdivs, tile_size * subdivs, 3), dtype=np.uint8)\n\n    # Draw grid lines (separating each tile)\n    fill_coords(tile_img, point_in_rect(0, 0.031, 0, 1), (100, 100, 100))\n    fill_coords(tile_img, point_in_rect(0, 1, 0, 0.031), (100, 100, 100))\n\n    # Render the object itself onto the tile\n    if obj is not None:\n        obj.render(tile_img)\n\n    if grid_agent is not None:\n        grid_agent.render(tile_img)\n\n    if highlight:\n        highlight_img(tile_img)\n\n    tile_img = downsample(tile_img, subdivs)\n\n    # Cache the rendered tile\n    self.__class__.tile_cache[key] = tile_img\n\n    return tile_img\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.render","title":"<code>render(tile_size, highlight_mask=None)</code>","text":"<p>Render a tile and cache the result.</p> <p>:param tile_size: The size of the tile (pixels). :type tile_size: int :param highlight_mask: Array mask to indicate which cells are highlighted, defaults to None :type highlight_mask: np.ndarray | None, optional :return: An RGB image of the rendered grid. :rtype: np.ndarray</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def render(\n    self,\n    tile_size: int,\n    highlight_mask: np.ndarray | None = None,\n) -&gt; np.ndarray:\n    \"\"\"Render a tile and cache the result.\n\n    :param tile_size: The size of the tile (pixels).\n    :type tile_size: int\n    :param highlight_mask: Array mask to indicate which cells are highlighted, defaults to None\n    :type highlight_mask: np.ndarray | None, optional\n    :return: An RGB image of the rendered grid.\n    :rtype: np.ndarray\n    \"\"\"\n    if highlight_mask is None:\n        highlight_mask = np.zeros(shape=(self.width, self.height), dtype=bool)\n\n    # Compute total size\n    width_px = self.width * tile_size\n    height_px = self.height * tile_size\n\n    img = np.zeros(shape=(height_px, width_px, 3), dtype=np.uint8)\n\n    # render the grid\n    assert highlight_mask is not None\n    for row in range(self.height):\n        for col in range(self.width):\n            cell = self.get(row=row, col=col)\n\n            tile_img = self.render_tile(\n                cell,\n                highlight=highlight_mask.T[row, col],\n                position=(row, col),\n                tile_size=tile_size,\n            )\n            ymin = row * tile_size\n            ymax = (row + 1) * tile_size\n            xmin = col * tile_size\n            xmax = (col + 1) * tile_size\n\n            img[ymin:ymax, xmin:xmax, :] = tile_img\n\n    return img\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.encode","title":"<code>encode(vis_mask=None, encode_char=False, scope='global')</code>","text":"<p>Produce an ASCII/int representation of the grid.</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def encode(\n    self,\n    vis_mask: np.ndarray | None = None,\n    encode_char=False,\n    scope: str = \"global\",\n) -&gt; np.ndarray:\n    \"\"\"Produce an ASCII/int representation of the grid.\"\"\"\n    if vis_mask is None:\n        vis_mask = np.ones((self.height, self.width), dtype=bool)\n\n    array = np.empty((self.height, self.width, 3), dtype=object)\n\n    assert vis_mask is not None\n    for col in range(self.width):\n        for row in range(self.height):\n            if not vis_mask[row, col]:\n                continue\n\n            v = self.get(row=row, col=col)\n            if v is None:\n                encoding = (\n                    (\n                        GridConstants.FreeSpace\n                        if encode_char\n                        else object_to_idx(None, scope=scope)\n                    ),\n                    0,\n                    0,\n                )\n            else:\n                encoding = v.encode(encode_char=encode_char, scope=scope)\n\n            array[row, col] = encoding\n\n    for grid_agent in self.grid_agents.values():\n        row, col = grid_agent.pos\n        array[row, col] = grid_agent.encode(encode_char=encode_char)\n\n    if not encode_char:\n        array = array.astype(np.int8)\n\n    return array\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.decode","title":"<code>decode(array, scope='global')</code>  <code>staticmethod</code>","text":"<p>Decode ASCII encoding back into a Grid.</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>@staticmethod\ndef decode(array: np.ndarray, scope: str = \"global\") -&gt; tuple[Grid, np.ndarray]:\n    \"\"\"Decode ASCII encoding back into a Grid.\"\"\"\n    channels, height, width = array.shape\n    assert channels == 2\n\n    vis_mask = np.ones(shape=(height, width), dtype=bool)\n\n    grid = Grid(height=height, width=width)\n    agent_count = 0\n    for col in range(width):\n        for row in range(height):\n            char, state = array[:, row, col]\n            state = int(float(state))\n            v = GridObj.decode(char, state, scope=scope)\n            if v:\n                v.pos = v.init_pos = (row, col)\n                vis_mask[row, col] = v.visible()\n\n            if isinstance(v, GridAgent):\n                grid.grid_agents[agent_count] = v\n                agent_count += 1\n            else:\n                grid.set(row=row, col=col, obj=v)\n\n    return grid, vis_mask\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.get_obj_count","title":"<code>get_obj_count(grid_obj)</code>","text":"<p>Get the number of a particular object that exists in the grid.</p> <p>:param grid_obj: The GridObj to count. :type grid_obj: GridObj | None :return: The number of the GridObj in the grid. :rtype: int</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def get_obj_count(self, grid_obj: GridObj | None) -&gt; int:\n    \"\"\"Get the number of a particular object that exists in the grid.\n\n    :param grid_obj: The GridObj to count.\n    :type grid_obj: GridObj | None\n    :return: The number of the GridObj in the grid.\n    :rtype: int\n    \"\"\"\n    count = 0\n    for obj in self.grid:\n        if isinstance(obj, grid_obj):\n            count += 1\n    return count\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.Grid.process_vis","title":"<code>process_vis(agent_pos)</code>","text":"<p>Compute visibility mask from the agent's position.</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def process_vis(self, agent_pos: tuple[int, int]) -&gt; np.ndarray:\n    \"\"\"Compute visibility mask from the agent's position.\"\"\"\n    mask = np.zeros(shape=(self.width, self.height), dtype=bool)\n\n    mask[agent_pos[1], agent_pos[0]] = True\n\n    for j in reversed(range(0, self.height)):\n        for i in range(0, self.width - 1):\n            if not mask[i, j]:\n                continue\n\n            cell = self.get(j, i)\n            if cell and not cell.see_behind():\n                continue\n\n            mask[i + 1, j] = True\n            if j &gt; 0:\n                mask[i + 1, j - 1] = True\n                mask[i, j - 1] = True\n\n        for i in reversed(range(1, self.width)):\n            if not mask[i, j]:\n                continue\n\n            cell = self.get(j, i)\n            if cell and not cell.see_behind():\n                continue\n\n            mask[i - 1, j] = True\n            if j &gt; 0:\n                mask[i - 1, j - 1] = True\n                mask[i, j - 1] = True\n\n    for j in range(0, self.height):\n        for i in range(0, self.width):\n            if not mask[i, j]:\n                self.set(j, i, None)\n\n    mask = np.transpose(mask, axes=(1, 0))\n    return mask\n</code></pre>"},{"location":"reference/cogrid/core/grid/#cogrid.core.grid.get_grid_agent_at_position","title":"<code>get_grid_agent_at_position(grid, position)</code>","text":"<p>Return the GridAgent at a given position, if any.</p> <p>:param grid: The grid to search. :type grid: Grid :param position: The position to search for. :type position: tuple[int, int] | np.ndarray :return: The GridAgent at the given position, if any. :rtype: GridAgent | None</p> Source code in <code>cogrid/core/grid.py</code> <pre><code>def get_grid_agent_at_position(\n    grid: Grid, position: tuple[int, int] | np.ndarray\n) -&gt; GridAgent | None:\n    \"\"\"Return the GridAgent at a given position, if any.\n\n    :param grid: The grid to search.\n    :type grid: Grid\n    :param position: The position to search for.\n    :type position: tuple[int, int] | np.ndarray\n    :return: The GridAgent at the given position, if any.\n    :rtype: GridAgent | None\n    \"\"\"\n    for grid_agent in grid.grid_agents.values():\n        # assert agent.pos is not None, \"Agent pos should never be None.\"\n        if np.array_equal(grid_agent.pos, position):\n            return grid_agent\n    return None\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/","title":"grid_object","text":""},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object","title":"<code>cogrid.core.grid_object</code>","text":"<p>Backward-compatibility re-export shim.</p> <p>This module previously contained all grid object code (base class, registry, and concrete definitions) in a single 818-line file. The code has been split into three focused modules:</p> <ul> <li><code>grid_object_base</code>: GridObj base class, GridAgent wrapper, helpers</li> <li><code>grid_object_registry</code>: OBJECT_REGISTRY, registration and lookup functions</li> <li><code>grid_objects</code>: Concrete global objects (Wall, Floor, Counter, Key, Door)</li> </ul> <p>All public names are re-exported here so existing imports continue to work:</p> <pre><code>from cogrid.core.grid_object import GridObj, Wall, make_object  # still works\nfrom cogrid.core import grid_object; grid_object.OBJECT_REGISTRY  # still works\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridAgent","title":"<code>GridAgent</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>Grid wrapper for an Agent, handling direction rendering and inventory.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>class GridAgent(GridObj):\n    \"\"\"Grid wrapper for an Agent, handling direction rendering and inventory.\"\"\"\n\n    def __init__(self, agent, n_agents: int, scope: str = \"global\"):\n        \"\"\"Initialize from an Agent, encoding direction as char and inventory as state.\"\"\"\n        from cogrid.core.grid_object_registry import object_to_idx\n\n        self.char = {\n            Directions.Up: \"^\",\n            Directions.Down: \"v\",\n            Directions.Left: \"&lt;\",\n            Directions.Right: \"&gt;\",\n        }[agent.dir]\n\n        assert len(agent.inventory) &lt;= 1, (\n            \"Current implementation requires maximum inventory size of 1.\"\n        )\n\n        self.object_id = f\"agent_{self.char}\"\n\n        state = 0 if len(agent.inventory) == 0 else object_to_idx(agent.inventory[0], scope=scope)\n\n        super().__init__(state=state)\n        self.dir = agent.dir\n        self.pos = agent.pos\n        self.front_pos = agent.front_pos\n        self.agent_id = agent.id\n        self.inventory: list[GridObj] = deepcopy(agent.inventory)\n        assert self.pos is not None\n\n        # Generate high-contrast colors based on HSV color space\n        # Hue values are evenly spaced around the color wheel\n        hue = (agent.agent_number - 1) * (360 / n_agents)\n        # Use high saturation (0.7-1.0) and value (0.8-1.0) for vibrant colors\n        # This avoids whites (high V, low S), blacks (low V), and greys (low S)\n        rgb_color = self._hsv_to_rgb(hue, 0.35, 0.99)\n        self.color = rgb_color\n\n    def rotate_left(self):\n        \"\"\"Rotate the agent's direction counter-clockwise.\"\"\"\n        self.char = {\"^\": \"&lt;\", \"&lt;\": \"v\", \"v\": \"&gt;\", \"&gt;\": \"^\"}[self.char]\n        self.object_id = f\"agent_{self.char}\"\n        self.dir -= 1\n        if self.dir &lt; 0:\n            self.dir += 4\n\n    def render(self, tile_img):\n        \"\"\"Draw agent as a directional triangle with inventory items.\"\"\"\n        tri_fn = point_in_triangle(\n            (0.12, 0.19),\n            (0.87, 0.50),\n            (0.12, 0.81),\n        )\n\n        # Rotate the triangle based on agent direction\n        assert self.dir is not None\n        tri_fn = rotate_fn(tri_fn, cx=0.5, cy=0.5, theta=0.5 * math.pi * self.dir)\n        fill_coords(tile_img, tri_fn, self.color)\n\n        # add any item in the inventory to the corner\n        inv_tile_rows, inv_tile_cols = (\n            tile_img.shape[0] // 3,\n            tile_img.shape[1] // 3,\n        )\n        assert len(self.inventory) &lt;= 3, (\n            \"We're rendering inventory items at 1/3 size, so can't do more than 3!\"\n        )\n\n        offset = 4  # offset so we still see grid lines\n        for i, obj in enumerate(self.inventory):\n            inventory_tile = np.zeros(shape=(inv_tile_rows, inv_tile_cols, 3))\n            obj.render(inventory_tile)\n\n            # Take the subset of the image that we'll fill, then only\n            # fill where the image is non-zero (transparent background).\n            tile_subset = tile_img[\n                i * inv_tile_rows + offset : (i + 1) * inv_tile_rows + offset,\n                offset : inv_tile_cols + offset,\n                :,\n            ]\n            nonzero_entries = np.nonzero(inventory_tile)\n            tile_subset[nonzero_entries] = inventory_tile[nonzero_entries]\n\n    @staticmethod\n    def decode(char_or_idx: str | int, state: int, scope: str = \"global\"):\n        \"\"\"Decode a char/idx and state into a GridAgent-compatible object.\"\"\"\n        from cogrid.core.grid_object_registry import (\n            get_object_id_from_char,\n            get_object_names,\n            make_object,\n        )\n\n        if char_or_idx in [\n            None,\n            GridConstants.FreeSpace,\n            GridConstants.Obscured,\n        ]:\n            return None\n\n        # check if the name was passed instead of the character\n        if _is_str(char_or_idx) and len(char_or_idx) &gt; 1:\n            object_id = char_or_idx\n        elif _is_str(char_or_idx):\n            object_id = get_object_id_from_char(char_or_idx)\n        elif _is_int(char_or_idx):\n            object_id = get_object_names(scope=scope)[char_or_idx]\n        else:\n            raise ValueError(f\"Invalid identifier for decoding: {char_or_idx}\")\n\n        state = int(state)\n\n        return make_object(object_id, state=state)\n\n    @staticmethod\n    def _hsv_to_rgb(h: float, s: float, v: float) -&gt; tuple[float, float, float]:\n        \"\"\"Convert HSV color values to RGB tuple.\"\"\"\n        h = h % 360\n        c = v * s\n        x = c * (1 - abs((h / 60) % 2 - 1))\n        m = v - c\n\n        if 0 &lt;= h &lt; 60:\n            r, g, b = c, x, 0\n        elif 60 &lt;= h &lt; 120:\n            r, g, b = x, c, 0\n        elif 120 &lt;= h &lt; 180:\n            r, g, b = 0, c, x\n        elif 180 &lt;= h &lt; 240:\n            r, g, b = 0, x, c\n        elif 240 &lt;= h &lt; 300:\n            r, g, b = x, 0, c\n        else:\n            r, g, b = c, 0, x\n\n        return ((r + m) * 255.0, (g + m) * 255.0, (b + m) * 255.0)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridAgent.__init__","title":"<code>__init__(agent, n_agents, scope='global')</code>","text":"<p>Initialize from an Agent, encoding direction as char and inventory as state.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def __init__(self, agent, n_agents: int, scope: str = \"global\"):\n    \"\"\"Initialize from an Agent, encoding direction as char and inventory as state.\"\"\"\n    from cogrid.core.grid_object_registry import object_to_idx\n\n    self.char = {\n        Directions.Up: \"^\",\n        Directions.Down: \"v\",\n        Directions.Left: \"&lt;\",\n        Directions.Right: \"&gt;\",\n    }[agent.dir]\n\n    assert len(agent.inventory) &lt;= 1, (\n        \"Current implementation requires maximum inventory size of 1.\"\n    )\n\n    self.object_id = f\"agent_{self.char}\"\n\n    state = 0 if len(agent.inventory) == 0 else object_to_idx(agent.inventory[0], scope=scope)\n\n    super().__init__(state=state)\n    self.dir = agent.dir\n    self.pos = agent.pos\n    self.front_pos = agent.front_pos\n    self.agent_id = agent.id\n    self.inventory: list[GridObj] = deepcopy(agent.inventory)\n    assert self.pos is not None\n\n    # Generate high-contrast colors based on HSV color space\n    # Hue values are evenly spaced around the color wheel\n    hue = (agent.agent_number - 1) * (360 / n_agents)\n    # Use high saturation (0.7-1.0) and value (0.8-1.0) for vibrant colors\n    # This avoids whites (high V, low S), blacks (low V), and greys (low S)\n    rgb_color = self._hsv_to_rgb(hue, 0.35, 0.99)\n    self.color = rgb_color\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridAgent.rotate_left","title":"<code>rotate_left()</code>","text":"<p>Rotate the agent's direction counter-clockwise.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def rotate_left(self):\n    \"\"\"Rotate the agent's direction counter-clockwise.\"\"\"\n    self.char = {\"^\": \"&lt;\", \"&lt;\": \"v\", \"v\": \"&gt;\", \"&gt;\": \"^\"}[self.char]\n    self.object_id = f\"agent_{self.char}\"\n    self.dir -= 1\n    if self.dir &lt; 0:\n        self.dir += 4\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridAgent.render","title":"<code>render(tile_img)</code>","text":"<p>Draw agent as a directional triangle with inventory items.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw agent as a directional triangle with inventory items.\"\"\"\n    tri_fn = point_in_triangle(\n        (0.12, 0.19),\n        (0.87, 0.50),\n        (0.12, 0.81),\n    )\n\n    # Rotate the triangle based on agent direction\n    assert self.dir is not None\n    tri_fn = rotate_fn(tri_fn, cx=0.5, cy=0.5, theta=0.5 * math.pi * self.dir)\n    fill_coords(tile_img, tri_fn, self.color)\n\n    # add any item in the inventory to the corner\n    inv_tile_rows, inv_tile_cols = (\n        tile_img.shape[0] // 3,\n        tile_img.shape[1] // 3,\n    )\n    assert len(self.inventory) &lt;= 3, (\n        \"We're rendering inventory items at 1/3 size, so can't do more than 3!\"\n    )\n\n    offset = 4  # offset so we still see grid lines\n    for i, obj in enumerate(self.inventory):\n        inventory_tile = np.zeros(shape=(inv_tile_rows, inv_tile_cols, 3))\n        obj.render(inventory_tile)\n\n        # Take the subset of the image that we'll fill, then only\n        # fill where the image is non-zero (transparent background).\n        tile_subset = tile_img[\n            i * inv_tile_rows + offset : (i + 1) * inv_tile_rows + offset,\n            offset : inv_tile_cols + offset,\n            :,\n        ]\n        nonzero_entries = np.nonzero(inventory_tile)\n        tile_subset[nonzero_entries] = inventory_tile[nonzero_entries]\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridAgent.decode","title":"<code>decode(char_or_idx, state, scope='global')</code>  <code>staticmethod</code>","text":"<p>Decode a char/idx and state into a GridAgent-compatible object.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>@staticmethod\ndef decode(char_or_idx: str | int, state: int, scope: str = \"global\"):\n    \"\"\"Decode a char/idx and state into a GridAgent-compatible object.\"\"\"\n    from cogrid.core.grid_object_registry import (\n        get_object_id_from_char,\n        get_object_names,\n        make_object,\n    )\n\n    if char_or_idx in [\n        None,\n        GridConstants.FreeSpace,\n        GridConstants.Obscured,\n    ]:\n        return None\n\n    # check if the name was passed instead of the character\n    if _is_str(char_or_idx) and len(char_or_idx) &gt; 1:\n        object_id = char_or_idx\n    elif _is_str(char_or_idx):\n        object_id = get_object_id_from_char(char_or_idx)\n    elif _is_int(char_or_idx):\n        object_id = get_object_names(scope=scope)[char_or_idx]\n    else:\n        raise ValueError(f\"Invalid identifier for decoding: {char_or_idx}\")\n\n    state = int(state)\n\n    return make_object(object_id, state=state)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj","title":"<code>GridObj</code>","text":"<p>Base class for all objects that can exist on a grid cell.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>class GridObj:\n    \"\"\"Base class for all objects that can exist on a grid cell.\"\"\"\n\n    object_id: str = None\n    color: str | tuple = None\n    char: str = None\n\n    def __init__(\n        self,\n        state: int = 0,\n        toggle_value: float = 0,\n        inventory_value: float = 0,\n        overlap_value: float = 0,\n        placed_on_value: float = 0,\n        picked_up_from_value: float = 0,\n    ):\n        \"\"\"Initialize grid object with state and interaction reward values.\"\"\"\n        self.uuid: str = str(uuid.uuid4())\n\n        self.state: int = state\n\n        # If an object can be placed on top of this one, this will hold the object that's on top.\n        self.obj_placed_on: GridObj | None = None\n\n        # position info\n        self.init_pos: tuple[int, int] | None = None\n        self.pos: tuple[int, int] | None = None\n\n        # defines rewards for holding/toggling/overlapping\n        self.toggle_value: float | int = toggle_value\n        self.inventory_value: float | int = inventory_value\n        self.overlap_value: float | int = overlap_value\n        self.placed_on_value: float | int = placed_on_value\n        self.picked_up_from_value: float | int = picked_up_from_value\n\n    def can_overlap(self, agent: GridAgent) -&gt; bool:\n        \"\"\"Can an agent overlap with this object?\"\"\"\n        return False\n\n    def can_pickup(self, agent: GridAgent) -&gt; bool:\n        \"\"\"Can an agent pick this object up and store in inventory?\"\"\"\n        return False\n\n    def can_place_on(self, agent: GridAgent, cell: GridObj) -&gt; bool:\n        \"\"\"Can another object be placed on top of this object?\n\n        For example, a countertop that can't be walked through but can\n        have an item on top of it.\n        \"\"\"\n        return False\n\n    def can_pickup_from(self, agent: GridAgent) -&gt; bool:\n        \"\"\"Can the agent pick up an object from this one?\"\"\"\n        return self.obj_placed_on is not None and self.obj_placed_on.can_pickup(agent=agent)\n\n    def place_on(self, agent: GridAgent, cell: GridObj) -&gt; None:\n        \"\"\"Place another object on top of this one.\"\"\"\n        self.obj_placed_on = cell\n        self.state = hash(cell.__class__.__name__) % (2**31 - 1)\n\n    def pick_up_from(self, agent: GridAgent) -&gt; GridObj:\n        \"\"\"Remove and return the object placed on top of this one.\"\"\"\n        assert self.obj_placed_on is not None, (\n            f\"Picking up from but there's no object placed on {self.object_id}\"\n        )\n        cell = self.obj_placed_on\n        self.obj_placed_on = None\n        self.state = 0\n        return cell\n\n    def see_behind(self, agent: GridAgent) -&gt; bool:\n        \"\"\"Can the agent see through this object?\"\"\"\n        return True\n\n    def visible(self) -&gt; bool:\n        \"\"\"Return True if this object is visible to agents.\"\"\"\n        return True\n\n    def toggle(self, env, agent: GridAgent = None) -&gt; bool:\n        \"\"\"Trigger/Toggle an action this object performs.\n\n        Some toggles are conditioned on the environment and require\n        specific conditions to be met.\n        \"\"\"\n        return False\n\n    def encode(self, encode_char=True, scope: str = \"global\"):\n        \"\"\"Encode this object as a (char/idx, extra, state) tuple.\"\"\"\n        from cogrid.core.grid_object_registry import object_to_idx\n\n        return (\n            self.char if encode_char else object_to_idx(self, scope=scope),\n            0,\n            int(self.state),\n        )\n\n    def render(self, tile_img):\n        \"\"\"By default, everything will be rendered as a square with the specified color.\"\"\"\n        fill_coords(tile_img, point_in_rect(0, 1, 0, 1), color=self.color)\n\n    @staticmethod\n    def decode(char_or_idx: str | int, state: int, scope: str = \"global\"):\n        \"\"\"Decode a char/idx and state into a GridObj instance.\"\"\"\n        from cogrid.core.grid_object_registry import get_object_id_from_char, make_object\n\n        if char_or_idx in [\n            None,\n            GridConstants.FreeSpace,\n            GridConstants.Obscured,\n        ]:\n            return None\n\n        # check if the name was passed instead of the character\n        if _is_str(char_or_idx) and len(char_or_idx) &gt; 1:\n            object_id = char_or_idx\n        elif _is_str(char_or_idx):\n            object_id = get_object_id_from_char(char_or_idx, scope=scope)\n        else:\n            raise ValueError(f\"Invalid identifier for decoding: {char_or_idx}\")\n\n        state = int(state)\n\n        return make_object(object_id, state=state, scope=scope)\n\n    def rotate_left(self):\n        \"\"\"Rotate this object counter-clockwise (overridden by agents).\"\"\"\n        pass\n\n    def tick(self):\n        \"\"\"Advance time-dependent state (overridden by objects like pots).\"\"\"\n        pass\n\n    def _remove_from_grid(self, grid):\n        \"\"\"Remove this object from the grid at its current position.\"\"\"\n        cell = grid.get(*self.pos)\n        assert self is cell\n        grid.set(*self.pos, None)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.__init__","title":"<code>__init__(state=0, toggle_value=0, inventory_value=0, overlap_value=0, placed_on_value=0, picked_up_from_value=0)</code>","text":"<p>Initialize grid object with state and interaction reward values.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def __init__(\n    self,\n    state: int = 0,\n    toggle_value: float = 0,\n    inventory_value: float = 0,\n    overlap_value: float = 0,\n    placed_on_value: float = 0,\n    picked_up_from_value: float = 0,\n):\n    \"\"\"Initialize grid object with state and interaction reward values.\"\"\"\n    self.uuid: str = str(uuid.uuid4())\n\n    self.state: int = state\n\n    # If an object can be placed on top of this one, this will hold the object that's on top.\n    self.obj_placed_on: GridObj | None = None\n\n    # position info\n    self.init_pos: tuple[int, int] | None = None\n    self.pos: tuple[int, int] | None = None\n\n    # defines rewards for holding/toggling/overlapping\n    self.toggle_value: float | int = toggle_value\n    self.inventory_value: float | int = inventory_value\n    self.overlap_value: float | int = overlap_value\n    self.placed_on_value: float | int = placed_on_value\n    self.picked_up_from_value: float | int = picked_up_from_value\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.can_overlap","title":"<code>can_overlap(agent)</code>","text":"<p>Can an agent overlap with this object?</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def can_overlap(self, agent: GridAgent) -&gt; bool:\n    \"\"\"Can an agent overlap with this object?\"\"\"\n    return False\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.can_pickup","title":"<code>can_pickup(agent)</code>","text":"<p>Can an agent pick this object up and store in inventory?</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def can_pickup(self, agent: GridAgent) -&gt; bool:\n    \"\"\"Can an agent pick this object up and store in inventory?\"\"\"\n    return False\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.can_place_on","title":"<code>can_place_on(agent, cell)</code>","text":"<p>Can another object be placed on top of this object?</p> <p>For example, a countertop that can't be walked through but can have an item on top of it.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def can_place_on(self, agent: GridAgent, cell: GridObj) -&gt; bool:\n    \"\"\"Can another object be placed on top of this object?\n\n    For example, a countertop that can't be walked through but can\n    have an item on top of it.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.can_pickup_from","title":"<code>can_pickup_from(agent)</code>","text":"<p>Can the agent pick up an object from this one?</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def can_pickup_from(self, agent: GridAgent) -&gt; bool:\n    \"\"\"Can the agent pick up an object from this one?\"\"\"\n    return self.obj_placed_on is not None and self.obj_placed_on.can_pickup(agent=agent)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.place_on","title":"<code>place_on(agent, cell)</code>","text":"<p>Place another object on top of this one.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def place_on(self, agent: GridAgent, cell: GridObj) -&gt; None:\n    \"\"\"Place another object on top of this one.\"\"\"\n    self.obj_placed_on = cell\n    self.state = hash(cell.__class__.__name__) % (2**31 - 1)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.pick_up_from","title":"<code>pick_up_from(agent)</code>","text":"<p>Remove and return the object placed on top of this one.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def pick_up_from(self, agent: GridAgent) -&gt; GridObj:\n    \"\"\"Remove and return the object placed on top of this one.\"\"\"\n    assert self.obj_placed_on is not None, (\n        f\"Picking up from but there's no object placed on {self.object_id}\"\n    )\n    cell = self.obj_placed_on\n    self.obj_placed_on = None\n    self.state = 0\n    return cell\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.see_behind","title":"<code>see_behind(agent)</code>","text":"<p>Can the agent see through this object?</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def see_behind(self, agent: GridAgent) -&gt; bool:\n    \"\"\"Can the agent see through this object?\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.visible","title":"<code>visible()</code>","text":"<p>Return True if this object is visible to agents.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def visible(self) -&gt; bool:\n    \"\"\"Return True if this object is visible to agents.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.toggle","title":"<code>toggle(env, agent=None)</code>","text":"<p>Trigger/Toggle an action this object performs.</p> <p>Some toggles are conditioned on the environment and require specific conditions to be met.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def toggle(self, env, agent: GridAgent = None) -&gt; bool:\n    \"\"\"Trigger/Toggle an action this object performs.\n\n    Some toggles are conditioned on the environment and require\n    specific conditions to be met.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.encode","title":"<code>encode(encode_char=True, scope='global')</code>","text":"<p>Encode this object as a (char/idx, extra, state) tuple.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def encode(self, encode_char=True, scope: str = \"global\"):\n    \"\"\"Encode this object as a (char/idx, extra, state) tuple.\"\"\"\n    from cogrid.core.grid_object_registry import object_to_idx\n\n    return (\n        self.char if encode_char else object_to_idx(self, scope=scope),\n        0,\n        int(self.state),\n    )\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.render","title":"<code>render(tile_img)</code>","text":"<p>By default, everything will be rendered as a square with the specified color.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"By default, everything will be rendered as a square with the specified color.\"\"\"\n    fill_coords(tile_img, point_in_rect(0, 1, 0, 1), color=self.color)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.decode","title":"<code>decode(char_or_idx, state, scope='global')</code>  <code>staticmethod</code>","text":"<p>Decode a char/idx and state into a GridObj instance.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>@staticmethod\ndef decode(char_or_idx: str | int, state: int, scope: str = \"global\"):\n    \"\"\"Decode a char/idx and state into a GridObj instance.\"\"\"\n    from cogrid.core.grid_object_registry import get_object_id_from_char, make_object\n\n    if char_or_idx in [\n        None,\n        GridConstants.FreeSpace,\n        GridConstants.Obscured,\n    ]:\n        return None\n\n    # check if the name was passed instead of the character\n    if _is_str(char_or_idx) and len(char_or_idx) &gt; 1:\n        object_id = char_or_idx\n    elif _is_str(char_or_idx):\n        object_id = get_object_id_from_char(char_or_idx, scope=scope)\n    else:\n        raise ValueError(f\"Invalid identifier for decoding: {char_or_idx}\")\n\n    state = int(state)\n\n    return make_object(object_id, state=state, scope=scope)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.rotate_left","title":"<code>rotate_left()</code>","text":"<p>Rotate this object counter-clockwise (overridden by agents).</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def rotate_left(self):\n    \"\"\"Rotate this object counter-clockwise (overridden by agents).\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.GridObj.tick","title":"<code>tick()</code>","text":"<p>Advance time-dependent state (overridden by objects like pots).</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def tick(self):\n    \"\"\"Advance time-dependent state (overridden by objects like pots).\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Counter","title":"<code>Counter</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A counter surface that can hold one object on top.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>@register_object_type(\"counter\", can_place_on=True)\nclass Counter(GridObj):\n    \"\"\"A counter surface that can hold one object on top.\"\"\"\n\n    object_id = \"counter\"\n    color = constants.Colors.LightBrown\n    char = \"C\"\n\n    def __init__(self, state: int = 0, **kwargs):\n        \"\"\"Initialize counter with given state.\"\"\"\n        super().__init__(\n            state=state,\n        )\n\n    def can_place_on(self, agent: GridAgent, cell: GridObj) -&gt; bool:\n        \"\"\"True when the counter has no object on it.\"\"\"\n        return self.obj_placed_on is None\n\n    def render(self, tile_img):\n        \"\"\"Draw counter and any object placed on it.\"\"\"\n        super().render(tile_img)\n\n        if self.obj_placed_on is not None:\n            self.obj_placed_on.render(tile_img)\n\n    @classmethod\n    def build_render_sync_fn(cls):\n        \"\"\"Return a render-sync callback for counter objects.\"\"\"\n\n        def counter_render_sync(grid, env_state, scope):\n            \"\"\"Sync obj_placed_on for counters from object_state_map.\"\"\"\n            osm = env_state.object_state_map\n            for r in range(grid.height):\n                for c in range(grid.width):\n                    cell = grid.get(r, c)\n                    if cell is None or cell.object_id != \"counter\":\n                        continue\n                    state_val = int(osm[r, c])\n                    if state_val &gt; 0:\n                        placed_id = idx_to_object(state_val, scope=scope)\n                        cell.obj_placed_on = (\n                            make_object(placed_id, scope=scope) if placed_id else None\n                        )\n                    else:\n                        cell.obj_placed_on = None\n\n        return counter_render_sync\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Counter.__init__","title":"<code>__init__(state=0, **kwargs)</code>","text":"<p>Initialize counter with given state.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def __init__(self, state: int = 0, **kwargs):\n    \"\"\"Initialize counter with given state.\"\"\"\n    super().__init__(\n        state=state,\n    )\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Counter.can_place_on","title":"<code>can_place_on(agent, cell)</code>","text":"<p>True when the counter has no object on it.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def can_place_on(self, agent: GridAgent, cell: GridObj) -&gt; bool:\n    \"\"\"True when the counter has no object on it.\"\"\"\n    return self.obj_placed_on is None\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Counter.render","title":"<code>render(tile_img)</code>","text":"<p>Draw counter and any object placed on it.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw counter and any object placed on it.\"\"\"\n    super().render(tile_img)\n\n    if self.obj_placed_on is not None:\n        self.obj_placed_on.render(tile_img)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Counter.build_render_sync_fn","title":"<code>build_render_sync_fn()</code>  <code>classmethod</code>","text":"<p>Return a render-sync callback for counter objects.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>@classmethod\ndef build_render_sync_fn(cls):\n    \"\"\"Return a render-sync callback for counter objects.\"\"\"\n\n    def counter_render_sync(grid, env_state, scope):\n        \"\"\"Sync obj_placed_on for counters from object_state_map.\"\"\"\n        osm = env_state.object_state_map\n        for r in range(grid.height):\n            for c in range(grid.width):\n                cell = grid.get(r, c)\n                if cell is None or cell.object_id != \"counter\":\n                    continue\n                state_val = int(osm[r, c])\n                if state_val &gt; 0:\n                    placed_id = idx_to_object(state_val, scope=scope)\n                    cell.obj_placed_on = (\n                        make_object(placed_id, scope=scope) if placed_id else None\n                    )\n                else:\n                    cell.obj_placed_on = None\n\n    return counter_render_sync\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Door","title":"<code>Door</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A door that can be open, closed, or locked (requires Key).</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>@register_object_type(\"door\")\nclass Door(GridObj):\n    \"\"\"A door that can be open, closed, or locked (requires Key).\"\"\"\n\n    object_id = \"door\"\n    color = constants.Colors.DarkGrey\n    char = \"D\"\n\n    def __init__(self, state):\n        \"\"\"Initialize door with state (0=locked, 1=closed, 2=open).\"\"\"\n        super().__init__(state=state)\n        self.is_open = state == 2\n        self.is_locked = state == 0\n\n    def can_overlap(self, agent: GridAgent) -&gt; bool:\n        \"\"\"The agent can only walk over this cell when the door is open.\"\"\"\n        return self.is_open\n\n    def see_behind(self, agent: GridAgent) -&gt; bool:\n        \"\"\"Return True only when the door is open.\"\"\"\n        return self.is_open\n\n    def toggle(self, env, agent: GridAgent) -&gt; bool:\n        \"\"\"Unlock (if agent has Key) or open/close the door.\"\"\"\n        if self.is_locked:\n            if any([isinstance(obj, Key) for obj in agent.inventory]):\n                self.is_locked = False\n                self.is_open = True\n                return True\n            return False\n\n        self.is_open = not self.is_open\n        return True\n\n    def encode(self, encode_char=False):\n        \"\"\"Encode the door as a 3-tuple of integers.\"\"\"\n        # State, 0: open, 1: closed, 2: locked\n        if self.is_open:\n            self.state = 2\n        elif self.is_locked:\n            self.state = 0\n        # if door is closed and unlocked\n        elif not self.is_open:\n            self.state = 1\n        else:\n            raise ValueError(\n                f\"No possible state encoding for door: open={self.is_open}, locked={self.is_locked}\"\n            )\n\n        return super().encode(encode_char=encode_char)\n\n    def render(self, tile_img):\n        \"\"\"Draw the door based on its state (open, closed, or locked).\"\"\"\n        if self.state == 2:\n            fill_coords(tile_img, point_in_rect(0.88, 1.00, 0.00, 1.00), self.color)\n            fill_coords(tile_img, point_in_rect(0.92, 0.96, 0.04, 0.96), (0, 0, 0))\n            return\n\n        # Door frame and door\n        if self.state == 0:\n            fill_coords(tile_img, point_in_rect(0.00, 1.00, 0.00, 1.00), self.color)\n            fill_coords(\n                tile_img,\n                point_in_rect(0.06, 0.94, 0.06, 0.94),\n                0.45 * np.array(self.color),\n            )\n\n            # Draw key slot\n            fill_coords(tile_img, point_in_rect(0.52, 0.75, 0.50, 0.56), self.color)\n        else:\n            fill_coords(tile_img, point_in_rect(0.00, 1.00, 0.00, 1.00), self.color)\n            fill_coords(tile_img, point_in_rect(0.04, 0.96, 0.04, 0.96), (0, 0, 0))\n            fill_coords(tile_img, point_in_rect(0.08, 0.92, 0.08, 0.92), self.color)\n            fill_coords(tile_img, point_in_rect(0.12, 0.88, 0.12, 0.88), (0, 0, 0))\n\n            # Draw door handle\n            fill_coords(tile_img, point_in_circle(cx=0.75, cy=0.50, r=0.08), self.color)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Door.__init__","title":"<code>__init__(state)</code>","text":"<p>Initialize door with state (0=locked, 1=closed, 2=open).</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def __init__(self, state):\n    \"\"\"Initialize door with state (0=locked, 1=closed, 2=open).\"\"\"\n    super().__init__(state=state)\n    self.is_open = state == 2\n    self.is_locked = state == 0\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Door.can_overlap","title":"<code>can_overlap(agent)</code>","text":"<p>The agent can only walk over this cell when the door is open.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def can_overlap(self, agent: GridAgent) -&gt; bool:\n    \"\"\"The agent can only walk over this cell when the door is open.\"\"\"\n    return self.is_open\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Door.see_behind","title":"<code>see_behind(agent)</code>","text":"<p>Return True only when the door is open.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def see_behind(self, agent: GridAgent) -&gt; bool:\n    \"\"\"Return True only when the door is open.\"\"\"\n    return self.is_open\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Door.toggle","title":"<code>toggle(env, agent)</code>","text":"<p>Unlock (if agent has Key) or open/close the door.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def toggle(self, env, agent: GridAgent) -&gt; bool:\n    \"\"\"Unlock (if agent has Key) or open/close the door.\"\"\"\n    if self.is_locked:\n        if any([isinstance(obj, Key) for obj in agent.inventory]):\n            self.is_locked = False\n            self.is_open = True\n            return True\n        return False\n\n    self.is_open = not self.is_open\n    return True\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Door.encode","title":"<code>encode(encode_char=False)</code>","text":"<p>Encode the door as a 3-tuple of integers.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def encode(self, encode_char=False):\n    \"\"\"Encode the door as a 3-tuple of integers.\"\"\"\n    # State, 0: open, 1: closed, 2: locked\n    if self.is_open:\n        self.state = 2\n    elif self.is_locked:\n        self.state = 0\n    # if door is closed and unlocked\n    elif not self.is_open:\n        self.state = 1\n    else:\n        raise ValueError(\n            f\"No possible state encoding for door: open={self.is_open}, locked={self.is_locked}\"\n        )\n\n    return super().encode(encode_char=encode_char)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Door.render","title":"<code>render(tile_img)</code>","text":"<p>Draw the door based on its state (open, closed, or locked).</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw the door based on its state (open, closed, or locked).\"\"\"\n    if self.state == 2:\n        fill_coords(tile_img, point_in_rect(0.88, 1.00, 0.00, 1.00), self.color)\n        fill_coords(tile_img, point_in_rect(0.92, 0.96, 0.04, 0.96), (0, 0, 0))\n        return\n\n    # Door frame and door\n    if self.state == 0:\n        fill_coords(tile_img, point_in_rect(0.00, 1.00, 0.00, 1.00), self.color)\n        fill_coords(\n            tile_img,\n            point_in_rect(0.06, 0.94, 0.06, 0.94),\n            0.45 * np.array(self.color),\n        )\n\n        # Draw key slot\n        fill_coords(tile_img, point_in_rect(0.52, 0.75, 0.50, 0.56), self.color)\n    else:\n        fill_coords(tile_img, point_in_rect(0.00, 1.00, 0.00, 1.00), self.color)\n        fill_coords(tile_img, point_in_rect(0.04, 0.96, 0.04, 0.96), (0, 0, 0))\n        fill_coords(tile_img, point_in_rect(0.08, 0.92, 0.08, 0.92), self.color)\n        fill_coords(tile_img, point_in_rect(0.12, 0.88, 0.12, 0.88), (0, 0, 0))\n\n        # Draw door handle\n        fill_coords(tile_img, point_in_circle(cx=0.75, cy=0.50, r=0.08), self.color)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Floor","title":"<code>Floor</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>An empty floor tile that agents can walk over.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>@register_object_type(\"floor\", can_overlap=True)\nclass Floor(GridObj):\n    \"\"\"An empty floor tile that agents can walk over.\"\"\"\n\n    object_id = \"floor\"\n    color = constants.Colors.PaleBlue\n    char = GridConstants.FreeSpace\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize floor with default state.\"\"\"\n        super().__init__(\n            state=0,\n        )\n\n    def can_overlap(self) -&gt; bool:\n        \"\"\"Return True; agents can walk over floor tiles.\"\"\"\n        return True\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Floor.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize floor with default state.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize floor with default state.\"\"\"\n    super().__init__(\n        state=0,\n    )\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Floor.can_overlap","title":"<code>can_overlap()</code>","text":"<p>Return True; agents can walk over floor tiles.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def can_overlap(self) -&gt; bool:\n    \"\"\"Return True; agents can walk over floor tiles.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Key","title":"<code>Key</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A key that can be picked up to unlock doors.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>@register_object_type(\"key\", can_pickup=True)\nclass Key(GridObj):\n    \"\"\"A key that can be picked up to unlock doors.\"\"\"\n\n    object_id = \"key\"\n    color = constants.Colors.Yellow\n    char = \"K\"\n\n    def __init__(self, state=0):\n        \"\"\"Initialize key with given state.\"\"\"\n        super().__init__(state=state)\n\n    def can_pickup(self, agent: GridAgent):\n        \"\"\"Return True; keys are always pickable.\"\"\"\n        return True\n\n    def render(self, tile_img):\n        \"\"\"Draw key icon with ring and teeth.\"\"\"\n        # Vertical quad\n        fill_coords(tile_img, point_in_rect(0.50, 0.63, 0.31, 0.88), self.color)\n\n        # Teeth\n        fill_coords(tile_img, point_in_rect(0.38, 0.50, 0.59, 0.66), self.color)\n        fill_coords(tile_img, point_in_rect(0.38, 0.50, 0.81, 0.88), self.color)\n\n        # Ring\n        fill_coords(tile_img, point_in_circle(cx=0.56, cy=0.28, r=0.190), self.color)\n        fill_coords(tile_img, point_in_circle(cx=0.56, cy=0.28, r=0.064), (0, 0, 0))\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Key.__init__","title":"<code>__init__(state=0)</code>","text":"<p>Initialize key with given state.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def __init__(self, state=0):\n    \"\"\"Initialize key with given state.\"\"\"\n    super().__init__(state=state)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Key.can_pickup","title":"<code>can_pickup(agent)</code>","text":"<p>Return True; keys are always pickable.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def can_pickup(self, agent: GridAgent):\n    \"\"\"Return True; keys are always pickable.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Key.render","title":"<code>render(tile_img)</code>","text":"<p>Draw key icon with ring and teeth.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw key icon with ring and teeth.\"\"\"\n    # Vertical quad\n    fill_coords(tile_img, point_in_rect(0.50, 0.63, 0.31, 0.88), self.color)\n\n    # Teeth\n    fill_coords(tile_img, point_in_rect(0.38, 0.50, 0.59, 0.66), self.color)\n    fill_coords(tile_img, point_in_rect(0.38, 0.50, 0.81, 0.88), self.color)\n\n    # Ring\n    fill_coords(tile_img, point_in_circle(cx=0.56, cy=0.28, r=0.190), self.color)\n    fill_coords(tile_img, point_in_circle(cx=0.56, cy=0.28, r=0.064), (0, 0, 0))\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Wall","title":"<code>Wall</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>An impassable wall tile.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>@register_object_type(\"wall\", is_wall=True)\nclass Wall(GridObj):\n    \"\"\"An impassable wall tile.\"\"\"\n\n    object_id = \"wall\"\n    color = constants.Colors.Grey\n    char = \"#\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize wall with default state.\"\"\"\n        super().__init__(state=0)\n\n    def see_behind(self) -&gt; bool:\n        \"\"\"Return False; walls block visibility.\"\"\"\n        return False\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Wall.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize wall with default state.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Initialize wall with default state.\"\"\"\n    super().__init__(state=0)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.Wall.see_behind","title":"<code>see_behind()</code>","text":"<p>Return False; walls block visibility.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def see_behind(self) -&gt; bool:\n    \"\"\"Return False; walls block visibility.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.build_lookup_tables","title":"<code>build_lookup_tables(scope='global')</code>","text":"<p>Build per-type boolean property arrays (CAN_PICKUP, CAN_OVERLAP, etc.).</p> <p>Returns <code>(n_types,)</code> int32 arrays indexed by the integer encoding from <code>object_to_idx()</code>.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def build_lookup_tables(scope: str = \"global\") -&gt; dict[str, np.ndarray]:\n    \"\"\"Build per-type boolean property arrays (CAN_PICKUP, CAN_OVERLAP, etc.).\n\n    Returns ``(n_types,)`` int32 arrays indexed by the integer encoding\n    from ``object_to_idx()``.\n    \"\"\"\n    from cogrid.backend.array_ops import set_at\n\n    type_names = get_object_names(scope=scope)\n    n_types = len(type_names)\n\n    property_keys = [\n        \"CAN_PICKUP\",\n        \"CAN_OVERLAP\",\n        \"CAN_PLACE_ON\",\n        \"CAN_PICKUP_FROM\",\n        \"IS_WALL\",\n    ]\n\n    tables = {key: xp.zeros(n_types, dtype=xp.int32) for key in property_keys}\n\n    for idx, name in enumerate(type_names):\n        if name is None:\n            # Index 0: empty cell -- overlappable\n            tables[\"CAN_OVERLAP\"] = set_at(tables[\"CAN_OVERLAP\"], idx, 1)\n            continue\n\n        if name == \"free_space\":\n            # Index 1: free_space -- overlappable (not in OBJECT_REGISTRY, hardcoded)\n            tables[\"CAN_OVERLAP\"] = set_at(tables[\"CAN_OVERLAP\"], idx, 1)\n            continue\n\n        if name.startswith(\"agent_\"):\n            # Agent direction placeholders -- skip, leave all-zero\n            continue\n\n        # Look up properties: try (scope, name) first, then (\"global\", name)\n        props = _OBJECT_TYPE_PROPERTIES.get((scope, name))\n        if props is None:\n            props = _OBJECT_TYPE_PROPERTIES.get((\"global\", name))\n\n        if props is None:\n            # Object registered via old register_object() without decorator.\n            # Default to all-False properties.\n            import warnings\n\n            warnings.warn(\n                f\"Object '{name}' in scope '{scope}' has no static properties \"\n                f\"(not registered via @register_object_type). \"\n                f\"Defaulting to all-False in lookup tables.\",\n                stacklevel=2,\n            )\n            continue\n\n        prop_map = {\n            \"can_pickup\": \"CAN_PICKUP\",\n            \"can_overlap\": \"CAN_OVERLAP\",\n            \"can_place_on\": \"CAN_PLACE_ON\",\n            \"can_pickup_from\": \"CAN_PICKUP_FROM\",\n            \"is_wall\": \"IS_WALL\",\n        }\n\n        for prop_name, table_key in prop_map.items():\n            if props.get(prop_name, False):\n                tables[table_key] = set_at(tables[table_key], idx, 1)\n\n    return tables\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.get_object_char","title":"<code>get_object_char(object_id, scope='global')</code>","text":"<p>Return the character representation of an object.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def get_object_char(object_id: str, scope: str = \"global\") -&gt; str:\n    \"\"\"Return the character representation of an object.\"\"\"\n    return get_object_class(object_id, scope=scope).char\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.get_object_class","title":"<code>get_object_class(object_id, scope='global')</code>","text":"<p>Return the class registered for the given object_id.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def get_object_class(object_id: str, scope: str = \"global\") -&gt; GridObj:\n    \"\"\"Return the class registered for the given object_id.\"\"\"\n    return OBJECT_REGISTRY[scope][object_id]\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.get_object_id_from_char","title":"<code>get_object_id_from_char(object_char, scope='global')</code>","text":"<p>Look up an object_id from its character, checking global first.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def get_object_id_from_char(object_char: str, scope: str = \"global\") -&gt; str:\n    \"\"\"Look up an object_id from its character, checking global first.\"\"\"\n    # First check global scope, no matter what scope was passed (default to global).\n    for object_id, object_class in OBJECT_REGISTRY[\"global\"].items():\n        if object_class.char == object_char:\n            return object_id\n\n    if scope != \"global\":\n        for object_id, object_class in OBJECT_REGISTRY[scope].items():\n            if object_class.char == object_char:\n                return object_id\n\n    raise ValueError(f\"No registered object with char `{object_char}` in scope `{scope}`.\")\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.get_object_names","title":"<code>get_object_names(scope='global')</code>","text":"<p>Return all registered object IDs in stable encoding order.</p> <p>Order: [None, \"free_space\", sorted globals, sorted scope, agent directions].</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def get_object_names(scope: str = \"global\") -&gt; list[str]:\n    \"\"\"Return all registered object IDs in stable encoding order.\n\n    Order: [None, \"free_space\", sorted globals, sorted scope, agent directions].\n    \"\"\"\n    # Start with None and free_space which are special cases\n    names = [None, \"free_space\"]\n\n    # Add all registered global objects in sorted order (except free_space which we already added)\n    global_objects = sorted(\n        [obj_id for obj_id in OBJECT_REGISTRY.get(\"global\", {}).keys() if obj_id != \"free_space\"]\n    )\n    names.extend(global_objects)\n\n    # Add scope-specific objects if a non-global scope is specified\n    if scope != \"global\" and scope in OBJECT_REGISTRY:\n        scope_objects = sorted(\n            [\n                obj_id\n                for obj_id in OBJECT_REGISTRY[scope].keys()\n                # Skip any objects that might overlap with global scope\n                if obj_id not in OBJECT_REGISTRY.get(\"global\", {})\n            ]\n        )\n        names.extend(scope_objects)\n\n    # Add agent directions last\n    names.extend([f\"agent_{direction}\" for direction in \"^&gt;v&lt;\"])\n\n    return names\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.get_registered_object_ids","title":"<code>get_registered_object_ids(scope='global')</code>","text":"<p>Return a list of the object_ids of available objects in a given scope.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def get_registered_object_ids(scope: str = \"global\") -&gt; list[str]:\n    \"\"\"Return a list of the object_ids of available objects in a given scope.\"\"\"\n    return list(OBJECT_REGISTRY[scope].keys())\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.idx_to_object","title":"<code>idx_to_object(idx, scope='global')</code>","text":"<p>Convert an integer index back to its object_id.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def idx_to_object(idx: int, scope: str = \"global\") -&gt; str:\n    \"\"\"Convert an integer index back to its object_id.\"\"\"\n    names = get_object_names(scope=scope)\n    if idx &gt;= len(names):\n        raise ValueError(\n            f\"Object index {idx} not in object registry (checked global and {scope} scopes).\"\n        )\n    return names[idx]\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.make_object","title":"<code>make_object(object_id, scope='global', **kwargs)</code>","text":"<p>Create a GridObj instance by object_id, checking global then scope.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def make_object(object_id: str | None, scope: str = \"global\", **kwargs) -&gt; GridObj:\n    \"\"\"Create a GridObj instance by object_id, checking global then scope.\"\"\"\n    if object_id is None:\n        return None\n\n    if scope not in OBJECT_REGISTRY:\n        raise ValueError(\n            f\"No objects registered with scope `{scope}`. \"\n            f\"Existing scopes are {list(OBJECT_REGISTRY.keys())}.\"\n        )\n\n    if object_id in OBJECT_REGISTRY[\"global\"]:\n        return OBJECT_REGISTRY[\"global\"][object_id](**kwargs)\n    elif object_id not in OBJECT_REGISTRY[scope]:\n        raise ValueError(\n            f\"Object with object_id `{object_id}` not registered \"\n            f\"in scope `{scope}`. Call register_object() to add it.\"\n        )\n\n    return OBJECT_REGISTRY[scope][object_id](**kwargs)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.object_to_idx","title":"<code>object_to_idx(object, scope='global')</code>","text":"<p>Convert an object or object_id to its integer index.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def object_to_idx(object: GridObj | str | None, scope: str = \"global\") -&gt; int:\n    \"\"\"Convert an object or object_id to its integer index.\"\"\"\n    if isinstance(object, GridObj):\n        object_id = object.object_id\n    else:\n        object_id = object\n\n    return get_object_names(scope=scope).index(object_id)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.register_object","title":"<code>register_object(object_id, obj_class, scope='global')</code>","text":"<p>Register an object class under the given scope.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def register_object(object_id: str, obj_class: GridObj, scope: str = \"global\") -&gt; None:\n    \"\"\"Register an object class under the given scope.\"\"\"\n    global_scope_chars = [obj.char for obj in OBJECT_REGISTRY.get(\"global\", {}).values()]\n\n    if obj_class.char in global_scope_chars:\n        raise ValueError(\n            f\"Character `{obj_class.char}` is already in use in the global scope. \"\n            \"Please choose a different character.\"\n        )\n\n    if object_id in OBJECT_REGISTRY.get(\"global\", {}):\n        raise ValueError(\n            f\"Object with object_id `{object_id}` already registered in the global scope. \"\n            \"Please select a different ID.\"\n        )\n\n    if scope not in OBJECT_REGISTRY:\n        OBJECT_REGISTRY[scope] = {}\n\n    OBJECT_REGISTRY[scope][object_id] = obj_class\n</code></pre>"},{"location":"reference/cogrid/core/grid_object/#cogrid.core.grid_object.register_object_type","title":"<code>register_object_type(object_id, scope='global', can_pickup=False, can_overlap=False, can_place_on=False, can_pickup_from=False, is_wall=False)</code>","text":"<p>Register a GridObj subclass with static property metadata.</p> <p>Stores boolean properties for <code>build_lookup_tables()</code> and auto-discovers component classmethods (tick, interaction, etc.).</p> <p>Usage::</p> <pre><code>@register_object_type(\"wall\", is_wall=True)\nclass Wall(GridObj): ...\n</code></pre> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def register_object_type(\n    object_id: str,\n    scope: str = \"global\",\n    can_pickup: bool = False,\n    can_overlap: bool = False,\n    can_place_on: bool = False,\n    can_pickup_from: bool = False,\n    is_wall: bool = False,\n):\n    \"\"\"Register a GridObj subclass with static property metadata.\n\n    Stores boolean properties for ``build_lookup_tables()`` and\n    auto-discovers component classmethods (tick, interaction, etc.).\n\n    Usage::\n\n        @register_object_type(\"wall\", is_wall=True)\n        class Wall(GridObj): ...\n    \"\"\"\n\n    def decorator(cls):\n        # Lazy import to avoid circular dependency\n        from cogrid.core.component_registry import (\n            _validate_classmethod_signature,\n            get_all_components,\n            register_component_metadata,\n        )\n\n        properties = {\n            \"can_pickup\": can_pickup,\n            \"can_overlap\": can_overlap,\n            \"can_place_on\": can_place_on,\n            \"can_pickup_from\": can_pickup_from,\n            \"is_wall\": is_wall,\n        }\n\n        # Store static properties for lookup table generation\n        _OBJECT_TYPE_PROPERTIES[(scope, object_id)] = properties\n\n        # Duplicate char detection within the same scope\n        for existing in get_all_components(scope):\n            if existing.char == cls.char:\n                raise ValueError(\n                    f\"Duplicate char '{cls.char}' in scope '{scope}': \"\n                    f\"{existing.cls.__name__} and {cls.__name__}\"\n                )\n\n        # Set object_id on the class\n        cls.object_id = object_id\n\n        # Delegate to existing register_object for backward compatibility\n        register_object(object_id, cls, scope=scope)\n\n        # Convention-based classmethod scan\n        discovered: dict = {}\n        for method_name in _COMPONENT_METHODS:\n            method = getattr(cls, method_name, None)\n            if method is not None and callable(method):\n                _validate_classmethod_signature(cls, method_name, method)\n                discovered[method_name] = method\n\n        # Store component metadata in the registry\n        register_component_metadata(\n            scope=scope,\n            object_id=object_id,\n            cls=cls,\n            properties=properties,\n            methods=discovered,\n        )\n\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/","title":"grid_object_base","text":""},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base","title":"<code>cogrid.core.grid_object_base</code>","text":"<p>GridObj base class and GridAgent wrapper.</p> <p>GridObj defines an object in the CoGridEnv environment. It is largely derived from the Minigrid WorldObj: https://github.com/Farama-Foundation/Minigrid/minigrid/core/world_object.py</p> <p>GridAgent is a GridObj subclass that represents an agent on the grid, handling direction-based rendering and inventory display.</p>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj","title":"<code>GridObj</code>","text":"<p>Base class for all objects that can exist on a grid cell.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>class GridObj:\n    \"\"\"Base class for all objects that can exist on a grid cell.\"\"\"\n\n    object_id: str = None\n    color: str | tuple = None\n    char: str = None\n\n    def __init__(\n        self,\n        state: int = 0,\n        toggle_value: float = 0,\n        inventory_value: float = 0,\n        overlap_value: float = 0,\n        placed_on_value: float = 0,\n        picked_up_from_value: float = 0,\n    ):\n        \"\"\"Initialize grid object with state and interaction reward values.\"\"\"\n        self.uuid: str = str(uuid.uuid4())\n\n        self.state: int = state\n\n        # If an object can be placed on top of this one, this will hold the object that's on top.\n        self.obj_placed_on: GridObj | None = None\n\n        # position info\n        self.init_pos: tuple[int, int] | None = None\n        self.pos: tuple[int, int] | None = None\n\n        # defines rewards for holding/toggling/overlapping\n        self.toggle_value: float | int = toggle_value\n        self.inventory_value: float | int = inventory_value\n        self.overlap_value: float | int = overlap_value\n        self.placed_on_value: float | int = placed_on_value\n        self.picked_up_from_value: float | int = picked_up_from_value\n\n    def can_overlap(self, agent: GridAgent) -&gt; bool:\n        \"\"\"Can an agent overlap with this object?\"\"\"\n        return False\n\n    def can_pickup(self, agent: GridAgent) -&gt; bool:\n        \"\"\"Can an agent pick this object up and store in inventory?\"\"\"\n        return False\n\n    def can_place_on(self, agent: GridAgent, cell: GridObj) -&gt; bool:\n        \"\"\"Can another object be placed on top of this object?\n\n        For example, a countertop that can't be walked through but can\n        have an item on top of it.\n        \"\"\"\n        return False\n\n    def can_pickup_from(self, agent: GridAgent) -&gt; bool:\n        \"\"\"Can the agent pick up an object from this one?\"\"\"\n        return self.obj_placed_on is not None and self.obj_placed_on.can_pickup(agent=agent)\n\n    def place_on(self, agent: GridAgent, cell: GridObj) -&gt; None:\n        \"\"\"Place another object on top of this one.\"\"\"\n        self.obj_placed_on = cell\n        self.state = hash(cell.__class__.__name__) % (2**31 - 1)\n\n    def pick_up_from(self, agent: GridAgent) -&gt; GridObj:\n        \"\"\"Remove and return the object placed on top of this one.\"\"\"\n        assert self.obj_placed_on is not None, (\n            f\"Picking up from but there's no object placed on {self.object_id}\"\n        )\n        cell = self.obj_placed_on\n        self.obj_placed_on = None\n        self.state = 0\n        return cell\n\n    def see_behind(self, agent: GridAgent) -&gt; bool:\n        \"\"\"Can the agent see through this object?\"\"\"\n        return True\n\n    def visible(self) -&gt; bool:\n        \"\"\"Return True if this object is visible to agents.\"\"\"\n        return True\n\n    def toggle(self, env, agent: GridAgent = None) -&gt; bool:\n        \"\"\"Trigger/Toggle an action this object performs.\n\n        Some toggles are conditioned on the environment and require\n        specific conditions to be met.\n        \"\"\"\n        return False\n\n    def encode(self, encode_char=True, scope: str = \"global\"):\n        \"\"\"Encode this object as a (char/idx, extra, state) tuple.\"\"\"\n        from cogrid.core.grid_object_registry import object_to_idx\n\n        return (\n            self.char if encode_char else object_to_idx(self, scope=scope),\n            0,\n            int(self.state),\n        )\n\n    def render(self, tile_img):\n        \"\"\"By default, everything will be rendered as a square with the specified color.\"\"\"\n        fill_coords(tile_img, point_in_rect(0, 1, 0, 1), color=self.color)\n\n    @staticmethod\n    def decode(char_or_idx: str | int, state: int, scope: str = \"global\"):\n        \"\"\"Decode a char/idx and state into a GridObj instance.\"\"\"\n        from cogrid.core.grid_object_registry import get_object_id_from_char, make_object\n\n        if char_or_idx in [\n            None,\n            GridConstants.FreeSpace,\n            GridConstants.Obscured,\n        ]:\n            return None\n\n        # check if the name was passed instead of the character\n        if _is_str(char_or_idx) and len(char_or_idx) &gt; 1:\n            object_id = char_or_idx\n        elif _is_str(char_or_idx):\n            object_id = get_object_id_from_char(char_or_idx, scope=scope)\n        else:\n            raise ValueError(f\"Invalid identifier for decoding: {char_or_idx}\")\n\n        state = int(state)\n\n        return make_object(object_id, state=state, scope=scope)\n\n    def rotate_left(self):\n        \"\"\"Rotate this object counter-clockwise (overridden by agents).\"\"\"\n        pass\n\n    def tick(self):\n        \"\"\"Advance time-dependent state (overridden by objects like pots).\"\"\"\n        pass\n\n    def _remove_from_grid(self, grid):\n        \"\"\"Remove this object from the grid at its current position.\"\"\"\n        cell = grid.get(*self.pos)\n        assert self is cell\n        grid.set(*self.pos, None)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.__init__","title":"<code>__init__(state=0, toggle_value=0, inventory_value=0, overlap_value=0, placed_on_value=0, picked_up_from_value=0)</code>","text":"<p>Initialize grid object with state and interaction reward values.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def __init__(\n    self,\n    state: int = 0,\n    toggle_value: float = 0,\n    inventory_value: float = 0,\n    overlap_value: float = 0,\n    placed_on_value: float = 0,\n    picked_up_from_value: float = 0,\n):\n    \"\"\"Initialize grid object with state and interaction reward values.\"\"\"\n    self.uuid: str = str(uuid.uuid4())\n\n    self.state: int = state\n\n    # If an object can be placed on top of this one, this will hold the object that's on top.\n    self.obj_placed_on: GridObj | None = None\n\n    # position info\n    self.init_pos: tuple[int, int] | None = None\n    self.pos: tuple[int, int] | None = None\n\n    # defines rewards for holding/toggling/overlapping\n    self.toggle_value: float | int = toggle_value\n    self.inventory_value: float | int = inventory_value\n    self.overlap_value: float | int = overlap_value\n    self.placed_on_value: float | int = placed_on_value\n    self.picked_up_from_value: float | int = picked_up_from_value\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.can_overlap","title":"<code>can_overlap(agent)</code>","text":"<p>Can an agent overlap with this object?</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def can_overlap(self, agent: GridAgent) -&gt; bool:\n    \"\"\"Can an agent overlap with this object?\"\"\"\n    return False\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.can_pickup","title":"<code>can_pickup(agent)</code>","text":"<p>Can an agent pick this object up and store in inventory?</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def can_pickup(self, agent: GridAgent) -&gt; bool:\n    \"\"\"Can an agent pick this object up and store in inventory?\"\"\"\n    return False\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.can_place_on","title":"<code>can_place_on(agent, cell)</code>","text":"<p>Can another object be placed on top of this object?</p> <p>For example, a countertop that can't be walked through but can have an item on top of it.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def can_place_on(self, agent: GridAgent, cell: GridObj) -&gt; bool:\n    \"\"\"Can another object be placed on top of this object?\n\n    For example, a countertop that can't be walked through but can\n    have an item on top of it.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.can_pickup_from","title":"<code>can_pickup_from(agent)</code>","text":"<p>Can the agent pick up an object from this one?</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def can_pickup_from(self, agent: GridAgent) -&gt; bool:\n    \"\"\"Can the agent pick up an object from this one?\"\"\"\n    return self.obj_placed_on is not None and self.obj_placed_on.can_pickup(agent=agent)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.place_on","title":"<code>place_on(agent, cell)</code>","text":"<p>Place another object on top of this one.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def place_on(self, agent: GridAgent, cell: GridObj) -&gt; None:\n    \"\"\"Place another object on top of this one.\"\"\"\n    self.obj_placed_on = cell\n    self.state = hash(cell.__class__.__name__) % (2**31 - 1)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.pick_up_from","title":"<code>pick_up_from(agent)</code>","text":"<p>Remove and return the object placed on top of this one.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def pick_up_from(self, agent: GridAgent) -&gt; GridObj:\n    \"\"\"Remove and return the object placed on top of this one.\"\"\"\n    assert self.obj_placed_on is not None, (\n        f\"Picking up from but there's no object placed on {self.object_id}\"\n    )\n    cell = self.obj_placed_on\n    self.obj_placed_on = None\n    self.state = 0\n    return cell\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.see_behind","title":"<code>see_behind(agent)</code>","text":"<p>Can the agent see through this object?</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def see_behind(self, agent: GridAgent) -&gt; bool:\n    \"\"\"Can the agent see through this object?\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.visible","title":"<code>visible()</code>","text":"<p>Return True if this object is visible to agents.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def visible(self) -&gt; bool:\n    \"\"\"Return True if this object is visible to agents.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.toggle","title":"<code>toggle(env, agent=None)</code>","text":"<p>Trigger/Toggle an action this object performs.</p> <p>Some toggles are conditioned on the environment and require specific conditions to be met.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def toggle(self, env, agent: GridAgent = None) -&gt; bool:\n    \"\"\"Trigger/Toggle an action this object performs.\n\n    Some toggles are conditioned on the environment and require\n    specific conditions to be met.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.encode","title":"<code>encode(encode_char=True, scope='global')</code>","text":"<p>Encode this object as a (char/idx, extra, state) tuple.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def encode(self, encode_char=True, scope: str = \"global\"):\n    \"\"\"Encode this object as a (char/idx, extra, state) tuple.\"\"\"\n    from cogrid.core.grid_object_registry import object_to_idx\n\n    return (\n        self.char if encode_char else object_to_idx(self, scope=scope),\n        0,\n        int(self.state),\n    )\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.render","title":"<code>render(tile_img)</code>","text":"<p>By default, everything will be rendered as a square with the specified color.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"By default, everything will be rendered as a square with the specified color.\"\"\"\n    fill_coords(tile_img, point_in_rect(0, 1, 0, 1), color=self.color)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.decode","title":"<code>decode(char_or_idx, state, scope='global')</code>  <code>staticmethod</code>","text":"<p>Decode a char/idx and state into a GridObj instance.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>@staticmethod\ndef decode(char_or_idx: str | int, state: int, scope: str = \"global\"):\n    \"\"\"Decode a char/idx and state into a GridObj instance.\"\"\"\n    from cogrid.core.grid_object_registry import get_object_id_from_char, make_object\n\n    if char_or_idx in [\n        None,\n        GridConstants.FreeSpace,\n        GridConstants.Obscured,\n    ]:\n        return None\n\n    # check if the name was passed instead of the character\n    if _is_str(char_or_idx) and len(char_or_idx) &gt; 1:\n        object_id = char_or_idx\n    elif _is_str(char_or_idx):\n        object_id = get_object_id_from_char(char_or_idx, scope=scope)\n    else:\n        raise ValueError(f\"Invalid identifier for decoding: {char_or_idx}\")\n\n    state = int(state)\n\n    return make_object(object_id, state=state, scope=scope)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.rotate_left","title":"<code>rotate_left()</code>","text":"<p>Rotate this object counter-clockwise (overridden by agents).</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def rotate_left(self):\n    \"\"\"Rotate this object counter-clockwise (overridden by agents).\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridObj.tick","title":"<code>tick()</code>","text":"<p>Advance time-dependent state (overridden by objects like pots).</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def tick(self):\n    \"\"\"Advance time-dependent state (overridden by objects like pots).\"\"\"\n    pass\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridAgent","title":"<code>GridAgent</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>Grid wrapper for an Agent, handling direction rendering and inventory.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>class GridAgent(GridObj):\n    \"\"\"Grid wrapper for an Agent, handling direction rendering and inventory.\"\"\"\n\n    def __init__(self, agent, n_agents: int, scope: str = \"global\"):\n        \"\"\"Initialize from an Agent, encoding direction as char and inventory as state.\"\"\"\n        from cogrid.core.grid_object_registry import object_to_idx\n\n        self.char = {\n            Directions.Up: \"^\",\n            Directions.Down: \"v\",\n            Directions.Left: \"&lt;\",\n            Directions.Right: \"&gt;\",\n        }[agent.dir]\n\n        assert len(agent.inventory) &lt;= 1, (\n            \"Current implementation requires maximum inventory size of 1.\"\n        )\n\n        self.object_id = f\"agent_{self.char}\"\n\n        state = 0 if len(agent.inventory) == 0 else object_to_idx(agent.inventory[0], scope=scope)\n\n        super().__init__(state=state)\n        self.dir = agent.dir\n        self.pos = agent.pos\n        self.front_pos = agent.front_pos\n        self.agent_id = agent.id\n        self.inventory: list[GridObj] = deepcopy(agent.inventory)\n        assert self.pos is not None\n\n        # Generate high-contrast colors based on HSV color space\n        # Hue values are evenly spaced around the color wheel\n        hue = (agent.agent_number - 1) * (360 / n_agents)\n        # Use high saturation (0.7-1.0) and value (0.8-1.0) for vibrant colors\n        # This avoids whites (high V, low S), blacks (low V), and greys (low S)\n        rgb_color = self._hsv_to_rgb(hue, 0.35, 0.99)\n        self.color = rgb_color\n\n    def rotate_left(self):\n        \"\"\"Rotate the agent's direction counter-clockwise.\"\"\"\n        self.char = {\"^\": \"&lt;\", \"&lt;\": \"v\", \"v\": \"&gt;\", \"&gt;\": \"^\"}[self.char]\n        self.object_id = f\"agent_{self.char}\"\n        self.dir -= 1\n        if self.dir &lt; 0:\n            self.dir += 4\n\n    def render(self, tile_img):\n        \"\"\"Draw agent as a directional triangle with inventory items.\"\"\"\n        tri_fn = point_in_triangle(\n            (0.12, 0.19),\n            (0.87, 0.50),\n            (0.12, 0.81),\n        )\n\n        # Rotate the triangle based on agent direction\n        assert self.dir is not None\n        tri_fn = rotate_fn(tri_fn, cx=0.5, cy=0.5, theta=0.5 * math.pi * self.dir)\n        fill_coords(tile_img, tri_fn, self.color)\n\n        # add any item in the inventory to the corner\n        inv_tile_rows, inv_tile_cols = (\n            tile_img.shape[0] // 3,\n            tile_img.shape[1] // 3,\n        )\n        assert len(self.inventory) &lt;= 3, (\n            \"We're rendering inventory items at 1/3 size, so can't do more than 3!\"\n        )\n\n        offset = 4  # offset so we still see grid lines\n        for i, obj in enumerate(self.inventory):\n            inventory_tile = np.zeros(shape=(inv_tile_rows, inv_tile_cols, 3))\n            obj.render(inventory_tile)\n\n            # Take the subset of the image that we'll fill, then only\n            # fill where the image is non-zero (transparent background).\n            tile_subset = tile_img[\n                i * inv_tile_rows + offset : (i + 1) * inv_tile_rows + offset,\n                offset : inv_tile_cols + offset,\n                :,\n            ]\n            nonzero_entries = np.nonzero(inventory_tile)\n            tile_subset[nonzero_entries] = inventory_tile[nonzero_entries]\n\n    @staticmethod\n    def decode(char_or_idx: str | int, state: int, scope: str = \"global\"):\n        \"\"\"Decode a char/idx and state into a GridAgent-compatible object.\"\"\"\n        from cogrid.core.grid_object_registry import (\n            get_object_id_from_char,\n            get_object_names,\n            make_object,\n        )\n\n        if char_or_idx in [\n            None,\n            GridConstants.FreeSpace,\n            GridConstants.Obscured,\n        ]:\n            return None\n\n        # check if the name was passed instead of the character\n        if _is_str(char_or_idx) and len(char_or_idx) &gt; 1:\n            object_id = char_or_idx\n        elif _is_str(char_or_idx):\n            object_id = get_object_id_from_char(char_or_idx)\n        elif _is_int(char_or_idx):\n            object_id = get_object_names(scope=scope)[char_or_idx]\n        else:\n            raise ValueError(f\"Invalid identifier for decoding: {char_or_idx}\")\n\n        state = int(state)\n\n        return make_object(object_id, state=state)\n\n    @staticmethod\n    def _hsv_to_rgb(h: float, s: float, v: float) -&gt; tuple[float, float, float]:\n        \"\"\"Convert HSV color values to RGB tuple.\"\"\"\n        h = h % 360\n        c = v * s\n        x = c * (1 - abs((h / 60) % 2 - 1))\n        m = v - c\n\n        if 0 &lt;= h &lt; 60:\n            r, g, b = c, x, 0\n        elif 60 &lt;= h &lt; 120:\n            r, g, b = x, c, 0\n        elif 120 &lt;= h &lt; 180:\n            r, g, b = 0, c, x\n        elif 180 &lt;= h &lt; 240:\n            r, g, b = 0, x, c\n        elif 240 &lt;= h &lt; 300:\n            r, g, b = x, 0, c\n        else:\n            r, g, b = c, 0, x\n\n        return ((r + m) * 255.0, (g + m) * 255.0, (b + m) * 255.0)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridAgent.__init__","title":"<code>__init__(agent, n_agents, scope='global')</code>","text":"<p>Initialize from an Agent, encoding direction as char and inventory as state.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def __init__(self, agent, n_agents: int, scope: str = \"global\"):\n    \"\"\"Initialize from an Agent, encoding direction as char and inventory as state.\"\"\"\n    from cogrid.core.grid_object_registry import object_to_idx\n\n    self.char = {\n        Directions.Up: \"^\",\n        Directions.Down: \"v\",\n        Directions.Left: \"&lt;\",\n        Directions.Right: \"&gt;\",\n    }[agent.dir]\n\n    assert len(agent.inventory) &lt;= 1, (\n        \"Current implementation requires maximum inventory size of 1.\"\n    )\n\n    self.object_id = f\"agent_{self.char}\"\n\n    state = 0 if len(agent.inventory) == 0 else object_to_idx(agent.inventory[0], scope=scope)\n\n    super().__init__(state=state)\n    self.dir = agent.dir\n    self.pos = agent.pos\n    self.front_pos = agent.front_pos\n    self.agent_id = agent.id\n    self.inventory: list[GridObj] = deepcopy(agent.inventory)\n    assert self.pos is not None\n\n    # Generate high-contrast colors based on HSV color space\n    # Hue values are evenly spaced around the color wheel\n    hue = (agent.agent_number - 1) * (360 / n_agents)\n    # Use high saturation (0.7-1.0) and value (0.8-1.0) for vibrant colors\n    # This avoids whites (high V, low S), blacks (low V), and greys (low S)\n    rgb_color = self._hsv_to_rgb(hue, 0.35, 0.99)\n    self.color = rgb_color\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridAgent.rotate_left","title":"<code>rotate_left()</code>","text":"<p>Rotate the agent's direction counter-clockwise.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def rotate_left(self):\n    \"\"\"Rotate the agent's direction counter-clockwise.\"\"\"\n    self.char = {\"^\": \"&lt;\", \"&lt;\": \"v\", \"v\": \"&gt;\", \"&gt;\": \"^\"}[self.char]\n    self.object_id = f\"agent_{self.char}\"\n    self.dir -= 1\n    if self.dir &lt; 0:\n        self.dir += 4\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridAgent.render","title":"<code>render(tile_img)</code>","text":"<p>Draw agent as a directional triangle with inventory items.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw agent as a directional triangle with inventory items.\"\"\"\n    tri_fn = point_in_triangle(\n        (0.12, 0.19),\n        (0.87, 0.50),\n        (0.12, 0.81),\n    )\n\n    # Rotate the triangle based on agent direction\n    assert self.dir is not None\n    tri_fn = rotate_fn(tri_fn, cx=0.5, cy=0.5, theta=0.5 * math.pi * self.dir)\n    fill_coords(tile_img, tri_fn, self.color)\n\n    # add any item in the inventory to the corner\n    inv_tile_rows, inv_tile_cols = (\n        tile_img.shape[0] // 3,\n        tile_img.shape[1] // 3,\n    )\n    assert len(self.inventory) &lt;= 3, (\n        \"We're rendering inventory items at 1/3 size, so can't do more than 3!\"\n    )\n\n    offset = 4  # offset so we still see grid lines\n    for i, obj in enumerate(self.inventory):\n        inventory_tile = np.zeros(shape=(inv_tile_rows, inv_tile_cols, 3))\n        obj.render(inventory_tile)\n\n        # Take the subset of the image that we'll fill, then only\n        # fill where the image is non-zero (transparent background).\n        tile_subset = tile_img[\n            i * inv_tile_rows + offset : (i + 1) * inv_tile_rows + offset,\n            offset : inv_tile_cols + offset,\n            :,\n        ]\n        nonzero_entries = np.nonzero(inventory_tile)\n        tile_subset[nonzero_entries] = inventory_tile[nonzero_entries]\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_base/#cogrid.core.grid_object_base.GridAgent.decode","title":"<code>decode(char_or_idx, state, scope='global')</code>  <code>staticmethod</code>","text":"<p>Decode a char/idx and state into a GridAgent-compatible object.</p> Source code in <code>cogrid/core/grid_object_base.py</code> <pre><code>@staticmethod\ndef decode(char_or_idx: str | int, state: int, scope: str = \"global\"):\n    \"\"\"Decode a char/idx and state into a GridAgent-compatible object.\"\"\"\n    from cogrid.core.grid_object_registry import (\n        get_object_id_from_char,\n        get_object_names,\n        make_object,\n    )\n\n    if char_or_idx in [\n        None,\n        GridConstants.FreeSpace,\n        GridConstants.Obscured,\n    ]:\n        return None\n\n    # check if the name was passed instead of the character\n    if _is_str(char_or_idx) and len(char_or_idx) &gt; 1:\n        object_id = char_or_idx\n    elif _is_str(char_or_idx):\n        object_id = get_object_id_from_char(char_or_idx)\n    elif _is_int(char_or_idx):\n        object_id = get_object_names(scope=scope)[char_or_idx]\n    else:\n        raise ValueError(f\"Invalid identifier for decoding: {char_or_idx}\")\n\n    state = int(state)\n\n    return make_object(object_id, state=state)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_registry/","title":"grid_object_registry","text":""},{"location":"reference/cogrid/core/grid_object_registry/#cogrid.core.grid_object_registry","title":"<code>cogrid.core.grid_object_registry</code>","text":"<p>Grid object registration and lookup machinery.</p> <p>This module contains the OBJECT_REGISTRY, type property metadata, and all functions for registering, looking up, encoding, and decoding grid objects.</p>"},{"location":"reference/cogrid/core/grid_object_registry/#cogrid.core.grid_object_registry.make_object","title":"<code>make_object(object_id, scope='global', **kwargs)</code>","text":"<p>Create a GridObj instance by object_id, checking global then scope.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def make_object(object_id: str | None, scope: str = \"global\", **kwargs) -&gt; GridObj:\n    \"\"\"Create a GridObj instance by object_id, checking global then scope.\"\"\"\n    if object_id is None:\n        return None\n\n    if scope not in OBJECT_REGISTRY:\n        raise ValueError(\n            f\"No objects registered with scope `{scope}`. \"\n            f\"Existing scopes are {list(OBJECT_REGISTRY.keys())}.\"\n        )\n\n    if object_id in OBJECT_REGISTRY[\"global\"]:\n        return OBJECT_REGISTRY[\"global\"][object_id](**kwargs)\n    elif object_id not in OBJECT_REGISTRY[scope]:\n        raise ValueError(\n            f\"Object with object_id `{object_id}` not registered \"\n            f\"in scope `{scope}`. Call register_object() to add it.\"\n        )\n\n    return OBJECT_REGISTRY[scope][object_id](**kwargs)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_registry/#cogrid.core.grid_object_registry.get_object_class","title":"<code>get_object_class(object_id, scope='global')</code>","text":"<p>Return the class registered for the given object_id.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def get_object_class(object_id: str, scope: str = \"global\") -&gt; GridObj:\n    \"\"\"Return the class registered for the given object_id.\"\"\"\n    return OBJECT_REGISTRY[scope][object_id]\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_registry/#cogrid.core.grid_object_registry.register_object","title":"<code>register_object(object_id, obj_class, scope='global')</code>","text":"<p>Register an object class under the given scope.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def register_object(object_id: str, obj_class: GridObj, scope: str = \"global\") -&gt; None:\n    \"\"\"Register an object class under the given scope.\"\"\"\n    global_scope_chars = [obj.char for obj in OBJECT_REGISTRY.get(\"global\", {}).values()]\n\n    if obj_class.char in global_scope_chars:\n        raise ValueError(\n            f\"Character `{obj_class.char}` is already in use in the global scope. \"\n            \"Please choose a different character.\"\n        )\n\n    if object_id in OBJECT_REGISTRY.get(\"global\", {}):\n        raise ValueError(\n            f\"Object with object_id `{object_id}` already registered in the global scope. \"\n            \"Please select a different ID.\"\n        )\n\n    if scope not in OBJECT_REGISTRY:\n        OBJECT_REGISTRY[scope] = {}\n\n    OBJECT_REGISTRY[scope][object_id] = obj_class\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_registry/#cogrid.core.grid_object_registry.register_object_type","title":"<code>register_object_type(object_id, scope='global', can_pickup=False, can_overlap=False, can_place_on=False, can_pickup_from=False, is_wall=False)</code>","text":"<p>Register a GridObj subclass with static property metadata.</p> <p>Stores boolean properties for <code>build_lookup_tables()</code> and auto-discovers component classmethods (tick, interaction, etc.).</p> <p>Usage::</p> <pre><code>@register_object_type(\"wall\", is_wall=True)\nclass Wall(GridObj): ...\n</code></pre> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def register_object_type(\n    object_id: str,\n    scope: str = \"global\",\n    can_pickup: bool = False,\n    can_overlap: bool = False,\n    can_place_on: bool = False,\n    can_pickup_from: bool = False,\n    is_wall: bool = False,\n):\n    \"\"\"Register a GridObj subclass with static property metadata.\n\n    Stores boolean properties for ``build_lookup_tables()`` and\n    auto-discovers component classmethods (tick, interaction, etc.).\n\n    Usage::\n\n        @register_object_type(\"wall\", is_wall=True)\n        class Wall(GridObj): ...\n    \"\"\"\n\n    def decorator(cls):\n        # Lazy import to avoid circular dependency\n        from cogrid.core.component_registry import (\n            _validate_classmethod_signature,\n            get_all_components,\n            register_component_metadata,\n        )\n\n        properties = {\n            \"can_pickup\": can_pickup,\n            \"can_overlap\": can_overlap,\n            \"can_place_on\": can_place_on,\n            \"can_pickup_from\": can_pickup_from,\n            \"is_wall\": is_wall,\n        }\n\n        # Store static properties for lookup table generation\n        _OBJECT_TYPE_PROPERTIES[(scope, object_id)] = properties\n\n        # Duplicate char detection within the same scope\n        for existing in get_all_components(scope):\n            if existing.char == cls.char:\n                raise ValueError(\n                    f\"Duplicate char '{cls.char}' in scope '{scope}': \"\n                    f\"{existing.cls.__name__} and {cls.__name__}\"\n                )\n\n        # Set object_id on the class\n        cls.object_id = object_id\n\n        # Delegate to existing register_object for backward compatibility\n        register_object(object_id, cls, scope=scope)\n\n        # Convention-based classmethod scan\n        discovered: dict = {}\n        for method_name in _COMPONENT_METHODS:\n            method = getattr(cls, method_name, None)\n            if method is not None and callable(method):\n                _validate_classmethod_signature(cls, method_name, method)\n                discovered[method_name] = method\n\n        # Store component metadata in the registry\n        register_component_metadata(\n            scope=scope,\n            object_id=object_id,\n            cls=cls,\n            properties=properties,\n            methods=discovered,\n        )\n\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_registry/#cogrid.core.grid_object_registry.build_lookup_tables","title":"<code>build_lookup_tables(scope='global')</code>","text":"<p>Build per-type boolean property arrays (CAN_PICKUP, CAN_OVERLAP, etc.).</p> <p>Returns <code>(n_types,)</code> int32 arrays indexed by the integer encoding from <code>object_to_idx()</code>.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def build_lookup_tables(scope: str = \"global\") -&gt; dict[str, np.ndarray]:\n    \"\"\"Build per-type boolean property arrays (CAN_PICKUP, CAN_OVERLAP, etc.).\n\n    Returns ``(n_types,)`` int32 arrays indexed by the integer encoding\n    from ``object_to_idx()``.\n    \"\"\"\n    from cogrid.backend.array_ops import set_at\n\n    type_names = get_object_names(scope=scope)\n    n_types = len(type_names)\n\n    property_keys = [\n        \"CAN_PICKUP\",\n        \"CAN_OVERLAP\",\n        \"CAN_PLACE_ON\",\n        \"CAN_PICKUP_FROM\",\n        \"IS_WALL\",\n    ]\n\n    tables = {key: xp.zeros(n_types, dtype=xp.int32) for key in property_keys}\n\n    for idx, name in enumerate(type_names):\n        if name is None:\n            # Index 0: empty cell -- overlappable\n            tables[\"CAN_OVERLAP\"] = set_at(tables[\"CAN_OVERLAP\"], idx, 1)\n            continue\n\n        if name == \"free_space\":\n            # Index 1: free_space -- overlappable (not in OBJECT_REGISTRY, hardcoded)\n            tables[\"CAN_OVERLAP\"] = set_at(tables[\"CAN_OVERLAP\"], idx, 1)\n            continue\n\n        if name.startswith(\"agent_\"):\n            # Agent direction placeholders -- skip, leave all-zero\n            continue\n\n        # Look up properties: try (scope, name) first, then (\"global\", name)\n        props = _OBJECT_TYPE_PROPERTIES.get((scope, name))\n        if props is None:\n            props = _OBJECT_TYPE_PROPERTIES.get((\"global\", name))\n\n        if props is None:\n            # Object registered via old register_object() without decorator.\n            # Default to all-False properties.\n            import warnings\n\n            warnings.warn(\n                f\"Object '{name}' in scope '{scope}' has no static properties \"\n                f\"(not registered via @register_object_type). \"\n                f\"Defaulting to all-False in lookup tables.\",\n                stacklevel=2,\n            )\n            continue\n\n        prop_map = {\n            \"can_pickup\": \"CAN_PICKUP\",\n            \"can_overlap\": \"CAN_OVERLAP\",\n            \"can_place_on\": \"CAN_PLACE_ON\",\n            \"can_pickup_from\": \"CAN_PICKUP_FROM\",\n            \"is_wall\": \"IS_WALL\",\n        }\n\n        for prop_name, table_key in prop_map.items():\n            if props.get(prop_name, False):\n                tables[table_key] = set_at(tables[table_key], idx, 1)\n\n    return tables\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_registry/#cogrid.core.grid_object_registry.get_registered_object_ids","title":"<code>get_registered_object_ids(scope='global')</code>","text":"<p>Return a list of the object_ids of available objects in a given scope.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def get_registered_object_ids(scope: str = \"global\") -&gt; list[str]:\n    \"\"\"Return a list of the object_ids of available objects in a given scope.\"\"\"\n    return list(OBJECT_REGISTRY[scope].keys())\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_registry/#cogrid.core.grid_object_registry.get_object_char","title":"<code>get_object_char(object_id, scope='global')</code>","text":"<p>Return the character representation of an object.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def get_object_char(object_id: str, scope: str = \"global\") -&gt; str:\n    \"\"\"Return the character representation of an object.\"\"\"\n    return get_object_class(object_id, scope=scope).char\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_registry/#cogrid.core.grid_object_registry.get_object_id_from_char","title":"<code>get_object_id_from_char(object_char, scope='global')</code>","text":"<p>Look up an object_id from its character, checking global first.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def get_object_id_from_char(object_char: str, scope: str = \"global\") -&gt; str:\n    \"\"\"Look up an object_id from its character, checking global first.\"\"\"\n    # First check global scope, no matter what scope was passed (default to global).\n    for object_id, object_class in OBJECT_REGISTRY[\"global\"].items():\n        if object_class.char == object_char:\n            return object_id\n\n    if scope != \"global\":\n        for object_id, object_class in OBJECT_REGISTRY[scope].items():\n            if object_class.char == object_char:\n                return object_id\n\n    raise ValueError(f\"No registered object with char `{object_char}` in scope `{scope}`.\")\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_registry/#cogrid.core.grid_object_registry.get_object_names","title":"<code>get_object_names(scope='global')</code>","text":"<p>Return all registered object IDs in stable encoding order.</p> <p>Order: [None, \"free_space\", sorted globals, sorted scope, agent directions].</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def get_object_names(scope: str = \"global\") -&gt; list[str]:\n    \"\"\"Return all registered object IDs in stable encoding order.\n\n    Order: [None, \"free_space\", sorted globals, sorted scope, agent directions].\n    \"\"\"\n    # Start with None and free_space which are special cases\n    names = [None, \"free_space\"]\n\n    # Add all registered global objects in sorted order (except free_space which we already added)\n    global_objects = sorted(\n        [obj_id for obj_id in OBJECT_REGISTRY.get(\"global\", {}).keys() if obj_id != \"free_space\"]\n    )\n    names.extend(global_objects)\n\n    # Add scope-specific objects if a non-global scope is specified\n    if scope != \"global\" and scope in OBJECT_REGISTRY:\n        scope_objects = sorted(\n            [\n                obj_id\n                for obj_id in OBJECT_REGISTRY[scope].keys()\n                # Skip any objects that might overlap with global scope\n                if obj_id not in OBJECT_REGISTRY.get(\"global\", {})\n            ]\n        )\n        names.extend(scope_objects)\n\n    # Add agent directions last\n    names.extend([f\"agent_{direction}\" for direction in \"^&gt;v&lt;\"])\n\n    return names\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_registry/#cogrid.core.grid_object_registry.object_to_idx","title":"<code>object_to_idx(object, scope='global')</code>","text":"<p>Convert an object or object_id to its integer index.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def object_to_idx(object: GridObj | str | None, scope: str = \"global\") -&gt; int:\n    \"\"\"Convert an object or object_id to its integer index.\"\"\"\n    if isinstance(object, GridObj):\n        object_id = object.object_id\n    else:\n        object_id = object\n\n    return get_object_names(scope=scope).index(object_id)\n</code></pre>"},{"location":"reference/cogrid/core/grid_object_registry/#cogrid.core.grid_object_registry.idx_to_object","title":"<code>idx_to_object(idx, scope='global')</code>","text":"<p>Convert an integer index back to its object_id.</p> Source code in <code>cogrid/core/grid_object_registry.py</code> <pre><code>def idx_to_object(idx: int, scope: str = \"global\") -&gt; str:\n    \"\"\"Convert an integer index back to its object_id.\"\"\"\n    names = get_object_names(scope=scope)\n    if idx &gt;= len(names):\n        raise ValueError(\n            f\"Object index {idx} not in object registry (checked global and {scope} scopes).\"\n        )\n    return names[idx]\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/","title":"grid_objects","text":""},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects","title":"<code>cogrid.core.grid_objects</code>","text":"<p>Concrete global grid object definitions.</p> <p>Contains the built-in object types (Wall, Floor, Counter, Key, Door) that are registered in the global scope via @register_object_type.</p>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Wall","title":"<code>Wall</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>An impassable wall tile.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>@register_object_type(\"wall\", is_wall=True)\nclass Wall(GridObj):\n    \"\"\"An impassable wall tile.\"\"\"\n\n    object_id = \"wall\"\n    color = constants.Colors.Grey\n    char = \"#\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"Initialize wall with default state.\"\"\"\n        super().__init__(state=0)\n\n    def see_behind(self) -&gt; bool:\n        \"\"\"Return False; walls block visibility.\"\"\"\n        return False\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Wall.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize wall with default state.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Initialize wall with default state.\"\"\"\n    super().__init__(state=0)\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Wall.see_behind","title":"<code>see_behind()</code>","text":"<p>Return False; walls block visibility.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def see_behind(self) -&gt; bool:\n    \"\"\"Return False; walls block visibility.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Floor","title":"<code>Floor</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>An empty floor tile that agents can walk over.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>@register_object_type(\"floor\", can_overlap=True)\nclass Floor(GridObj):\n    \"\"\"An empty floor tile that agents can walk over.\"\"\"\n\n    object_id = \"floor\"\n    color = constants.Colors.PaleBlue\n    char = GridConstants.FreeSpace\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize floor with default state.\"\"\"\n        super().__init__(\n            state=0,\n        )\n\n    def can_overlap(self) -&gt; bool:\n        \"\"\"Return True; agents can walk over floor tiles.\"\"\"\n        return True\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Floor.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize floor with default state.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize floor with default state.\"\"\"\n    super().__init__(\n        state=0,\n    )\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Floor.can_overlap","title":"<code>can_overlap()</code>","text":"<p>Return True; agents can walk over floor tiles.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def can_overlap(self) -&gt; bool:\n    \"\"\"Return True; agents can walk over floor tiles.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Counter","title":"<code>Counter</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A counter surface that can hold one object on top.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>@register_object_type(\"counter\", can_place_on=True)\nclass Counter(GridObj):\n    \"\"\"A counter surface that can hold one object on top.\"\"\"\n\n    object_id = \"counter\"\n    color = constants.Colors.LightBrown\n    char = \"C\"\n\n    def __init__(self, state: int = 0, **kwargs):\n        \"\"\"Initialize counter with given state.\"\"\"\n        super().__init__(\n            state=state,\n        )\n\n    def can_place_on(self, agent: GridAgent, cell: GridObj) -&gt; bool:\n        \"\"\"True when the counter has no object on it.\"\"\"\n        return self.obj_placed_on is None\n\n    def render(self, tile_img):\n        \"\"\"Draw counter and any object placed on it.\"\"\"\n        super().render(tile_img)\n\n        if self.obj_placed_on is not None:\n            self.obj_placed_on.render(tile_img)\n\n    @classmethod\n    def build_render_sync_fn(cls):\n        \"\"\"Return a render-sync callback for counter objects.\"\"\"\n\n        def counter_render_sync(grid, env_state, scope):\n            \"\"\"Sync obj_placed_on for counters from object_state_map.\"\"\"\n            osm = env_state.object_state_map\n            for r in range(grid.height):\n                for c in range(grid.width):\n                    cell = grid.get(r, c)\n                    if cell is None or cell.object_id != \"counter\":\n                        continue\n                    state_val = int(osm[r, c])\n                    if state_val &gt; 0:\n                        placed_id = idx_to_object(state_val, scope=scope)\n                        cell.obj_placed_on = (\n                            make_object(placed_id, scope=scope) if placed_id else None\n                        )\n                    else:\n                        cell.obj_placed_on = None\n\n        return counter_render_sync\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Counter.__init__","title":"<code>__init__(state=0, **kwargs)</code>","text":"<p>Initialize counter with given state.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def __init__(self, state: int = 0, **kwargs):\n    \"\"\"Initialize counter with given state.\"\"\"\n    super().__init__(\n        state=state,\n    )\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Counter.can_place_on","title":"<code>can_place_on(agent, cell)</code>","text":"<p>True when the counter has no object on it.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def can_place_on(self, agent: GridAgent, cell: GridObj) -&gt; bool:\n    \"\"\"True when the counter has no object on it.\"\"\"\n    return self.obj_placed_on is None\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Counter.render","title":"<code>render(tile_img)</code>","text":"<p>Draw counter and any object placed on it.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw counter and any object placed on it.\"\"\"\n    super().render(tile_img)\n\n    if self.obj_placed_on is not None:\n        self.obj_placed_on.render(tile_img)\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Counter.build_render_sync_fn","title":"<code>build_render_sync_fn()</code>  <code>classmethod</code>","text":"<p>Return a render-sync callback for counter objects.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>@classmethod\ndef build_render_sync_fn(cls):\n    \"\"\"Return a render-sync callback for counter objects.\"\"\"\n\n    def counter_render_sync(grid, env_state, scope):\n        \"\"\"Sync obj_placed_on for counters from object_state_map.\"\"\"\n        osm = env_state.object_state_map\n        for r in range(grid.height):\n            for c in range(grid.width):\n                cell = grid.get(r, c)\n                if cell is None or cell.object_id != \"counter\":\n                    continue\n                state_val = int(osm[r, c])\n                if state_val &gt; 0:\n                    placed_id = idx_to_object(state_val, scope=scope)\n                    cell.obj_placed_on = (\n                        make_object(placed_id, scope=scope) if placed_id else None\n                    )\n                else:\n                    cell.obj_placed_on = None\n\n    return counter_render_sync\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Key","title":"<code>Key</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A key that can be picked up to unlock doors.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>@register_object_type(\"key\", can_pickup=True)\nclass Key(GridObj):\n    \"\"\"A key that can be picked up to unlock doors.\"\"\"\n\n    object_id = \"key\"\n    color = constants.Colors.Yellow\n    char = \"K\"\n\n    def __init__(self, state=0):\n        \"\"\"Initialize key with given state.\"\"\"\n        super().__init__(state=state)\n\n    def can_pickup(self, agent: GridAgent):\n        \"\"\"Return True; keys are always pickable.\"\"\"\n        return True\n\n    def render(self, tile_img):\n        \"\"\"Draw key icon with ring and teeth.\"\"\"\n        # Vertical quad\n        fill_coords(tile_img, point_in_rect(0.50, 0.63, 0.31, 0.88), self.color)\n\n        # Teeth\n        fill_coords(tile_img, point_in_rect(0.38, 0.50, 0.59, 0.66), self.color)\n        fill_coords(tile_img, point_in_rect(0.38, 0.50, 0.81, 0.88), self.color)\n\n        # Ring\n        fill_coords(tile_img, point_in_circle(cx=0.56, cy=0.28, r=0.190), self.color)\n        fill_coords(tile_img, point_in_circle(cx=0.56, cy=0.28, r=0.064), (0, 0, 0))\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Key.__init__","title":"<code>__init__(state=0)</code>","text":"<p>Initialize key with given state.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def __init__(self, state=0):\n    \"\"\"Initialize key with given state.\"\"\"\n    super().__init__(state=state)\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Key.can_pickup","title":"<code>can_pickup(agent)</code>","text":"<p>Return True; keys are always pickable.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def can_pickup(self, agent: GridAgent):\n    \"\"\"Return True; keys are always pickable.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Key.render","title":"<code>render(tile_img)</code>","text":"<p>Draw key icon with ring and teeth.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw key icon with ring and teeth.\"\"\"\n    # Vertical quad\n    fill_coords(tile_img, point_in_rect(0.50, 0.63, 0.31, 0.88), self.color)\n\n    # Teeth\n    fill_coords(tile_img, point_in_rect(0.38, 0.50, 0.59, 0.66), self.color)\n    fill_coords(tile_img, point_in_rect(0.38, 0.50, 0.81, 0.88), self.color)\n\n    # Ring\n    fill_coords(tile_img, point_in_circle(cx=0.56, cy=0.28, r=0.190), self.color)\n    fill_coords(tile_img, point_in_circle(cx=0.56, cy=0.28, r=0.064), (0, 0, 0))\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Door","title":"<code>Door</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A door that can be open, closed, or locked (requires Key).</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>@register_object_type(\"door\")\nclass Door(GridObj):\n    \"\"\"A door that can be open, closed, or locked (requires Key).\"\"\"\n\n    object_id = \"door\"\n    color = constants.Colors.DarkGrey\n    char = \"D\"\n\n    def __init__(self, state):\n        \"\"\"Initialize door with state (0=locked, 1=closed, 2=open).\"\"\"\n        super().__init__(state=state)\n        self.is_open = state == 2\n        self.is_locked = state == 0\n\n    def can_overlap(self, agent: GridAgent) -&gt; bool:\n        \"\"\"The agent can only walk over this cell when the door is open.\"\"\"\n        return self.is_open\n\n    def see_behind(self, agent: GridAgent) -&gt; bool:\n        \"\"\"Return True only when the door is open.\"\"\"\n        return self.is_open\n\n    def toggle(self, env, agent: GridAgent) -&gt; bool:\n        \"\"\"Unlock (if agent has Key) or open/close the door.\"\"\"\n        if self.is_locked:\n            if any([isinstance(obj, Key) for obj in agent.inventory]):\n                self.is_locked = False\n                self.is_open = True\n                return True\n            return False\n\n        self.is_open = not self.is_open\n        return True\n\n    def encode(self, encode_char=False):\n        \"\"\"Encode the door as a 3-tuple of integers.\"\"\"\n        # State, 0: open, 1: closed, 2: locked\n        if self.is_open:\n            self.state = 2\n        elif self.is_locked:\n            self.state = 0\n        # if door is closed and unlocked\n        elif not self.is_open:\n            self.state = 1\n        else:\n            raise ValueError(\n                f\"No possible state encoding for door: open={self.is_open}, locked={self.is_locked}\"\n            )\n\n        return super().encode(encode_char=encode_char)\n\n    def render(self, tile_img):\n        \"\"\"Draw the door based on its state (open, closed, or locked).\"\"\"\n        if self.state == 2:\n            fill_coords(tile_img, point_in_rect(0.88, 1.00, 0.00, 1.00), self.color)\n            fill_coords(tile_img, point_in_rect(0.92, 0.96, 0.04, 0.96), (0, 0, 0))\n            return\n\n        # Door frame and door\n        if self.state == 0:\n            fill_coords(tile_img, point_in_rect(0.00, 1.00, 0.00, 1.00), self.color)\n            fill_coords(\n                tile_img,\n                point_in_rect(0.06, 0.94, 0.06, 0.94),\n                0.45 * np.array(self.color),\n            )\n\n            # Draw key slot\n            fill_coords(tile_img, point_in_rect(0.52, 0.75, 0.50, 0.56), self.color)\n        else:\n            fill_coords(tile_img, point_in_rect(0.00, 1.00, 0.00, 1.00), self.color)\n            fill_coords(tile_img, point_in_rect(0.04, 0.96, 0.04, 0.96), (0, 0, 0))\n            fill_coords(tile_img, point_in_rect(0.08, 0.92, 0.08, 0.92), self.color)\n            fill_coords(tile_img, point_in_rect(0.12, 0.88, 0.12, 0.88), (0, 0, 0))\n\n            # Draw door handle\n            fill_coords(tile_img, point_in_circle(cx=0.75, cy=0.50, r=0.08), self.color)\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Door.__init__","title":"<code>__init__(state)</code>","text":"<p>Initialize door with state (0=locked, 1=closed, 2=open).</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def __init__(self, state):\n    \"\"\"Initialize door with state (0=locked, 1=closed, 2=open).\"\"\"\n    super().__init__(state=state)\n    self.is_open = state == 2\n    self.is_locked = state == 0\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Door.can_overlap","title":"<code>can_overlap(agent)</code>","text":"<p>The agent can only walk over this cell when the door is open.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def can_overlap(self, agent: GridAgent) -&gt; bool:\n    \"\"\"The agent can only walk over this cell when the door is open.\"\"\"\n    return self.is_open\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Door.see_behind","title":"<code>see_behind(agent)</code>","text":"<p>Return True only when the door is open.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def see_behind(self, agent: GridAgent) -&gt; bool:\n    \"\"\"Return True only when the door is open.\"\"\"\n    return self.is_open\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Door.toggle","title":"<code>toggle(env, agent)</code>","text":"<p>Unlock (if agent has Key) or open/close the door.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def toggle(self, env, agent: GridAgent) -&gt; bool:\n    \"\"\"Unlock (if agent has Key) or open/close the door.\"\"\"\n    if self.is_locked:\n        if any([isinstance(obj, Key) for obj in agent.inventory]):\n            self.is_locked = False\n            self.is_open = True\n            return True\n        return False\n\n    self.is_open = not self.is_open\n    return True\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Door.encode","title":"<code>encode(encode_char=False)</code>","text":"<p>Encode the door as a 3-tuple of integers.</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def encode(self, encode_char=False):\n    \"\"\"Encode the door as a 3-tuple of integers.\"\"\"\n    # State, 0: open, 1: closed, 2: locked\n    if self.is_open:\n        self.state = 2\n    elif self.is_locked:\n        self.state = 0\n    # if door is closed and unlocked\n    elif not self.is_open:\n        self.state = 1\n    else:\n        raise ValueError(\n            f\"No possible state encoding for door: open={self.is_open}, locked={self.is_locked}\"\n        )\n\n    return super().encode(encode_char=encode_char)\n</code></pre>"},{"location":"reference/cogrid/core/grid_objects/#cogrid.core.grid_objects.Door.render","title":"<code>render(tile_img)</code>","text":"<p>Draw the door based on its state (open, closed, or locked).</p> Source code in <code>cogrid/core/grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw the door based on its state (open, closed, or locked).\"\"\"\n    if self.state == 2:\n        fill_coords(tile_img, point_in_rect(0.88, 1.00, 0.00, 1.00), self.color)\n        fill_coords(tile_img, point_in_rect(0.92, 0.96, 0.04, 0.96), (0, 0, 0))\n        return\n\n    # Door frame and door\n    if self.state == 0:\n        fill_coords(tile_img, point_in_rect(0.00, 1.00, 0.00, 1.00), self.color)\n        fill_coords(\n            tile_img,\n            point_in_rect(0.06, 0.94, 0.06, 0.94),\n            0.45 * np.array(self.color),\n        )\n\n        # Draw key slot\n        fill_coords(tile_img, point_in_rect(0.52, 0.75, 0.50, 0.56), self.color)\n    else:\n        fill_coords(tile_img, point_in_rect(0.00, 1.00, 0.00, 1.00), self.color)\n        fill_coords(tile_img, point_in_rect(0.04, 0.96, 0.04, 0.96), (0, 0, 0))\n        fill_coords(tile_img, point_in_rect(0.08, 0.92, 0.08, 0.92), self.color)\n        fill_coords(tile_img, point_in_rect(0.12, 0.88, 0.12, 0.88), (0, 0, 0))\n\n        # Draw door handle\n        fill_coords(tile_img, point_in_circle(cx=0.75, cy=0.50, r=0.08), self.color)\n</code></pre>"},{"location":"reference/cogrid/core/grid_utils/","title":"grid_utils","text":""},{"location":"reference/cogrid/core/grid_utils/#cogrid.core.grid_utils","title":"<code>cogrid.core.grid_utils</code>","text":"<p>Grid utility functions for layout conversion and adjacency.</p>"},{"location":"reference/cogrid/core/grid_utils/#cogrid.core.grid_utils.ascii_to_numpy","title":"<code>ascii_to_numpy(ascii_list)</code>","text":"<p>Convert an ASCII grid representation to a numpy array.</p> Source code in <code>cogrid/core/grid_utils.py</code> <pre><code>def ascii_to_numpy(ascii_list):\n    \"\"\"Convert an ASCII grid representation to a numpy array.\"\"\"\n    rows, cols = len(ascii_list), len(ascii_list[0])\n    for row in range(0, rows):\n        assert len(ascii_list[row]) == cols, print(\"The ascii map is not rectangular!\")\n    arr = np.full((rows, cols), GridConstants.FreeSpace)\n    for row in range(arr.shape[0]):\n        for col in range(arr.shape[1]):\n            arr[row, col] = ascii_list[row][col]\n    return arr\n</code></pre>"},{"location":"reference/cogrid/core/grid_utils/#cogrid.core.grid_utils.adjacent_positions","title":"<code>adjacent_positions(row, col)</code>","text":"<p>Yield the four cardinal neighbor positions.</p> Source code in <code>cogrid/core/grid_utils.py</code> <pre><code>def adjacent_positions(row, col):\n    \"\"\"Yield the four cardinal neighbor positions.\"\"\"\n    for rdelta, cdelta in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        yield row + rdelta, col + cdelta\n</code></pre>"},{"location":"reference/cogrid/core/grid_utils/#cogrid.core.grid_utils.layout_to_state","title":"<code>layout_to_state(grid, scope='global', scope_config=None)</code>","text":"<p>Convert a Grid instance into array-based state (type map, state map, wall map).</p> <p>Scope-specific state is extracted via scope_config's <code>state_extractor</code> if provided.</p> Source code in <code>cogrid/core/grid_utils.py</code> <pre><code>def layout_to_state(grid, scope: str = \"global\", scope_config=None) -&gt; dict:\n    \"\"\"Convert a Grid instance into array-based state (type map, state map, wall map).\n\n    Scope-specific state is extracted via scope_config's ``state_extractor``\n    if provided.\n    \"\"\"\n    from cogrid.core.grid_object import Wall, object_to_idx\n\n    height, width = grid.height, grid.width\n\n    # Always use numpy for layout construction (requires mutable in-place\n    # assignment).  Callers convert to JAX arrays when needed (e.g. in\n    # CoGridEnv.reset() JAX path).\n    object_type_map = np.zeros((height, width), dtype=np.int32)\n    object_state_map = np.zeros((height, width), dtype=np.int32)\n    wall_map = np.zeros((height, width), dtype=np.int32)\n\n    for r in range(height):\n        for c in range(width):\n            cell = grid.get(r, c)\n\n            if cell is None:\n                # Empty cell: type_id = 0, state = 0 (already initialized)\n                continue\n\n            type_id = object_to_idx(cell, scope=scope)\n            object_type_map[r, c] = type_id\n            object_state_map[r, c] = int(cell.state)\n\n            if isinstance(cell, Wall):\n                wall_map[r, c] = 1\n\n    # Spawn points are handled by _gen_grid before Grid.decode is called,\n    # so they won't appear in the grid. Return empty list here -- callers\n    # should use env.spawn_points from the CoGridEnv instead.\n    spawn_points = []\n\n    result = {\n        \"object_type_map\": object_type_map,\n        \"object_state_map\": object_state_map,\n        \"wall_map\": wall_map,\n        \"spawn_points\": spawn_points,\n    }\n\n    # Extract scope-specific container state (e.g. scope-specific container arrays)\n    state_extractor = scope_config.get(\"state_extractor\") if scope_config else None\n    if state_extractor is not None:\n        extra_state = state_extractor(grid, scope)\n        result.update(extra_state)\n\n    return result\n</code></pre>"},{"location":"reference/cogrid/core/grid_utils/#cogrid.core.grid_utils.grid_to_state","title":"<code>grid_to_state(grid, env_agents, scope='global', scope_config=None)</code>","text":"<p>Convenience wrapper: layout_to_state + create_agent_arrays.</p> Source code in <code>cogrid/core/grid_utils.py</code> <pre><code>def grid_to_state(grid, env_agents, scope: str = \"global\", scope_config=None) -&gt; dict:\n    \"\"\"Convenience wrapper: layout_to_state + create_agent_arrays.\"\"\"\n    from cogrid.core.agent import create_agent_arrays\n\n    result = layout_to_state(grid, scope=scope, scope_config=scope_config)\n    agent_arrays = create_agent_arrays(env_agents, scope=scope)\n    result.update(agent_arrays)\n    return result\n</code></pre>"},{"location":"reference/cogrid/core/interactions/","title":"interactions","text":""},{"location":"reference/cogrid/core/interactions/#cogrid.core.interactions","title":"<code>cogrid.core.interactions</code>","text":"<p>Vectorized interaction processing using integer lookup tables.</p> <p>Core modules contain only generic infrastructure. Environment-specific interaction logic is delegated via an explicit <code>interaction_fn</code> parameter.</p> <p>Key function:</p> <ul> <li><code>process_interactions()</code> -- handles pickup, drop, place_on interactions   for all agents using xp array operations. Processes agents sequentially   (lower index = higher priority) with vectorized condition computation.</li> </ul>"},{"location":"reference/cogrid/core/interactions/#cogrid.core.interactions.process_interactions","title":"<code>process_interactions(state, actions, interaction_fn, lookup_tables, scope_config, dir_vec_table, action_pickup_drop_idx, action_toggle_idx)</code>","text":"<p>Process pickup/drop/place_on interactions for all agents.</p> <p>Priority order: (1) pickup, (2) pickup_from (scope-specific), (3) drop on empty, (4) place_on. Agents are processed sequentially (lower index = higher priority).</p> <p>Returns updated <code>state</code>.</p> Source code in <code>cogrid/core/interactions.py</code> <pre><code>def process_interactions(\n    state,  # EnvState\n    actions,  # (n_agents,) int32\n    interaction_fn,  # callable or None\n    lookup_tables,  # dict with CAN_PICKUP, CAN_OVERLAP, CAN_PLACE_ON, CAN_PICKUP_FROM\n    scope_config,  # scope config dict (passed through to interaction_fn)\n    dir_vec_table,  # (4, 2) int32\n    action_pickup_drop_idx,  # int -- index of PickupDrop action\n    action_toggle_idx,  # int -- index of Toggle action\n):\n    \"\"\"Process pickup/drop/place_on interactions for all agents.\n\n    Priority order: (1) pickup, (2) pickup_from (scope-specific),\n    (3) drop on empty, (4) place_on. Agents are processed sequentially\n    (lower index = higher priority).\n\n    Returns updated ``state``.\n    \"\"\"\n    n_agents = state.agent_pos.shape[0]\n    H, W = state.object_type_map.shape\n\n    CAN_PICKUP = lookup_tables[\"CAN_PICKUP\"]\n    CAN_PLACE_ON = lookup_tables[\"CAN_PLACE_ON\"]\n\n    # Compute forward positions for ALL agents\n    fwd_pos = state.agent_pos + dir_vec_table[state.agent_dir]  # (n_agents, 2)\n    fwd_r = xp.clip(fwd_pos[:, 0], 0, H - 1)\n    fwd_c = xp.clip(fwd_pos[:, 1], 0, W - 1)\n\n    # Which agents are interacting\n    is_interact = actions == action_pickup_drop_idx\n\n    # Agent-ahead check for each agent (vectorized pairwise)\n    # fwd_matches_pos[i,j] = True iff agent i's forward pos == agent j's position\n    fwd_rc = xp.stack([fwd_r, fwd_c], axis=1)  # (n_agents, 2)\n    fwd_matches_pos = xp.all(fwd_rc[:, None, :] == state.agent_pos[None, :, :], axis=2)\n    not_self = ~xp.eye(n_agents, dtype=xp.bool_)\n    agent_ahead = xp.any(fwd_matches_pos &amp; not_self, axis=1)\n\n    base_ok = is_interact &amp; ~agent_ahead  # (n_agents,) bool\n\n    if interaction_fn is not None:\n        # Scope with interaction_fn: process agents sequentially.\n        # Lower-index agents have priority (process first, mutations visible\n        # to later agents). n_agents is a static shape dim, so this Python\n        # range loop unrolls at trace time -- no lax.fori_loop needed.\n        for i in range(n_agents):\n            state = interaction_fn(state, i, fwd_r[i], fwd_c[i], base_ok[i], scope_config)\n    else:\n        # Generic scope: handle branches 1, 3, 4 without scope-specific handler.\n        agent_inv = state.agent_inv\n        object_type_map = state.object_type_map\n        object_state_map = state.object_state_map\n\n        for agent_idx in range(n_agents):\n            fwd_type = object_type_map[fwd_r[agent_idx], fwd_c[agent_idx]]\n            inv_item = agent_inv[agent_idx, 0]\n            ok = base_ok[agent_idx]\n\n            # Branch 1: can_pickup\n            b1_cond = ok &amp; (fwd_type &gt; 0) &amp; (CAN_PICKUP[fwd_type] == 1) &amp; (inv_item == -1)\n\n            b1_inv = set_at(agent_inv, (agent_idx, 0), fwd_type)\n            b1_otm = set_at_2d(object_type_map, fwd_r[agent_idx], fwd_c[agent_idx], 0)\n            b1_osm = set_at_2d(object_state_map, fwd_r[agent_idx], fwd_c[agent_idx], 0)\n\n            # Branch 3: drop on empty\n            b3_cond = ok &amp; ~b1_cond &amp; (fwd_type == 0) &amp; (inv_item != -1)\n\n            b3_otm = set_at_2d(object_type_map, fwd_r[agent_idx], fwd_c[agent_idx], inv_item)\n            b3_osm = set_at_2d(object_state_map, fwd_r[agent_idx], fwd_c[agent_idx], 0)\n            b3_inv = set_at(agent_inv, (agent_idx, 0), -1)\n\n            # Branch 4: generic place_on\n            b4_cond = (\n                ok\n                &amp; ~b1_cond\n                &amp; ~b3_cond\n                &amp; (fwd_type &gt; 0)\n                &amp; (CAN_PLACE_ON[fwd_type] == 1)\n                &amp; (inv_item != -1)\n                &amp; (object_state_map[fwd_r[agent_idx], fwd_c[agent_idx]] == 0)\n            )\n\n            b4_osm = set_at_2d(object_state_map, fwd_r[agent_idx], fwd_c[agent_idx], inv_item)\n            b4_inv = set_at(agent_inv, (agent_idx, 0), -1)\n\n            # Apply updates with cascading xp.where\n            agent_inv = xp.where(b1_cond, b1_inv, agent_inv)\n            agent_inv = xp.where(b3_cond, b3_inv, agent_inv)\n            agent_inv = xp.where(b4_cond, b4_inv, agent_inv)\n\n            object_type_map = xp.where(b1_cond, b1_otm, object_type_map)\n            object_type_map = xp.where(b3_cond, b3_otm, object_type_map)\n\n            object_state_map = xp.where(b1_cond, b1_osm, object_state_map)\n            object_state_map = xp.where(b3_cond, b3_osm, object_state_map)\n            object_state_map = xp.where(b4_cond, b4_osm, object_state_map)\n\n        state = dataclasses.replace(\n            state,\n            agent_inv=agent_inv,\n            object_type_map=object_type_map,\n            object_state_map=object_state_map,\n        )\n\n    return state\n</code></pre>"},{"location":"reference/cogrid/core/layout_parser/","title":"layout_parser","text":""},{"location":"reference/cogrid/core/layout_parser/#cogrid.core.layout_parser","title":"<code>cogrid.core.layout_parser</code>","text":"<p>Array-based layout parser with symbol registry.</p> <p>Parses ASCII layout strings directly into a fully initialized :class:<code>~cogrid.backend.env_state.EnvState</code> without creating any Grid, GridObj, or Agent objects.</p> <p>Symbol mappings can be registered per-scope via :func:<code>register_symbols</code> or included in the scope config's <code>symbol_table</code> key. The parser checks both sources (explicit registry first, scope config as fallback).</p> <p>Parsing always uses numpy (layouts are small, init-time only). Arrays are converted to JAX arrays when the JAX backend is active.</p> <p>Usage::</p> <pre><code>from cogrid.core.layout_parser import register_symbols, parse_layout\nfrom cogrid.core.autowire import build_scope_config_from_components\n\nregister_symbols(\"overcooked\", {\n    \"#\": {\"object_id\": \"wall\", \"is_wall\": True},\n    \"U\": {\"object_id\": \"pot\"},\n    ...\n})\n\nscope_config = build_scope_config_from_components(\"overcooked\")\nstate = parse_layout(layout_strings, \"overcooked\", scope_config)\n</code></pre>"},{"location":"reference/cogrid/core/layout_parser/#cogrid.core.layout_parser.register_symbols","title":"<code>register_symbols(scope, symbols)</code>","text":"<p>Register char-to-properties mappings for a scope.</p> <p>Example entry: <code>{\"#\": {\"object_id\": \"wall\", \"is_wall\": True}}</code>.</p> Source code in <code>cogrid/core/layout_parser.py</code> <pre><code>def register_symbols(scope: str, symbols: dict[str, dict]) -&gt; None:\n    \"\"\"Register char-to-properties mappings for a scope.\n\n    Example entry: ``{\"#\": {\"object_id\": \"wall\", \"is_wall\": True}}``.\n    \"\"\"\n    SYMBOL_REGISTRY[scope] = symbols\n</code></pre>"},{"location":"reference/cogrid/core/layout_parser/#cogrid.core.layout_parser.get_symbols","title":"<code>get_symbols(scope, scope_config=None)</code>","text":"<p>Return symbol mappings for a scope.</p> <p>Checks :data:<code>SYMBOL_REGISTRY</code> first, falls back to <code>scope_config[\"symbol_table\"]</code>.</p> Source code in <code>cogrid/core/layout_parser.py</code> <pre><code>def get_symbols(scope: str, scope_config: dict | None = None) -&gt; dict[str, dict]:\n    \"\"\"Return symbol mappings for a scope.\n\n    Checks :data:`SYMBOL_REGISTRY` first, falls back to\n    ``scope_config[\"symbol_table\"]``.\n    \"\"\"\n    if scope in SYMBOL_REGISTRY:\n        return SYMBOL_REGISTRY[scope]\n    if scope_config and scope_config.get(\"symbol_table\"):\n        return scope_config[\"symbol_table\"]\n    raise ValueError(\n        f\"No symbol mappings found for scope '{scope}'. \"\n        \"Call register_symbols() or include 'symbol_table' in scope config.\"\n    )\n</code></pre>"},{"location":"reference/cogrid/core/layout_parser/#cogrid.core.layout_parser.parse_layout","title":"<code>parse_layout(layout_strings, scope, scope_config, n_agents=2, action_set='cardinal', rng_key=None)</code>","text":"<p>Parse ASCII layout strings directly into a fully initialized EnvState.</p> <p>No Grid, GridObj, or Agent objects are created. Special characters: <code>' '</code> (empty), <code>'#'</code> (wall), <code>'+'</code> (spawn); all others are looked up in the symbol table.</p> <p>Calls the scope config's <code>extra_state_builder</code> if present, then validates against <code>extra_state_schema</code>. Arrays are converted to JAX when the JAX backend is active.</p> Source code in <code>cogrid/core/layout_parser.py</code> <pre><code>def parse_layout(\n    layout_strings: list[str],\n    scope: str,\n    scope_config: dict,\n    n_agents: int = 2,\n    action_set: str = \"cardinal\",\n    rng_key=None,\n) -&gt; EnvState:\n    \"\"\"Parse ASCII layout strings directly into a fully initialized EnvState.\n\n    No Grid, GridObj, or Agent objects are created. Special characters:\n    ``' '`` (empty), ``'#'`` (wall), ``'+'`` (spawn); all others are\n    looked up in the symbol table.\n\n    Calls the scope config's ``extra_state_builder`` if present, then\n    validates against ``extra_state_schema``. Arrays are converted to\n    JAX when the JAX backend is active.\n    \"\"\"\n    from cogrid.backend import get_backend\n    from cogrid.backend.env_state import create_env_state, validate_extra_state\n\n    symbols = get_symbols(scope, scope_config)\n\n    height = len(layout_strings)\n    width = max(len(row) for row in layout_strings)\n\n    # Build grid arrays with numpy (init-time only).\n    wall_map = np.zeros((height, width), dtype=np.int32)\n    object_type_map = np.zeros((height, width), dtype=np.int32)\n    object_state_map = np.zeros((height, width), dtype=np.int32)\n    spawn_positions: list[tuple[int, int]] = []\n\n    wall_type_id = object_to_idx(\"wall\", scope=scope)\n\n    for r, row in enumerate(layout_strings):\n        for c, char in enumerate(row):\n            if char == \" \":\n                # Free space -- cell stays 0.\n                continue\n\n            if char == \"+\":\n                # Spawn position -- collect but leave cell empty.\n                spawn_positions.append((r, c))\n                continue\n\n            sym = symbols.get(char)\n            if sym is None:\n                raise ValueError(\n                    f\"Unknown symbol '{char}' at row {r}, col {c} \"\n                    f\"for scope '{scope}'. \"\n                    f\"Available symbols: {list(symbols.keys())}\"\n                )\n\n            object_id = sym.get(\"object_id\")\n            is_wall = sym.get(\"is_wall\", False)\n            is_spawn = sym.get(\"is_spawn\", False)\n\n            if is_spawn:\n                spawn_positions.append((r, c))\n                continue\n\n            if object_id is not None:\n                type_id = object_to_idx(object_id, scope=scope)\n                object_type_map[r, c] = type_id\n\n            if is_wall:\n                wall_map[r, c] = 1\n                # Ensure wall type ID is set even if object_id wasn't\n                # explicitly \"wall\" (defensive).\n                if object_id is None:\n                    object_type_map[r, c] = wall_type_id\n\n    # Build extra_state via scope config builder.\n    parsed_arrays = {\n        \"object_type_map\": object_type_map,\n        \"wall_map\": wall_map,\n        \"object_state_map\": object_state_map,\n    }\n\n    extra_state_builder = scope_config.get(\"extra_state_builder\")\n    if extra_state_builder is not None:\n        extra_state = extra_state_builder(parsed_arrays, scope)\n    else:\n        extra_state = {}\n\n    # Validate extra_state against schema.\n    schema = scope_config.get(\"extra_state_schema\", {})\n    if schema:\n        validate_extra_state(extra_state, schema)\n\n    # Build agent arrays from spawn positions.\n    agent_pos = np.zeros((n_agents, 2), dtype=np.int32)\n    for i in range(min(n_agents, len(spawn_positions))):\n        agent_pos[i] = spawn_positions[i]\n\n    agent_dir = np.zeros(n_agents, dtype=np.int32)\n    agent_inv = np.full((n_agents, 1), -1, dtype=np.int32)\n    done = np.zeros(n_agents, dtype=np.bool_)\n    time_step = np.int32(0)\n\n    # Convert to JAX arrays if backend is active.\n    if get_backend() == \"jax\":\n        import jax.numpy as jnp\n\n        wall_map = jnp.array(wall_map)\n        object_type_map = jnp.array(object_type_map)\n        object_state_map = jnp.array(object_state_map)\n        agent_pos = jnp.array(agent_pos)\n        agent_dir = jnp.array(agent_dir)\n        agent_inv = jnp.array(agent_inv)\n        done = jnp.array(done)\n        time_step = jnp.int32(0)\n        extra_state = {k: jnp.array(v) for k, v in extra_state.items()}\n\n    return create_env_state(\n        agent_pos=agent_pos,\n        agent_dir=agent_dir,\n        agent_inv=agent_inv,\n        wall_map=wall_map,\n        object_type_map=object_type_map,\n        object_state_map=object_state_map,\n        extra_state=extra_state,\n        rng_key=rng_key,\n        time=time_step,\n        done=done,\n        n_agents=n_agents,\n        height=height,\n        width=width,\n        action_set=action_set,\n    )\n</code></pre>"},{"location":"reference/cogrid/core/layouts/","title":"layouts","text":""},{"location":"reference/cogrid/core/layouts/#cogrid.core.layouts","title":"<code>cogrid.core.layouts</code>","text":"<p>Layout storage and retrieval.</p>"},{"location":"reference/cogrid/core/layouts/#cogrid.core.layouts.get_layout","title":"<code>get_layout(layout_id, **kwargs)</code>","text":"<p>Retrieve a registered layout by name.</p> Source code in <code>cogrid/core/layouts.py</code> <pre><code>def get_layout(layout_id: str, **kwargs) -&gt; tuple[list[str], list[int]]:\n    \"\"\"Retrieve a registered layout by name.\"\"\"\n    return LAYOUT_REGISTRY[layout_id]\n</code></pre>"},{"location":"reference/cogrid/core/layouts/#cogrid.core.layouts.register_layout","title":"<code>register_layout(layout_id, layout, state_encoding=None)</code>","text":"<p>Register a named layout in the global layout store.</p> Source code in <code>cogrid/core/layouts.py</code> <pre><code>def register_layout(\n    layout_id: str,\n    layout: list[str],\n    state_encoding: list[list[int]] | np.ndarray | None = None,\n) -&gt; None:\n    \"\"\"Register a named layout in the global layout store.\"\"\"\n    if state_encoding is None:\n        state_encoding = np.zeros((len(layout), len(layout[0])))\n\n    if layout_id in LAYOUT_REGISTRY:\n        raise ValueError(\n            f\"There is already a layout registered with ID {layout_id}. Please use a unique ID.\"\n        )\n\n    LAYOUT_REGISTRY[layout_id] = (layout, state_encoding)\n</code></pre>"},{"location":"reference/cogrid/core/movement/","title":"movement","text":""},{"location":"reference/cogrid/core/movement/#cogrid.core.movement","title":"<code>cogrid.core.movement</code>","text":"<p>Vectorized movement resolution for CoGrid environments.</p> <p>Provides a single :func:<code>move_agents</code> function that computes new agent positions and directions using pure <code>xp</code> array operations. Collision resolution and swap detection are fully vectorized via pairwise conflict matrices and priority masking -- no Python loops, no <code>lax.fori_loop</code>.</p> <p>The caller supplies a pre-computed <code>priority</code> array (agent indices in resolution order), keeping this module free of backend-specific RNG logic.</p> <p>Usage::</p> <pre><code>from cogrid.core.movement import move_agents\n\nnew_pos, new_dir = move_agents(\n    agent_pos,\n    agent_dir,\n    actions,\n    wall_map,\n    object_type_map,\n    can_overlap,\n    priority,\n    action_set,\n)\n</code></pre>"},{"location":"reference/cogrid/core/movement/#cogrid.core.movement.move_agents","title":"<code>move_agents(agent_pos, agent_dir, actions, wall_map, object_type_map, can_overlap, priority, action_set)</code>","text":"<p>Compute new positions and directions with collision/swap resolution.</p> <p><code>priority[0]</code> is the highest-priority agent (caller provides via <code>rng.permutation</code>). Returns <code>(new_pos, new_dir)</code>.</p> Source code in <code>cogrid/core/movement.py</code> <pre><code>def move_agents(\n    agent_pos,  # (n_agents, 2) int32 -- current positions [row, col]\n    agent_dir,  # (n_agents,) int32 -- current directions\n    actions,  # (n_agents,) int32 -- action indices\n    wall_map,  # (H, W) int32 -- 1 where walls exist\n    object_type_map,  # (H, W) int32 -- type IDs at each cell\n    can_overlap,  # (n_types,) int32 -- 1 if overlappable, 0 if not\n    priority,  # (n_agents,) int32 -- pre-computed priority ordering\n    action_set,  # str -- \"cardinal\" or \"rotation\"\n):\n    \"\"\"Compute new positions and directions with collision/swap resolution.\n\n    ``priority[0]`` is the highest-priority agent (caller provides via\n    ``rng.permutation``). Returns ``(new_pos, new_dir)``.\n    \"\"\"\n    new_dir, is_mover = _update_directions(agent_dir, actions, action_set)\n    proposed = _compute_proposed_positions(\n        agent_pos,\n        new_dir,\n        is_mover,\n        wall_map,\n        object_type_map,\n        can_overlap,\n    )\n    final_pos = _resolve_collisions(proposed, agent_pos, priority)\n    final_pos = _resolve_swaps(final_pos, agent_pos)\n    return final_pos, new_dir\n</code></pre>"},{"location":"reference/cogrid/core/rewards/","title":"rewards","text":""},{"location":"reference/cogrid/core/rewards/#cogrid.core.rewards","title":"<code>cogrid.core.rewards</code>","text":"<p>Generic reward composition utility.</p> <p>Provides the <code>Reward</code> base class for reward components. Reward composition is handled automatically by the auto-wiring layer in <code>cogrid.core.autowire.build_reward_config_from_components()</code>.</p> <p>Environment-specific reward functions live in their respective envs/ modules: - Overcooked: <code>cogrid.envs.overcooked.rewards</code></p>"},{"location":"reference/cogrid/core/rewards/#cogrid.core.rewards.Reward","title":"<code>Reward</code>","text":"<p>Base class for reward functions.</p> <p>Subclasses define compute() which receives StateView objects and returns (n_agents,) float32 reward arrays. The returned values are the final rewards -- apply any scaling or broadcasting inside compute().</p> <p>Usage::</p> <pre><code>@register_reward_type(\"delivery\", scope=\"overcooked\")\nclass DeliveryReward(Reward):\n    def compute(self, prev_state, state, actions, reward_config):\n        ...\n        return rewards  # (n_agents,) float32\n</code></pre> Source code in <code>cogrid/core/rewards.py</code> <pre><code>class Reward:\n    \"\"\"Base class for reward functions.\n\n    Subclasses define compute() which receives StateView objects and returns\n    (n_agents,) float32 reward arrays. The returned values are the final\n    rewards -- apply any scaling or broadcasting inside compute().\n\n    Usage::\n\n        @register_reward_type(\"delivery\", scope=\"overcooked\")\n        class DeliveryReward(Reward):\n            def compute(self, prev_state, state, actions, reward_config):\n                ...\n                return rewards  # (n_agents,) float32\n    \"\"\"\n\n    def compute(self, prev_state, state, actions, reward_config):\n        \"\"\"Compute and return (n_agents,) float32 reward array.\n\n        Subclasses must override.\n        \"\"\"\n        raise NotImplementedError(\n            f\"{type(self).__name__}.compute() is not implemented. \"\n            f\"Subclasses must override compute().\"\n        )\n</code></pre>"},{"location":"reference/cogrid/core/rewards/#cogrid.core.rewards.Reward.compute","title":"<code>compute(prev_state, state, actions, reward_config)</code>","text":"<p>Compute and return (n_agents,) float32 reward array.</p> <p>Subclasses must override.</p> Source code in <code>cogrid/core/rewards.py</code> <pre><code>def compute(self, prev_state, state, actions, reward_config):\n    \"\"\"Compute and return (n_agents,) float32 reward array.\n\n    Subclasses must override.\n    \"\"\"\n    raise NotImplementedError(\n        f\"{type(self).__name__}.compute() is not implemented. \"\n        f\"Subclasses must override compute().\"\n    )\n</code></pre>"},{"location":"reference/cogrid/core/roles/","title":"roles","text":""},{"location":"reference/cogrid/core/roles/#cogrid.core.roles","title":"<code>cogrid.core.roles</code>","text":"<p>Agent role definitions for role-based environments.</p>"},{"location":"reference/cogrid/core/roles/#cogrid.core.roles.Roles","title":"<code>Roles</code>  <code>dataclass</code>","text":"<p>Named roles for role-based task assignment.</p> Source code in <code>cogrid/core/roles.py</code> <pre><code>@dataclasses.dataclass\nclass Roles:\n    \"\"\"Named roles for role-based task assignment.\"\"\"\n\n    Medic = \"medic\"\n    Engineer = \"engineer\"\n</code></pre>"},{"location":"reference/cogrid/core/step_pipeline/","title":"step_pipeline","text":""},{"location":"reference/cogrid/core/step_pipeline/#cogrid.core.step_pipeline","title":"<code>cogrid.core.step_pipeline</code>","text":"<p>Unified step and reset pipeline for CoGrid environments.</p> <p>Replaces the JAX-only <code>jax_step.py</code> with backend-agnostic functions that work on both numpy and JAX via <code>xp</code>.  Backend-specific code (RNG splitting, <code>stop_gradient</code>) is isolated to <code>get_backend()</code> conditionals -- everything else uses the <code>xp</code> array namespace.</p> <p>The three public functions compose all Phase 5-7 sub-functions (<code>move_agents</code>, <code>process_interactions</code>, <code>get_all_agent_obs</code>, <code>compute_rewards</code>, scope-config tick handler) into a pure pipeline operating on :class:<code>~cogrid.backend.env_state.EnvState</code>.</p> <p>Public API:</p> <ul> <li>:func:<code>envstate_to_dict</code> -- zero-cost EnvState-to-dict conversion.</li> <li>:func:<code>step</code> -- end-to-end step: tick, move, interact, obs, rewards,   dones.</li> <li>:func:<code>reset</code> -- build initial EnvState and compute initial   observations.</li> <li>:func:<code>build_step_fn</code> -- init-time factory: closes over static config,   returns <code>(state, actions) -&gt; ...</code> closure (auto-JIT on JAX).</li> <li>:func:<code>build_reset_fn</code> -- init-time factory: closes over layout config,   returns <code>(rng) -&gt; (state, obs)</code> closure (auto-JIT on JAX).</li> </ul> <p>Usage::</p> <pre><code>from cogrid.core.step_pipeline import step, reset, envstate_to_dict\nfrom cogrid.core.step_pipeline import build_step_fn, build_reset_fn\n</code></pre>"},{"location":"reference/cogrid/core/step_pipeline/#cogrid.core.step_pipeline.envstate_to_dict","title":"<code>envstate_to_dict(state)</code>","text":"<p>Convert EnvState to a StateView with dot access and scope-stripped extras.</p> <p>Zero-cost under JIT (no array copies). Extra_state keys like <code>\"scope.key\"</code> become <code>state_view.key</code>.</p> Source code in <code>cogrid/core/step_pipeline.py</code> <pre><code>def envstate_to_dict(state):\n    \"\"\"Convert EnvState to a StateView with dot access and scope-stripped extras.\n\n    Zero-cost under JIT (no array copies). Extra_state keys like\n    ``\"scope.key\"`` become ``state_view.key``.\n    \"\"\"\n    extra = {}\n    for key, val in state.extra_state.items():\n        short_key = key.split(\".\", 1)[-1] if \".\" in key else key\n        extra[short_key] = val\n\n    return StateView(\n        agent_pos=state.agent_pos,\n        agent_dir=state.agent_dir,\n        agent_inv=state.agent_inv,\n        wall_map=state.wall_map,\n        object_type_map=state.object_type_map,\n        object_state_map=state.object_state_map,\n        extra=extra,\n    )\n</code></pre>"},{"location":"reference/cogrid/core/step_pipeline/#cogrid.core.step_pipeline.step","title":"<code>step(state, actions, *, scope_config, lookup_tables, feature_fn, reward_config, action_pickup_drop_idx, action_toggle_idx, max_steps, terminated_fn=None)</code>","text":"<p>End-to-end step: tick, move, interact, observe, reward, done.</p> <p>Keyword arguments are designed to be closed over via <code>build_step_fn</code>.</p> <p>Pipeline order: (1) capture prev_state, (2) tick, (3) movement, (4) interactions, (5) observations, (6) rewards, (7) terminateds/ truncateds, (8) stop_gradient (JAX only).</p> <p>Returns <code>(state, obs, rewards, terminateds, truncateds, infos)</code>.</p> Source code in <code>cogrid/core/step_pipeline.py</code> <pre><code>def step(\n    state,\n    actions,\n    *,\n    scope_config,\n    lookup_tables,\n    feature_fn,\n    reward_config,\n    action_pickup_drop_idx,\n    action_toggle_idx,\n    max_steps,\n    terminated_fn=None,\n):\n    \"\"\"End-to-end step: tick, move, interact, observe, reward, done.\n\n    Keyword arguments are designed to be closed over via ``build_step_fn``.\n\n    Pipeline order: (1) capture prev_state, (2) tick, (3) movement,\n    (4) interactions, (5) observations, (6) rewards, (7) terminateds/\n    truncateds, (8) stop_gradient (JAX only).\n\n    Returns ``(state, obs, rewards, terminateds, truncateds, infos)``.\n    \"\"\"\n    # a. Capture prev_state before ANY mutations (zero-cost, immutable)\n    prev_state = state\n\n    # b. Tick: delegate to scope config handler (if any)\n    tick_handler = scope_config.get(\"tick_handler\") if scope_config else None\n    if tick_handler is not None:\n        state = tick_handler(state, scope_config)\n\n    # c. Movement -- backend-specific RNG for priority\n    key, priority = _backend_rng(state.rng_key, \"permutation\", state.n_agents)\n\n    new_pos, new_dir = move_agents(\n        state.agent_pos,\n        state.agent_dir,\n        actions,\n        state.wall_map,\n        state.object_type_map,\n        lookup_tables[\"CAN_OVERLAP\"],\n        priority,\n        state.action_set,\n    )\n    state = dataclasses.replace(state, agent_pos=new_pos, agent_dir=new_dir, rng_key=key)\n\n    # d. Interactions\n    dir_vec_table = xp.array([[0, 1], [1, 0], [0, -1], [-1, 0]], dtype=xp.int32)\n    interaction_fn = scope_config.get(\"interaction_fn\") if scope_config else None\n\n    state = process_interactions(\n        state,\n        actions,\n        interaction_fn,\n        lookup_tables,\n        scope_config,\n        dir_vec_table,\n        action_pickup_drop_idx,\n        action_toggle_idx,\n    )\n    state = dataclasses.replace(state, time=state.time + 1)\n\n    # e. Observations\n    sv = envstate_to_dict(state)\n    obs = get_all_agent_obs(feature_fn, sv, state.n_agents)\n\n    # f. Rewards -- compute_fn comes from reward_config (no env-specific import)\n    prev_sv = envstate_to_dict(prev_state)\n    compute_fn = reward_config[\"compute_fn\"]\n    rewards = compute_fn(prev_sv, sv, actions, reward_config)\n\n    # g. Terminateds and truncateds\n    if terminated_fn is not None:\n        terminateds = terminated_fn(prev_sv, sv, reward_config)\n    else:\n        terminateds = xp.zeros(state.n_agents, dtype=xp.bool_)\n\n    truncated = state.time &gt;= max_steps\n    truncateds = xp.full(state.n_agents, truncated, dtype=xp.bool_)\n\n    # h. Zero out rewards for agents already done before this step\n    already_done = prev_state.done\n    rewards = xp.where(already_done, xp.zeros_like(rewards), rewards)\n\n    # i. Update done mask: once done, stays done\n    new_done = already_done | terminateds | truncateds\n    state = dataclasses.replace(state, done=new_done)\n\n    # j. Stop gradient (JAX only, no-op on numpy)\n    obs, rewards, terminateds, truncateds = _maybe_stop_gradient(\n        obs, rewards, terminateds, truncateds\n    )\n\n    # k. Return\n    return state, obs, rewards, terminateds, truncateds, {}\n</code></pre>"},{"location":"reference/cogrid/core/step_pipeline/#cogrid.core.step_pipeline.reset","title":"<code>reset(rng, *, layout_arrays, spawn_positions, n_agents, feature_fn, scope_config, action_set, max_inv_size=1)</code>","text":"<p>Build initial EnvState from pre-computed layout arrays.</p> <p>Layout data is pre-computed at init time; this function only randomizes agent initial directions. Returns <code>(state, obs)</code>.</p> Source code in <code>cogrid/core/step_pipeline.py</code> <pre><code>def reset(\n    rng,\n    *,\n    layout_arrays,\n    spawn_positions,\n    n_agents,\n    feature_fn,\n    scope_config,\n    action_set,\n    max_inv_size=1,\n):\n    \"\"\"Build initial EnvState from pre-computed layout arrays.\n\n    Layout data is pre-computed at init time; this function only\n    randomizes agent initial directions. Returns ``(state, obs)``.\n    \"\"\"\n    # Backend-specific RNG for random initial directions\n    key, agent_dir = _backend_rng(rng, \"directions\", n_agents)\n    agent_dir = agent_dir.astype(xp.int32)\n\n    # Agent positions from fixed spawn points\n    agent_pos = spawn_positions.astype(xp.int32)\n\n    # Empty inventory\n    agent_inv = xp.full((n_agents, max_inv_size), -1, dtype=xp.int32)\n\n    # Time starts at 0\n    time = xp.int32(0)\n\n    # Extract layout arrays\n    wall_map = layout_arrays[\"wall_map\"]\n    object_type_map = layout_arrays[\"object_type_map\"]\n    object_state_map = layout_arrays[\"object_state_map\"]\n\n    H, W = wall_map.shape\n\n    # Build extra_state generically: any layout_arrays key not in\n    # the base set is a scope-specific extra, prefixed with {scope}.\n    base_keys = {\"wall_map\", \"object_type_map\", \"object_state_map\"}\n    scope = scope_config.get(\"scope\", \"global\") if scope_config else \"global\"\n    extra_state = {}\n    for la_key, val in layout_arrays.items():\n        if la_key not in base_keys:\n            extra_state[f\"{scope}.{la_key}\"] = val\n\n    # Build EnvState\n    done = xp.zeros(n_agents, dtype=xp.bool_)\n    state = create_env_state(\n        agent_pos=agent_pos,\n        agent_dir=agent_dir,\n        agent_inv=agent_inv,\n        wall_map=wall_map,\n        object_type_map=object_type_map,\n        object_state_map=object_state_map,\n        extra_state=extra_state,\n        rng_key=key,\n        time=time,\n        done=done,\n        n_agents=n_agents,\n        height=H,\n        width=W,\n        action_set=action_set,\n    )\n\n    # Compute initial observations\n    sv = envstate_to_dict(state)\n    obs = get_all_agent_obs(feature_fn, sv, n_agents)\n\n    # Stop gradient (JAX only, no-op on numpy)\n    (obs,) = _maybe_stop_gradient(obs)\n\n    return state, obs\n</code></pre>"},{"location":"reference/cogrid/core/step_pipeline/#cogrid.core.step_pipeline.build_step_fn","title":"<code>build_step_fn(scope_config, lookup_tables, feature_fn, reward_config, action_pickup_drop_idx, action_toggle_idx, max_steps, terminated_fn=None, jit_compile=None)</code>","text":"<p>Close over static config and return a step function.</p> <p><code>(state, actions) -&gt; (state, obs, rewards, terminateds, truncateds, infos)</code></p> <p>Auto-JIT on JAX backend unless <code>jit_compile=False</code>.</p> Source code in <code>cogrid/core/step_pipeline.py</code> <pre><code>def build_step_fn(\n    scope_config,\n    lookup_tables,\n    feature_fn,\n    reward_config,\n    action_pickup_drop_idx,\n    action_toggle_idx,\n    max_steps,\n    terminated_fn=None,\n    jit_compile=None,\n):\n    \"\"\"Close over static config and return a step function.\n\n    ``(state, actions) -&gt; (state, obs, rewards, terminateds, truncateds, infos)``\n\n    Auto-JIT on JAX backend unless ``jit_compile=False``.\n    \"\"\"\n\n    def step_fn(state, actions):\n        return step(\n            state,\n            actions,\n            scope_config=scope_config,\n            lookup_tables=lookup_tables,\n            feature_fn=feature_fn,\n            reward_config=reward_config,\n            action_pickup_drop_idx=action_pickup_drop_idx,\n            action_toggle_idx=action_toggle_idx,\n            max_steps=max_steps,\n            terminated_fn=terminated_fn,\n        )\n\n    return _maybe_jit(step_fn, jit_compile)\n</code></pre>"},{"location":"reference/cogrid/core/step_pipeline/#cogrid.core.step_pipeline.build_reset_fn","title":"<code>build_reset_fn(layout_arrays, spawn_positions, n_agents, feature_fn, scope_config, action_set, jit_compile=None, **kwargs)</code>","text":"<p>Close over layout config and return a reset function.</p> <p><code>(rng) -&gt; (state, obs)</code></p> <p>Auto-JIT on JAX backend unless <code>jit_compile=False</code>.</p> Source code in <code>cogrid/core/step_pipeline.py</code> <pre><code>def build_reset_fn(\n    layout_arrays,\n    spawn_positions,\n    n_agents,\n    feature_fn,\n    scope_config,\n    action_set,\n    jit_compile=None,\n    **kwargs,\n):\n    \"\"\"Close over layout config and return a reset function.\n\n    ``(rng) -&gt; (state, obs)``\n\n    Auto-JIT on JAX backend unless ``jit_compile=False``.\n    \"\"\"\n\n    def reset_fn(rng):\n        return reset(\n            rng,\n            layout_arrays=layout_arrays,\n            spawn_positions=spawn_positions,\n            n_agents=n_agents,\n            feature_fn=feature_fn,\n            scope_config=scope_config,\n            action_set=action_set,\n            **kwargs,\n        )\n\n    return _maybe_jit(reset_fn, jit_compile)\n</code></pre>"},{"location":"reference/cogrid/core/typing/","title":"typing","text":""},{"location":"reference/cogrid/core/typing/#cogrid.core.typing","title":"<code>cogrid.core.typing</code>","text":"<p>Type aliases shared across the codebase.</p>"},{"location":"reference/cogrid/envs/","title":"envs","text":""},{"location":"reference/cogrid/envs/#cogrid.envs","title":"<code>cogrid.envs</code>","text":"<p>Environment definitions and registry.</p>"},{"location":"reference/cogrid/envs/#cogrid.envs.randomized_layout_fn","title":"<code>randomized_layout_fn(**kwargs)</code>","text":"<p>Return a randomly chosen Overcooked layout name and data.</p> Source code in <code>cogrid/envs/__init__.py</code> <pre><code>def randomized_layout_fn(**kwargs):\n    \"\"\"Return a randomly chosen Overcooked layout name and data.\"\"\"\n    layout_name = random.choice(\n        [\n            \"overcooked_cramped_room_v0\",\n            \"overcooked_asymmetric_advantages_v0\",\n            \"overcooked_coordination_ring_v0\",\n            \"overcooked_forced_coordination_v0\",\n            \"overcooked_counter_circuit_v0\",\n        ]\n    )\n    return layout_name, *layouts.get_layout(layout_name)\n</code></pre>"},{"location":"reference/cogrid/envs/registry/","title":"registry","text":""},{"location":"reference/cogrid/envs/registry/#cogrid.envs.registry","title":"<code>cogrid.envs.registry</code>","text":"<p>Environment registry for creating environments by name.</p>"},{"location":"reference/cogrid/envs/registry/#cogrid.envs.registry.make","title":"<code>make(environment_id, environment_scope='global', **kwargs)</code>","text":"<p>Create an environment instance by registered name.</p> Source code in <code>cogrid/envs/registry.py</code> <pre><code>def make(environment_id: str, environment_scope: str = \"global\", **kwargs) -&gt; cogrid_env.CoGridEnv:\n    \"\"\"Create an environment instance by registered name.\"\"\"\n    if environment_id not in ENVIRONMENT_REGISTRY:\n        raise ValueError(\n            f\"Environment ID {environment_id} is not registered. \"\n            f\"Please register it first. \\n \"\n            f\"Available environments: {list(ENVIRONMENT_REGISTRY.keys())}\"\n        )\n    return ENVIRONMENT_REGISTRY[environment_id](environment_scope=environment_scope, **kwargs)\n</code></pre>"},{"location":"reference/cogrid/envs/registry/#cogrid.envs.registry.register","title":"<code>register(environment_id, env_class)</code>","text":"<p>Register an environment factory by name.</p> Source code in <code>cogrid/envs/registry.py</code> <pre><code>def register(environment_id: str, env_class: cogrid_env.CoGridEnv) -&gt; None:\n    \"\"\"Register an environment factory by name.\"\"\"\n    ENVIRONMENT_REGISTRY[environment_id] = env_class\n</code></pre>"},{"location":"reference/cogrid/envs/goal_seeking/","title":"goal_seeking","text":""},{"location":"reference/cogrid/envs/goal_seeking/#cogrid.envs.goal_seeking","title":"<code>cogrid.envs.goal_seeking</code>","text":"<p>Goal-seeking environment.</p>"},{"location":"reference/cogrid/envs/goal_seeking/agent/","title":"agent","text":""},{"location":"reference/cogrid/envs/goal_seeking/agent/#cogrid.envs.goal_seeking.agent","title":"<code>cogrid.envs.goal_seeking.agent</code>","text":"<p>Goal-seeking environment agent.</p>"},{"location":"reference/cogrid/envs/goal_seeking/agent/#cogrid.envs.goal_seeking.agent.GoalSeekingAgent","title":"<code>GoalSeekingAgent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>Agent subclass for goal-seeking with goal position tracking.</p> Source code in <code>cogrid/envs/goal_seeking/agent.py</code> <pre><code>class GoalSeekingAgent(Agent):\n    \"\"\"Agent subclass for goal-seeking with goal position tracking.\"\"\"\n\n    def __init__(\n        self,\n        agent_id,\n        start_position,\n        env,\n        target_values,\n        config,\n    ):\n        \"\"\"Initialize goal-seeking agent with target values.\"\"\"\n        super().__init__(agent_id, start_position, env, config)\n\n        self.target_values = target_values\n\n        self.step_penalty = 0.01\n        self.collision_penalty = 0.05\n\n    def interact(self, char):\n        \"\"\"Handle interaction with a grid character.\"\"\"\n        raise NotImplementedError(\"Must add in reward modules!\")\n        # return \" \"\n\n    def create_inventory_ob(self):\n        \"\"\"Return binary vector of collected target objects.\"\"\"\n        return [1 if obj in self.inventory else 0 for obj in self.target_values.keys()]\n\n    @property\n    def inventory_capacity(self):\n        \"\"\"Return the number of distinct target types.\"\"\"\n        return len([*self.target_values.keys()])\n</code></pre>"},{"location":"reference/cogrid/envs/goal_seeking/agent/#cogrid.envs.goal_seeking.agent.GoalSeekingAgent.inventory_capacity","title":"<code>inventory_capacity</code>  <code>property</code>","text":"<p>Return the number of distinct target types.</p>"},{"location":"reference/cogrid/envs/goal_seeking/agent/#cogrid.envs.goal_seeking.agent.GoalSeekingAgent.__init__","title":"<code>__init__(agent_id, start_position, env, target_values, config)</code>","text":"<p>Initialize goal-seeking agent with target values.</p> Source code in <code>cogrid/envs/goal_seeking/agent.py</code> <pre><code>def __init__(\n    self,\n    agent_id,\n    start_position,\n    env,\n    target_values,\n    config,\n):\n    \"\"\"Initialize goal-seeking agent with target values.\"\"\"\n    super().__init__(agent_id, start_position, env, config)\n\n    self.target_values = target_values\n\n    self.step_penalty = 0.01\n    self.collision_penalty = 0.05\n</code></pre>"},{"location":"reference/cogrid/envs/goal_seeking/agent/#cogrid.envs.goal_seeking.agent.GoalSeekingAgent.interact","title":"<code>interact(char)</code>","text":"<p>Handle interaction with a grid character.</p> Source code in <code>cogrid/envs/goal_seeking/agent.py</code> <pre><code>def interact(self, char):\n    \"\"\"Handle interaction with a grid character.\"\"\"\n    raise NotImplementedError(\"Must add in reward modules!\")\n</code></pre>"},{"location":"reference/cogrid/envs/goal_seeking/agent/#cogrid.envs.goal_seeking.agent.GoalSeekingAgent.create_inventory_ob","title":"<code>create_inventory_ob()</code>","text":"<p>Return binary vector of collected target objects.</p> Source code in <code>cogrid/envs/goal_seeking/agent.py</code> <pre><code>def create_inventory_ob(self):\n    \"\"\"Return binary vector of collected target objects.\"\"\"\n    return [1 if obj in self.inventory else 0 for obj in self.target_values.keys()]\n</code></pre>"},{"location":"reference/cogrid/envs/goal_seeking/goal_seeking/","title":"goal_seeking","text":""},{"location":"reference/cogrid/envs/goal_seeking/goal_seeking/#cogrid.envs.goal_seeking.goal_seeking","title":"<code>cogrid.envs.goal_seeking.goal_seeking</code>","text":"<p>Goal-seeking grid environment.</p>"},{"location":"reference/cogrid/envs/goal_seeking/goal_seeking/#cogrid.envs.goal_seeking.goal_seeking.GoalSeeking","title":"<code>GoalSeeking</code>","text":"<p>               Bases: <code>CoGridEnv</code></p> <p>Goal Seeking GridWorld task. A remake with multi-agent capability. For reference, see:.</p> <p>https://www.cmu.edu/dietrich/sds/ddmlab/papers/2020ICCM_Ngoc-CameraReady.pdf https://www.cmu.edu/dietrich/sds/ddmlab/papers/NguyenGonzalez2020.pdf</p> Source code in <code>cogrid/envs/goal_seeking/goal_seeking.py</code> <pre><code>class GoalSeeking(CoGridEnv):\n    \"\"\"Goal Seeking GridWorld task. A remake with multi-agent capability. For reference, see:.\n\n    https://www.cmu.edu/dietrich/sds/ddmlab/papers/2020ICCM_Ngoc-CameraReady.pdf\n    https://www.cmu.edu/dietrich/sds/ddmlab/papers/NguyenGonzalez2020.pdf\n    \"\"\"\n\n    def __init__(self, grid_path, config):\n        \"\"\"Initialize the goal-seeking environment from config.\"\"\"\n        super().__init__(grid_path=grid_path, agent_class=GoalSeekingAgent, config=config)\n\n        self.target_values = self.grid_data[\"values\"]\n        self.optimal_path_length = self.grid_data[\"optimal_path_length\"]\n\n        self.ma_spawns = (\n            [tuple(pos) for pos in self.grid_data[\"ma_spawns\"]]\n            if config[\"num_agents\"] &gt; 1\n            else None\n        )\n\n        self.targets = {}\n        for row in range(self.base_grid.shape[0]):\n            for col in range(self.base_grid.shape[1]):\n                if self.base_grid[row, col] in self.target_values.keys():\n                    self.targets[self.base_grid[row, col]] = (row, col)\n\n        self.pref_target_loc = self.targets[\n            max(self.target_values.items(), key=operator.itemgetter(1))[0]\n        ]\n\n        self.setup_agents()\n\n    def select_spawn_point(self, random_spawn=True) -&gt; tuple:\n        \"\"\"Select an available spawn point for a new agent.\"\"\"\n        curr_pos = [agent.pos for agent in self.env_agents.values()]\n\n        if (\n            \"gen_random_spawn\" in self.config[\"env\"].keys()\n            and self.config[\"env\"][\"gen_random_spawn\"]\n        ):\n            self.np_random.shuffle(self.free_spaces)\n            # Random spawn excludes pre-defined spawn points so that\n            # random positions are distinct from map-specified ones\n            # (required for SoU transfer experiments).\n            available = [\n                sp for sp in self.free_spaces if sp not in curr_pos and sp not in self.spawns\n            ]\n            return available[0]\n\n        if random_spawn:\n            self.np_random.shuffle(self.spawns)\n\n        if self.config[\"num_agents\"] &gt; 1:\n            all_spawns = self.ma_spawns\n        else:\n            all_spawns = self.spawns\n\n        selected_spawn = None\n        for spawn in all_spawns:\n            if spawn not in curr_pos:\n                selected_spawn = spawn\n                break\n        assert selected_spawn is not None, (\n            \"There are not enough spawn points in the map for the specified number of agents.\"\n        )\n        return selected_spawn\n\n    def custom_reset(self):\n        \"\"\"Reset goal positions and broadcast agent positions.\"\"\"\n        self.add_goals()\n        for agent in self.env_agents.values():\n            agent.all_agent_pos = self.agent_pos\n\n    def add_goals(self):\n        \"\"\"Place goal targets on the world map.\"\"\"\n        for target, pos in self.targets.items():\n            self.world_map[pos] = target\n</code></pre>"},{"location":"reference/cogrid/envs/goal_seeking/goal_seeking/#cogrid.envs.goal_seeking.goal_seeking.GoalSeeking.__init__","title":"<code>__init__(grid_path, config)</code>","text":"<p>Initialize the goal-seeking environment from config.</p> Source code in <code>cogrid/envs/goal_seeking/goal_seeking.py</code> <pre><code>def __init__(self, grid_path, config):\n    \"\"\"Initialize the goal-seeking environment from config.\"\"\"\n    super().__init__(grid_path=grid_path, agent_class=GoalSeekingAgent, config=config)\n\n    self.target_values = self.grid_data[\"values\"]\n    self.optimal_path_length = self.grid_data[\"optimal_path_length\"]\n\n    self.ma_spawns = (\n        [tuple(pos) for pos in self.grid_data[\"ma_spawns\"]]\n        if config[\"num_agents\"] &gt; 1\n        else None\n    )\n\n    self.targets = {}\n    for row in range(self.base_grid.shape[0]):\n        for col in range(self.base_grid.shape[1]):\n            if self.base_grid[row, col] in self.target_values.keys():\n                self.targets[self.base_grid[row, col]] = (row, col)\n\n    self.pref_target_loc = self.targets[\n        max(self.target_values.items(), key=operator.itemgetter(1))[0]\n    ]\n\n    self.setup_agents()\n</code></pre>"},{"location":"reference/cogrid/envs/goal_seeking/goal_seeking/#cogrid.envs.goal_seeking.goal_seeking.GoalSeeking.select_spawn_point","title":"<code>select_spawn_point(random_spawn=True)</code>","text":"<p>Select an available spawn point for a new agent.</p> Source code in <code>cogrid/envs/goal_seeking/goal_seeking.py</code> <pre><code>def select_spawn_point(self, random_spawn=True) -&gt; tuple:\n    \"\"\"Select an available spawn point for a new agent.\"\"\"\n    curr_pos = [agent.pos for agent in self.env_agents.values()]\n\n    if (\n        \"gen_random_spawn\" in self.config[\"env\"].keys()\n        and self.config[\"env\"][\"gen_random_spawn\"]\n    ):\n        self.np_random.shuffle(self.free_spaces)\n        # Random spawn excludes pre-defined spawn points so that\n        # random positions are distinct from map-specified ones\n        # (required for SoU transfer experiments).\n        available = [\n            sp for sp in self.free_spaces if sp not in curr_pos and sp not in self.spawns\n        ]\n        return available[0]\n\n    if random_spawn:\n        self.np_random.shuffle(self.spawns)\n\n    if self.config[\"num_agents\"] &gt; 1:\n        all_spawns = self.ma_spawns\n    else:\n        all_spawns = self.spawns\n\n    selected_spawn = None\n    for spawn in all_spawns:\n        if spawn not in curr_pos:\n            selected_spawn = spawn\n            break\n    assert selected_spawn is not None, (\n        \"There are not enough spawn points in the map for the specified number of agents.\"\n    )\n    return selected_spawn\n</code></pre>"},{"location":"reference/cogrid/envs/goal_seeking/goal_seeking/#cogrid.envs.goal_seeking.goal_seeking.GoalSeeking.custom_reset","title":"<code>custom_reset()</code>","text":"<p>Reset goal positions and broadcast agent positions.</p> Source code in <code>cogrid/envs/goal_seeking/goal_seeking.py</code> <pre><code>def custom_reset(self):\n    \"\"\"Reset goal positions and broadcast agent positions.\"\"\"\n    self.add_goals()\n    for agent in self.env_agents.values():\n        agent.all_agent_pos = self.agent_pos\n</code></pre>"},{"location":"reference/cogrid/envs/goal_seeking/goal_seeking/#cogrid.envs.goal_seeking.goal_seeking.GoalSeeking.add_goals","title":"<code>add_goals()</code>","text":"<p>Place goal targets on the world map.</p> Source code in <code>cogrid/envs/goal_seeking/goal_seeking.py</code> <pre><code>def add_goals(self):\n    \"\"\"Place goal targets on the world map.\"\"\"\n    for target, pos in self.targets.items():\n        self.world_map[pos] = target\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/","title":"overcooked","text":""},{"location":"reference/cogrid/envs/overcooked/#cogrid.envs.overcooked","title":"<code>cogrid.envs.overcooked</code>","text":"<p>Overcooked cooperative cooking environment.</p>"},{"location":"reference/cogrid/envs/overcooked/agent/","title":"agent","text":""},{"location":"reference/cogrid/envs/overcooked/agent/#cogrid.envs.overcooked.agent","title":"<code>cogrid.envs.overcooked.agent</code>","text":"<p>Overcooked environment agent with role support.</p>"},{"location":"reference/cogrid/envs/overcooked/agent/#cogrid.envs.overcooked.agent.OvercookedAgent","title":"<code>OvercookedAgent</code>","text":"<p>               Bases: <code>Agent</code></p> <p>Agent subclass for Overcooked with role support.</p> Source code in <code>cogrid/envs/overcooked/agent.py</code> <pre><code>class OvercookedAgent(Agent):\n    \"\"\"Agent subclass for Overcooked with role support.\"\"\"\n\n    def can_pickup(self, grid_object: GridObj) -&gt; bool:\n        \"\"\"Determine if the agent can pickup a specified grid object.\n\n        The Overcooked agent can pick up objects until it reaches capacity,\n\n\n        :param grid_object: The grid object to check if the agent can pick up.\n        :type grid_object: GridObj\n        :return: True if the agent can pick up the object, False otherwise.\n        :rtype: bool\n        \"\"\"\n        if isinstance(grid_object, overcooked_grid_objects.Pot) and any(\n            [isinstance(inv_obj, overcooked_grid_objects.Plate) for inv_obj in self.inventory]\n        ):\n            return True\n\n        return len(self.inventory) &lt; self.inventory_capacity\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/agent/#cogrid.envs.overcooked.agent.OvercookedAgent.can_pickup","title":"<code>can_pickup(grid_object)</code>","text":"<p>Determine if the agent can pickup a specified grid object.</p> <p>The Overcooked agent can pick up objects until it reaches capacity,</p> <p>:param grid_object: The grid object to check if the agent can pick up. :type grid_object: GridObj :return: True if the agent can pick up the object, False otherwise. :rtype: bool</p> Source code in <code>cogrid/envs/overcooked/agent.py</code> <pre><code>def can_pickup(self, grid_object: GridObj) -&gt; bool:\n    \"\"\"Determine if the agent can pickup a specified grid object.\n\n    The Overcooked agent can pick up objects until it reaches capacity,\n\n\n    :param grid_object: The grid object to check if the agent can pick up.\n    :type grid_object: GridObj\n    :return: True if the agent can pick up the object, False otherwise.\n    :rtype: bool\n    \"\"\"\n    if isinstance(grid_object, overcooked_grid_objects.Pot) and any(\n        [isinstance(inv_obj, overcooked_grid_objects.Plate) for inv_obj in self.inventory]\n    ):\n        return True\n\n    return len(self.inventory) &lt; self.inventory_capacity\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/config/","title":"config","text":""},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config","title":"<code>cogrid.envs.overcooked.config</code>","text":"<p>Overcooked-specific array configuration.</p> <p>Provides environment-specific array logic for Overcooked: tick handlers, interaction function, extra state building, and static table construction.</p> <p>Key public functions:</p> <ul> <li><code>build_overcooked_extra_state</code> -- extra_state builder for pot arrays</li> <li><code>overcooked_interaction_fn</code> -- per-agent interaction with (state, ...) -&gt; state signature</li> <li><code>overcooked_interaction_body</code> -- low-level per-agent dispatch to branch handlers</li> <li><code>overcooked_tick</code> -- unified pot cooking timer state machine</li> <li><code>overcooked_tick_state</code> -- tick handler with generic signature</li> </ul>"},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config--overcooked-interaction-overview","title":"Overcooked Interaction Overview","text":"<p>When an agent issues a PickupDrop action, <code>process_interactions</code> (in <code>cogrid.core.interactions</code>) determines the cell the agent is facing and whether another agent is blocking it. It then calls <code>overcooked_interaction_fn</code> once per agent (lower index = higher priority).</p> <p>The interaction resolves to exactly one of seven mutually exclusive branches, evaluated in strict priority order. The first branch whose condition is True wins; all later branches are suppressed via cascading <code>~earlier_cond</code> guards.</p> <p>Decision tree (evaluated per agent per step):</p> <pre><code>base_ok?  (agent issued PickupDrop AND no other agent in the forward cell)\n    |\n    +-- No  --&gt; no-op (all branches short-circuit)\n    |\n    +-- Yes\n         |\n         +-- Branch 1: PICKUP loose object\n         |     condition: forward cell has a pickupable object, hand is empty\n         |     effect:    object moves from grid to agent inventory\n         |\n         +-- Branch 2A: PICKUP FROM POT (cooked soup)\n         |     condition: forward cell is a pot, pot is done cooking,\n         |                agent holds a plate\n         |     effect:    plate replaced with soup in inventory,\n         |                pot contents/timer reset\n         |\n         +-- Branch 2B: PICKUP FROM STACK (dispenser)\n         |     condition: forward cell is a stack (onion/tomato/plate),\n         |                hand is empty\n         |     effect:    produced item placed in agent inventory,\n         |                stack remains on grid (infinite supply)\n         |\n         +-- Branch 3: DROP on empty cell\n         |     condition: forward cell is empty (type 0), hand is not empty\n         |     effect:    held item placed on grid, inventory cleared\n         |\n         +-- Branch 4 (place-on): agent holds an item, forward cell is\n         |   a \"place-on\" target (pot, delivery zone, or counter)\n         |     |\n         |     +-- 4A: PLACE ON POT\n         |     |     condition: forward cell is pot, held item is a legal\n         |     |                ingredient, pot has capacity, same ingredient type\n         |     |     effect:    item added to pot_contents, inventory cleared\n         |     |\n         |     +-- 4B: PLACE ON DELIVERY ZONE\n         |     |     condition: forward cell is delivery zone, held item is soup\n         |     |     effect:    soup removed from inventory (delivery scored\n         |     |                by the reward function, not here)\n         |     |\n         |     +-- 4C: PLACE ON COUNTER\n         |           condition: forward cell is a counter/generic place-on\n         |                      target (not pot, not delivery zone),\n         |                      counter cell is empty (state == 0)\n         |           effect:    item stored in object_state_map, inventory cleared\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config--array-layout-extra_state","title":"Array layout (extra_state)","text":"<p>Each pot on the grid is tracked by index in three parallel arrays stored in <code>state.extra_state</code>:</p> <pre><code>pot_contents:  (n_pots, 3) int32   -- type IDs of ingredients, -1 = empty slot\npot_timer:     (n_pots,)   int32   -- cooking countdown, 30 = not started, 0 = done\npot_positions: (n_pots, 2) int32   -- (row, col) of each pot on the grid\n</code></pre> <p>Example with 2 pots, pot 0 has two onions cooking, pot 1 is empty:</p> <pre><code>pot_contents = [[onion_id, onion_id, -1],    pot_timer = [25, 30]\n                [-1,       -1,       -1]]\n</code></pre> <p>To find which pot the agent is facing, we compare the agent's forward position against all entries in pot_positions and take argmax of the boolean match vector.</p>"},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config--branchless-xpwhere-pattern","title":"Branchless xp.where pattern","text":"<p>Every branch function computes BOTH the condition (bool scalar) AND the would-be result arrays unconditionally. No Python if/else gates the computation -- this is required for JAX tracing where all code paths must execute. The final <code>_apply_interaction_updates</code> merges results using cascading <code>xp.where(cond, branch_result, previous)</code>:</p> <pre><code>result = xp.where(b1_cond, b1_result, original)\nresult = xp.where(b2_cond, b2_result, result)\n...\n</code></pre> <p>Because conditions are mutually exclusive (each guards against all earlier conditions), exactly zero or one condition is True, so the final value is either the matching branch's result or the original.</p>"},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config.build_overcooked_extra_state","title":"<code>build_overcooked_extra_state(parsed_arrays, scope='overcooked')</code>","text":"<p>Build pot state arrays (contents, timer, positions) from the layout.</p> Source code in <code>cogrid/envs/overcooked/config.py</code> <pre><code>def build_overcooked_extra_state(parsed_arrays, scope=\"overcooked\"):\n    \"\"\"Build pot state arrays (contents, timer, positions) from the layout.\"\"\"\n    import numpy as _np\n\n    pot_type_id = object_to_idx(\"pot\", scope=scope)\n    otm = parsed_arrays[\"object_type_map\"]\n\n    # Find pot positions from object_type_map.\n    pot_mask = otm == pot_type_id\n    pot_positions_list = list(zip(*_np.where(pot_mask)))  # list of (row, col)\n    n_pots = len(pot_positions_list)\n\n    if n_pots &gt; 0:\n        pot_positions = _np.array(pot_positions_list, dtype=_np.int32)\n        pot_contents = _np.full((n_pots, 3), -1, dtype=_np.int32)\n        pot_timer = _np.full((n_pots,), 30, dtype=_np.int32)\n    else:\n        pot_positions = _np.zeros((0, 2), dtype=_np.int32)\n        pot_contents = _np.full((0, 3), -1, dtype=_np.int32)\n        pot_timer = _np.zeros((0,), dtype=_np.int32)\n\n    return {\n        \"overcooked.pot_contents\": pot_contents,\n        \"overcooked.pot_timer\": pot_timer,\n        \"overcooked.pot_positions\": pot_positions,\n    }\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config.overcooked_interaction_fn","title":"<code>overcooked_interaction_fn(state, agent_idx, fwd_r, fwd_c, base_ok, scope_config)</code>","text":"<p>Per-agent Overcooked interaction: state in, state out.</p> <p>Called once per agent by <code>process_interactions</code> in priority order (agent 0 first). Mutations from earlier agents are visible to later agents because the updated state is threaded through sequentially.</p> <p>This function is a thin adapter between the generic <code>process_interactions</code> contract and the Overcooked-specific <code>overcooked_interaction_body</code>:</p> <pre><code>1. Extract mutable arrays from the immutable EnvState\n2. Call overcooked_interaction_body (pure array logic)\n3. Pack the (possibly mutated) arrays back into a new EnvState\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config.overcooked_interaction_fn--parameters","title":"Parameters","text":"<p>state : EnvState     Current environment state. Immutable -- a new state is returned. agent_idx : int or scalar array     Index of the agent being processed (0-based). fwd_r, fwd_c : scalar int arrays     Row and column of the cell directly in front of this agent,     already clipped to grid bounds by process_interactions. base_ok : bool scalar array     True if this agent issued PickupDrop AND no other agent occupies     the forward cell. When False, all branches no-op. scope_config : dict     Scope configuration containing <code>\"static_tables\"</code> -- a dict of     pre-built lookup arrays (CAN_PICKUP, type IDs, etc.) that the     branch functions use to resolve interactions without isinstance().</p>"},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config.overcooked_interaction_fn--returns","title":"Returns:","text":"<p>EnvState     New state with agent_inv, object_type_map, object_state_map, and     extra_state potentially updated.</p> Source code in <code>cogrid/envs/overcooked/config.py</code> <pre><code>def overcooked_interaction_fn(state, agent_idx, fwd_r, fwd_c, base_ok, scope_config):\n    \"\"\"Per-agent Overcooked interaction: state in, state out.\n\n    Called once per agent by ``process_interactions`` in priority order\n    (agent 0 first). Mutations from earlier agents are visible to later\n    agents because the updated state is threaded through sequentially.\n\n    This function is a thin adapter between the generic ``process_interactions``\n    contract and the Overcooked-specific ``overcooked_interaction_body``:\n\n        1. Extract mutable arrays from the immutable EnvState\n        2. Call overcooked_interaction_body (pure array logic)\n        3. Pack the (possibly mutated) arrays back into a new EnvState\n\n    Parameters\n    ----------\n    state : EnvState\n        Current environment state. Immutable -- a new state is returned.\n    agent_idx : int or scalar array\n        Index of the agent being processed (0-based).\n    fwd_r, fwd_c : scalar int arrays\n        Row and column of the cell directly in front of this agent,\n        already clipped to grid bounds by process_interactions.\n    base_ok : bool scalar array\n        True if this agent issued PickupDrop AND no other agent occupies\n        the forward cell. When False, all branches no-op.\n    scope_config : dict\n        Scope configuration containing ``\"static_tables\"`` -- a dict of\n        pre-built lookup arrays (CAN_PICKUP, type IDs, etc.) that the\n        branch functions use to resolve interactions without isinstance().\n\n    Returns:\n    -------\n    EnvState\n        New state with agent_inv, object_type_map, object_state_map, and\n        extra_state potentially updated.\n    \"\"\"\n    import dataclasses\n\n    static_tables = scope_config.get(\"static_tables\", {})\n\n    # Look up what's in front of the agent and what they're holding.\n    fwd_type = state.object_type_map[fwd_r, fwd_c]\n    inv_item = state.agent_inv[agent_idx, 0]\n\n    # Delegate to the pure-array interaction body which evaluates all\n    # seven branches and returns the (possibly updated) arrays.\n    agent_inv, otm, osm, pot_contents, pot_timer = overcooked_interaction_body(\n        agent_idx,\n        state.agent_inv,\n        state.object_type_map,\n        state.object_state_map,\n        fwd_r,\n        fwd_c,\n        fwd_type,\n        inv_item,\n        base_ok,\n        state.extra_state[\"overcooked.pot_contents\"],\n        state.extra_state[\"overcooked.pot_timer\"],\n        state.extra_state[\"overcooked.pot_positions\"],\n        static_tables,\n    )\n\n    # Repack into a new immutable EnvState. pot_positions never changes\n    # (pots don't move), so we only update contents and timer.\n    new_extra = {\n        **state.extra_state,\n        \"overcooked.pot_contents\": pot_contents,\n        \"overcooked.pot_timer\": pot_timer,\n    }\n    return dataclasses.replace(\n        state,\n        agent_inv=agent_inv,\n        object_type_map=otm,\n        object_state_map=osm,\n        extra_state=new_extra,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config.overcooked_tick","title":"<code>overcooked_tick(pot_contents, pot_timer, capacity=3, cooking_time=30)</code>","text":"<p>Advance the cooking timer for all pots by one step.</p> Pot state machine <ul> <li>Empty or partially filled (n_items &lt; capacity): timer unchanged.</li> <li>Full and timer &gt; 0 (cooking): timer decrements by 1.</li> <li>Full and timer == 0 (done): timer stays at 0 until soup is picked up.</li> </ul> <p>Also computes <code>pot_state</code>, an integer encoding written into <code>object_state_map</code> at each pot's position so that features and rendering can inspect pot status without accessing extra_state:</p> <pre><code>pot_state = n_items + n_items * timer\n</code></pre> <p>Examples:</p> <p>Empty pot:                 0 + 030 = 0 2 items, not cooking:      2 + 230 = 62 3 items, timer=29:         3 + 329 = 90 3 items, done (timer=0):   3 + 30  = 3</p> <p>Returns (pot_contents, new_timer, pot_state).</p> Source code in <code>cogrid/envs/overcooked/config.py</code> <pre><code>def overcooked_tick(pot_contents, pot_timer, capacity=3, cooking_time=30):\n    \"\"\"Advance the cooking timer for all pots by one step.\n\n    Pot state machine:\n        - Empty or partially filled (n_items &lt; capacity): timer unchanged.\n        - Full and timer &gt; 0 (cooking): timer decrements by 1.\n        - Full and timer == 0 (done): timer stays at 0 until soup is picked up.\n\n    Also computes ``pot_state``, an integer encoding written into\n    ``object_state_map`` at each pot's position so that features and\n    rendering can inspect pot status without accessing extra_state:\n\n        pot_state = n_items + n_items * timer\n\n    Examples:\n        Empty pot:                 0 + 0*30 = 0\n        2 items, not cooking:      2 + 2*30 = 62\n        3 items, timer=29:         3 + 3*29 = 90\n        3 items, done (timer=0):   3 + 3*0  = 3\n\n    Returns (pot_contents, new_timer, pot_state).\n    \"\"\"\n    n_items = xp.sum(pot_contents != -1, axis=1).astype(xp.int32)\n    is_cooking = (n_items == capacity) &amp; (pot_timer &gt; 0)\n    new_timer = xp.where(is_cooking, pot_timer - 1, pot_timer)\n    pot_state = (n_items + n_items * new_timer).astype(xp.int32)\n    return pot_contents, new_timer, pot_state\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config.overcooked_tick_state","title":"<code>overcooked_tick_state(state, scope_config)</code>","text":"<p>Tick handler with generic (state, scope_config) -&gt; state signature.</p> <p>Extracts pot arrays from extra_state, runs <code>overcooked_tick</code>, writes the updated timer back into extra_state and the pot_state encoding into <code>object_state_map</code> at each pot's grid position.</p> Source code in <code>cogrid/envs/overcooked/config.py</code> <pre><code>def overcooked_tick_state(state, scope_config):\n    \"\"\"Tick handler with generic (state, scope_config) -&gt; state signature.\n\n    Extracts pot arrays from extra_state, runs ``overcooked_tick``, writes\n    the updated timer back into extra_state and the pot_state encoding\n    into ``object_state_map`` at each pot's grid position.\n    \"\"\"\n    import dataclasses\n\n    pot_contents = state.extra_state[\"overcooked.pot_contents\"]\n    pot_timer = state.extra_state[\"overcooked.pot_timer\"]\n    pot_positions = state.extra_state[\"overcooked.pot_positions\"]\n    n_pots = pot_positions.shape[0]\n\n    pot_contents, pot_timer, pot_state = overcooked_tick(pot_contents, pot_timer)\n\n    # Write pot_state into object_state_map at pot positions\n    osm = state.object_state_map\n    for p in range(n_pots):\n        osm = set_at_2d(osm, pot_positions[p, 0], pot_positions[p, 1], pot_state[p])\n\n    new_extra = {\n        **state.extra_state,\n        \"overcooked.pot_contents\": pot_contents,\n        \"overcooked.pot_timer\": pot_timer,\n    }\n    return dataclasses.replace(state, object_state_map=osm, extra_state=new_extra)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config.overcooked_interaction_body","title":"<code>overcooked_interaction_body(agent_idx, agent_inv, object_type_map, object_state_map, fwd_r, fwd_c, fwd_type, inv_item, base_ok, pot_contents, pot_timer, pot_positions, static_tables)</code>","text":"<p>Evaluate all seven interaction branches for one agent and merge results.</p> <p>This is the core dispatch function. It:     1. Unpacks static lookup tables (type IDs, property arrays)     2. Resolves which pot (if any) the agent is facing     3. Calls each branch function to compute conditions and would-be results     4. Calls _apply_interaction_updates to merge via cascading xp.where</p> <p>The branch evaluation order and mutual exclusion are critical:</p> <pre><code>Branch 1  -&gt; b1_cond\nBranch 2A -&gt; requires ~b1_cond\nBranch 2B -&gt; requires ~b1_cond\nBranch 3  -&gt; requires ~b1_cond &amp; ~b2_pot_cond &amp; ~b2_stack_cond\nBranch 4* -&gt; requires ~b1_cond &amp; ~b2_pot_cond &amp; ~b2_stack_cond &amp; ~b3_cond\n</code></pre> <p>This ensures that if an agent could both pick up and place on (ambiguous), pickup always wins.</p>"},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config.overcooked_interaction_body--parameters","title":"Parameters","text":"<p>static_tables : dict     Pre-built at init time by <code>_build_static_tables</code>. Contains:</p> <pre><code>Property arrays (indexed by type ID):\n    CAN_PICKUP[type_id]          -&gt; 1 if pickupable\n    CAN_PICKUP_FROM[type_id]     -&gt; 1 if can pick from (stacks + pot)\n    CAN_PLACE_ON[type_id]        -&gt; 1 if can place items on\n    pickup_from_produces[type_id] -&gt; produced type ID (0 if N/A)\n    legal_pot_ingredients[type_id] -&gt; 1 if can go in pot\n\nScalar type IDs:\n    pot_id, plate_id, tomato_id, onion_soup_id,\n    tomato_soup_id, delivery_zone_id\n\nConstants:\n    cooking_time = 30  (ticks to cook a full pot)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/config/#cogrid.envs.overcooked.config.overcooked_interaction_body--returns","title":"Returns:","text":"<p>(agent_inv, object_type_map, object_state_map, pot_contents, pot_timer)     Updated arrays. Unchanged if base_ok is False or no branch fires.</p> Source code in <code>cogrid/envs/overcooked/config.py</code> <pre><code>def overcooked_interaction_body(\n    agent_idx,  # int: which agent is interacting (0-based)\n    agent_inv,  # (n_agents, 1) int32: all agent inventories\n    object_type_map,  # (H, W) int32: object type IDs on the grid\n    object_state_map,  # (H, W) int32: object state values on the grid\n    fwd_r,\n    fwd_c,  # scalar int arrays: forward cell coordinates\n    fwd_type,  # scalar int array: object type at forward cell\n    inv_item,  # scalar int array: what this agent is holding (-1 = empty)\n    base_ok,  # bool scalar: True if agent can interact (PickupDrop + no agent ahead)\n    pot_contents,  # (n_pots, 3) int32: ingredient type IDs per pot slot\n    pot_timer,  # (n_pots,) int32: cooking countdown per pot\n    pot_positions,  # (n_pots, 2) int32: (row, col) of each pot\n    static_tables,  # dict: pre-built lookup arrays (see _build_static_tables)\n):\n    \"\"\"Evaluate all seven interaction branches for one agent and merge results.\n\n    This is the core dispatch function. It:\n        1. Unpacks static lookup tables (type IDs, property arrays)\n        2. Resolves which pot (if any) the agent is facing\n        3. Calls each branch function to compute conditions and would-be results\n        4. Calls _apply_interaction_updates to merge via cascading xp.where\n\n    The branch evaluation order and mutual exclusion are critical:\n\n        Branch 1  -&gt; b1_cond\n        Branch 2A -&gt; requires ~b1_cond\n        Branch 2B -&gt; requires ~b1_cond\n        Branch 3  -&gt; requires ~b1_cond &amp; ~b2_pot_cond &amp; ~b2_stack_cond\n        Branch 4* -&gt; requires ~b1_cond &amp; ~b2_pot_cond &amp; ~b2_stack_cond &amp; ~b3_cond\n\n    This ensures that if an agent could both pick up and place on (ambiguous),\n    pickup always wins.\n\n    Parameters\n    ----------\n    static_tables : dict\n        Pre-built at init time by ``_build_static_tables``. Contains:\n\n        Property arrays (indexed by type ID):\n            CAN_PICKUP[type_id]          -&gt; 1 if pickupable\n            CAN_PICKUP_FROM[type_id]     -&gt; 1 if can pick from (stacks + pot)\n            CAN_PLACE_ON[type_id]        -&gt; 1 if can place items on\n            pickup_from_produces[type_id] -&gt; produced type ID (0 if N/A)\n            legal_pot_ingredients[type_id] -&gt; 1 if can go in pot\n\n        Scalar type IDs:\n            pot_id, plate_id, tomato_id, onion_soup_id,\n            tomato_soup_id, delivery_zone_id\n\n        Constants:\n            cooking_time = 30  (ticks to cook a full pot)\n\n    Returns:\n    -------\n    (agent_inv, object_type_map, object_state_map, pot_contents, pot_timer)\n        Updated arrays. Unchanged if base_ok is False or no branch fires.\n    \"\"\"\n    # --- Unpack static tables ---\n    CAN_PICKUP = static_tables[\"CAN_PICKUP\"]\n    CAN_PICKUP_FROM = static_tables[\"CAN_PICKUP_FROM\"]\n    CAN_PLACE_ON = static_tables[\"CAN_PLACE_ON\"]\n    pickup_from_produces = static_tables[\"pickup_from_produces\"]\n    legal_pot_ingredients = static_tables[\"legal_pot_ingredients\"]\n    pot_id = static_tables[\"pot_id\"]\n    plate_id = static_tables[\"plate_id\"]\n    tomato_id = static_tables[\"tomato_id\"]\n    onion_soup_id = static_tables[\"onion_soup_id\"]\n    tomato_soup_id = static_tables[\"tomato_soup_id\"]\n    delivery_zone_id = static_tables[\"delivery_zone_id\"]\n    cooking_time = static_tables[\"cooking_time\"]\n\n    # --- Pot matching ---\n    # If the forward cell is a pot, find which pot index it corresponds to\n    # in the pot_positions array. pot_idx is the argmax of the boolean\n    # match vector; has_pot_match is False if no pot is at this position\n    # (in which case pot_idx is 0 but guarded by has_pot_match in conditions).\n    fwd_pos_2d = xp.stack([fwd_r, fwd_c])\n    pot_match = xp.all(pot_positions == fwd_pos_2d[None, :], axis=1)\n    pot_idx = xp.argmax(pot_match)\n    has_pot_match = xp.any(pot_match)\n\n    # --- Branch 1: pickup loose object ---\n    b1_cond, b1_inv, b1_otm, b1_osm = _interact_pickup(\n        base_ok,\n        fwd_type,\n        fwd_r,\n        fwd_c,\n        inv_item,\n        agent_idx,\n        agent_inv,\n        object_type_map,\n        object_state_map,\n        CAN_PICKUP,\n    )\n\n    # --- Branch 2A: pickup cooked soup from pot ---\n    b2_pot_cond, b2_pot_inv, b2_pot_pc, b2_pot_pt = _interact_pickup_from_pot(\n        base_ok,\n        b1_cond,\n        fwd_type,\n        inv_item,\n        agent_idx,\n        agent_inv,\n        pot_contents,\n        pot_timer,\n        pot_idx,\n        has_pot_match,\n        pot_id,\n        plate_id,\n        tomato_id,\n        onion_soup_id,\n        tomato_soup_id,\n        cooking_time,\n    )\n\n    # --- Branch 2B: pickup from stack (onion/tomato/plate dispenser) ---\n    b2_stack_cond, b2_stack_inv = _interact_pickup_from_stack(\n        base_ok,\n        b1_cond,\n        fwd_type,\n        inv_item,\n        agent_idx,\n        agent_inv,\n        pot_id,\n        CAN_PICKUP_FROM,\n        pickup_from_produces,\n    )\n\n    # --- Branch 3: drop on empty cell ---\n    b3_cond, b3_inv, b3_otm, b3_osm = _interact_drop_on_empty(\n        base_ok,\n        b1_cond,\n        b2_pot_cond,\n        b2_stack_cond,\n        fwd_type,\n        fwd_r,\n        fwd_c,\n        inv_item,\n        agent_idx,\n        agent_inv,\n        object_type_map,\n        object_state_map,\n    )\n\n    # --- Shared base condition for all place-on branches (4A, 4B, 4C) ---\n    # All three require: base_ok, no earlier branch fired, forward cell\n    # has a place-on target, and agent is holding something.\n    b4_base = (\n        base_ok\n        &amp; ~b1_cond\n        &amp; ~b2_pot_cond\n        &amp; ~b2_stack_cond\n        &amp; ~b3_cond\n        &amp; (fwd_type &gt; 0)\n        &amp; (CAN_PLACE_ON[fwd_type] == 1)\n        &amp; (inv_item != -1)\n    )\n\n    # --- Branch 4A: place ingredient on pot ---\n    b4_pot_cond, b4_pot_inv, b4_pot_pc = _interact_place_on_pot(\n        b4_base,\n        fwd_type,\n        inv_item,\n        agent_idx,\n        agent_inv,\n        pot_contents,\n        pot_idx,\n        has_pot_match,\n        pot_id,\n        legal_pot_ingredients,\n    )\n\n    # --- Branch 4B: deliver soup to delivery zone ---\n    b4_dz_cond, b4_dz_inv = _interact_place_on_delivery(\n        b4_base,\n        fwd_type,\n        inv_item,\n        agent_idx,\n        agent_inv,\n        delivery_zone_id,\n        onion_soup_id,\n        tomato_soup_id,\n    )\n\n    # --- Branch 4C: place item on counter ---\n    b4_gen_cond, b4_gen_inv, b4_gen_osm = _interact_place_on_counter(\n        b4_base,\n        fwd_type,\n        fwd_r,\n        fwd_c,\n        inv_item,\n        agent_idx,\n        agent_inv,\n        object_state_map,\n        pot_id,\n        delivery_zone_id,\n    )\n\n    # --- Merge all branch results using cascading xp.where ---\n    return _apply_interaction_updates(\n        b1_cond,\n        b1_inv,\n        b1_otm,\n        b1_osm,\n        b2_pot_cond,\n        b2_pot_inv,\n        b2_pot_pc,\n        b2_pot_pt,\n        b2_stack_cond,\n        b2_stack_inv,\n        b3_cond,\n        b3_inv,\n        b3_otm,\n        b3_osm,\n        b4_pot_cond,\n        b4_pot_inv,\n        b4_pot_pc,\n        b4_dz_cond,\n        b4_dz_inv,\n        b4_gen_cond,\n        b4_gen_inv,\n        b4_gen_osm,\n        agent_inv,\n        object_type_map,\n        object_state_map,\n        pot_contents,\n        pot_timer,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/","title":"features","text":""},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features","title":"<code>cogrid.envs.overcooked.features</code>","text":"<p>Overcooked feature extractors.</p> <p>Produces the same 677-dim (for 2 agents) ego-centric observation as the legacy OOP feature system, but operates entirely on state arrays so it works with both numpy and JAX backends.</p> <p>All functions are JIT-compatible: no Python control flow on traced values, no int()/np.array() conversions of traced arrays.</p> <p>Feature composition is handled by autowire via Feature subclasses registered in this module.</p>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.OvercookedInventory","title":"<code>OvercookedInventory</code>","text":"<p>               Bases: <code>Feature</code></p> <p>One-hot inventory encoding feature.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@register_feature_type(\"overcooked_inventory\", scope=\"overcooked\")\nclass OvercookedInventory(Feature):\n    \"\"\"One-hot inventory encoding feature.\"\"\"\n\n    per_agent = True\n    obs_dim = 5\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build the inventory feature function for the given scope.\"\"\"\n        from cogrid.core.grid_object import object_to_idx\n\n        inv_type_order = [\"onion\", \"onion_soup\", \"plate\", \"tomato\", \"tomato_soup\"]\n        inv_type_ids = xp.array(\n            [object_to_idx(name, scope=scope) for name in inv_type_order],\n            dtype=xp.int32,\n        )\n\n        def fn(state, agent_idx):\n            return overcooked_inventory_feature(\n                state.agent_inv,\n                agent_idx,\n                inv_type_ids,\n            )\n\n        return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.OvercookedInventory.build_feature_fn","title":"<code>build_feature_fn(scope)</code>  <code>classmethod</code>","text":"<p>Build the inventory feature function for the given scope.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@classmethod\ndef build_feature_fn(cls, scope):\n    \"\"\"Build the inventory feature function for the given scope.\"\"\"\n    from cogrid.core.grid_object import object_to_idx\n\n    inv_type_order = [\"onion\", \"onion_soup\", \"plate\", \"tomato\", \"tomato_soup\"]\n    inv_type_ids = xp.array(\n        [object_to_idx(name, scope=scope) for name in inv_type_order],\n        dtype=xp.int32,\n    )\n\n    def fn(state, agent_idx):\n        return overcooked_inventory_feature(\n            state.agent_inv,\n            agent_idx,\n            inv_type_ids,\n        )\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.NextToCounter","title":"<code>NextToCounter</code>","text":"<p>               Bases: <code>Feature</code></p> <p>Cardinal adjacency to counters feature.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@register_feature_type(\"next_to_counter\", scope=\"overcooked\")\nclass NextToCounter(Feature):\n    \"\"\"Cardinal adjacency to counters feature.\"\"\"\n\n    per_agent = True\n    obs_dim = 4\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build the counter adjacency feature function.\"\"\"\n        from cogrid.core.grid_object import object_to_idx\n\n        counter_type_id = object_to_idx(\"counter\", scope=scope)\n\n        def fn(state, agent_idx):\n            return next_to_counter_feature(\n                state.agent_pos,\n                agent_idx,\n                state.object_type_map,\n                counter_type_id,\n            )\n\n        return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.NextToCounter.build_feature_fn","title":"<code>build_feature_fn(scope)</code>  <code>classmethod</code>","text":"<p>Build the counter adjacency feature function.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@classmethod\ndef build_feature_fn(cls, scope):\n    \"\"\"Build the counter adjacency feature function.\"\"\"\n    from cogrid.core.grid_object import object_to_idx\n\n    counter_type_id = object_to_idx(\"counter\", scope=scope)\n\n    def fn(state, agent_idx):\n        return next_to_counter_feature(\n            state.agent_pos,\n            agent_idx,\n            state.object_type_map,\n            counter_type_id,\n        )\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.NextToPot","title":"<code>NextToPot</code>","text":"<p>               Bases: <code>Feature</code></p> <p>Cardinal adjacency to pots with status encoding.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@register_feature_type(\"next_to_pot\", scope=\"overcooked\")\nclass NextToPot(Feature):\n    \"\"\"Cardinal adjacency to pots with status encoding.\"\"\"\n\n    per_agent = True\n    obs_dim = 16\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build the pot adjacency feature function.\"\"\"\n        from cogrid.core.grid_object import object_to_idx\n\n        pot_type_id = object_to_idx(\"pot\", scope=scope)\n\n        def fn(state, agent_idx):\n            return next_to_pot_feature(\n                state.agent_pos,\n                agent_idx,\n                state.object_type_map,\n                pot_type_id,\n                state.pot_positions,\n                state.pot_contents,\n                state.pot_timer,\n            )\n\n        return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.NextToPot.build_feature_fn","title":"<code>build_feature_fn(scope)</code>  <code>classmethod</code>","text":"<p>Build the pot adjacency feature function.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@classmethod\ndef build_feature_fn(cls, scope):\n    \"\"\"Build the pot adjacency feature function.\"\"\"\n    from cogrid.core.grid_object import object_to_idx\n\n    pot_type_id = object_to_idx(\"pot\", scope=scope)\n\n    def fn(state, agent_idx):\n        return next_to_pot_feature(\n            state.agent_pos,\n            agent_idx,\n            state.object_type_map,\n            pot_type_id,\n            state.pot_positions,\n            state.pot_contents,\n            state.pot_timer,\n        )\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.OrderedPotFeatures","title":"<code>OrderedPotFeatures</code>","text":"<p>               Bases: <code>Feature</code></p> <p>Per-pot features in grid-scan order.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@register_feature_type(\"ordered_pot_features\", scope=\"overcooked\")\nclass OrderedPotFeatures(Feature):\n    \"\"\"Per-pot features in grid-scan order.\"\"\"\n\n    per_agent = True\n    obs_dim = 24  # 12 features * max_num_pots=2\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build the ordered pot feature function.\"\"\"\n        from cogrid.core.grid_object import object_to_idx\n\n        onion_id = object_to_idx(\"onion\", scope=scope)\n        tomato_id = object_to_idx(\"tomato\", scope=scope)\n\n        def fn(state, agent_idx):\n            return ordered_pot_features(\n                state.agent_pos,\n                agent_idx,\n                state.pot_positions,\n                state.pot_contents,\n                state.pot_timer,\n                max_num_pots=2,\n                onion_id=onion_id,\n                tomato_id=tomato_id,\n            )\n\n        return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.OrderedPotFeatures.build_feature_fn","title":"<code>build_feature_fn(scope)</code>  <code>classmethod</code>","text":"<p>Build the ordered pot feature function.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@classmethod\ndef build_feature_fn(cls, scope):\n    \"\"\"Build the ordered pot feature function.\"\"\"\n    from cogrid.core.grid_object import object_to_idx\n\n    onion_id = object_to_idx(\"onion\", scope=scope)\n    tomato_id = object_to_idx(\"tomato\", scope=scope)\n\n    def fn(state, agent_idx):\n        return ordered_pot_features(\n            state.agent_pos,\n            agent_idx,\n            state.pot_positions,\n            state.pot_contents,\n            state.pot_timer,\n            max_num_pots=2,\n            onion_id=onion_id,\n            tomato_id=tomato_id,\n        )\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.DistToOtherPlayers","title":"<code>DistToOtherPlayers</code>","text":"<p>               Bases: <code>Feature</code></p> <p>Distance to other agents feature.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@register_feature_type(\"dist_to_other_players\", scope=\"overcooked\")\nclass DistToOtherPlayers(Feature):\n    \"\"\"Distance to other agents feature.\"\"\"\n\n    per_agent = True\n    obs_dim = 2  # 2 * (2 agents - 1) = 2\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build the distance-to-others feature function.\"\"\"\n\n        def fn(state, agent_idx):\n            return dist_to_other_players_feature(\n                state.agent_pos,\n                agent_idx,\n                n_agents=2,\n            )\n\n        return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.DistToOtherPlayers.build_feature_fn","title":"<code>build_feature_fn(scope)</code>  <code>classmethod</code>","text":"<p>Build the distance-to-others feature function.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@classmethod\ndef build_feature_fn(cls, scope):\n    \"\"\"Build the distance-to-others feature function.\"\"\"\n\n    def fn(state, agent_idx):\n        return dist_to_other_players_feature(\n            state.agent_pos,\n            agent_idx,\n            n_agents=2,\n        )\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.LayoutID","title":"<code>LayoutID</code>","text":"<p>               Bases: <code>Feature</code></p> <p>One-hot layout identifier feature.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@register_feature_type(\"layout_id\", scope=\"overcooked\")\nclass LayoutID(Feature):\n    \"\"\"One-hot layout identifier feature.\"\"\"\n\n    per_agent = False\n    obs_dim = 5\n    _layout_idx = 0  # Set before build_feature_fn; Phase 18 wires this\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build the layout ID feature function.\"\"\"\n        idx = cls._layout_idx\n\n        def fn(state):\n            return layout_id_feature(idx)\n\n        return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.LayoutID.build_feature_fn","title":"<code>build_feature_fn(scope)</code>  <code>classmethod</code>","text":"<p>Build the layout ID feature function.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@classmethod\ndef build_feature_fn(cls, scope):\n    \"\"\"Build the layout ID feature function.\"\"\"\n    idx = cls._layout_idx\n\n    def fn(state):\n        return layout_id_feature(idx)\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.EnvironmentLayout","title":"<code>EnvironmentLayout</code>","text":"<p>               Bases: <code>Feature</code></p> <p>Binary masks for object types across the layout.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@register_feature_type(\"environment_layout\", scope=\"overcooked\")\nclass EnvironmentLayout(Feature):\n    \"\"\"Binary masks for object types across the layout.\"\"\"\n\n    per_agent = False\n    obs_dim = 462  # 6 types * 11 * 7 (max layout shape)\n    _max_layout_shape = (11, 7)\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build the environment layout feature function.\"\"\"\n        from cogrid.core.grid_object import object_to_idx\n\n        layout_type_names = [\"counter\", \"pot\", \"onion\", \"plate\", \"onion_stack\", \"plate_stack\"]\n        layout_type_ids = [object_to_idx(name, scope=scope) for name in layout_type_names]\n        max_shape = cls._max_layout_shape\n\n        def fn(state):\n            return environment_layout_feature(\n                state.object_type_map,\n                layout_type_ids,\n                max_shape,\n            )\n\n        return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.EnvironmentLayout.build_feature_fn","title":"<code>build_feature_fn(scope)</code>  <code>classmethod</code>","text":"<p>Build the environment layout feature function.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>@classmethod\ndef build_feature_fn(cls, scope):\n    \"\"\"Build the environment layout feature function.\"\"\"\n    from cogrid.core.grid_object import object_to_idx\n\n    layout_type_names = [\"counter\", \"pot\", \"onion\", \"plate\", \"onion_stack\", \"plate_stack\"]\n    layout_type_ids = [object_to_idx(name, scope=scope) for name in layout_type_names]\n    max_shape = cls._max_layout_shape\n\n    def fn(state):\n        return environment_layout_feature(\n            state.object_type_map,\n            layout_type_ids,\n            max_shape,\n        )\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.overcooked_inventory_feature","title":"<code>overcooked_inventory_feature(agent_inv, agent_idx, inv_type_ids)</code>","text":"<p>One-hot inventory encoding. (5,) = [onion, onion_soup, plate, tomato, tomato_soup].</p> <p>Empty inventory (-1) matches nothing -&gt; all zeros.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>def overcooked_inventory_feature(agent_inv, agent_idx, inv_type_ids):\n    \"\"\"One-hot inventory encoding. (5,) = [onion, onion_soup, plate, tomato, tomato_soup].\n\n    Empty inventory (-1) matches nothing -&gt; all zeros.\n    \"\"\"\n    held = agent_inv[agent_idx, 0]\n    return (inv_type_ids == held).astype(xp.int32)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.next_to_counter_feature","title":"<code>next_to_counter_feature(agent_pos, agent_idx, object_type_map, counter_type_id)</code>","text":"<p>Multi-hot cardinal adjacency to counters. (4,) = [R, L, D, U].</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>def next_to_counter_feature(agent_pos, agent_idx, object_type_map, counter_type_id):\n    \"\"\"Multi-hot cardinal adjacency to counters. (4,) = [R, L, D, U].\"\"\"\n    H, W = object_type_map.shape\n    deltas = xp.array([[0, 1], [0, -1], [1, 0], [-1, 0]], dtype=xp.int32)\n    pos = agent_pos[agent_idx]\n    neighbors = pos[None, :] + deltas\n\n    in_bounds = (\n        (neighbors[:, 0] &gt;= 0)\n        &amp; (neighbors[:, 0] &lt; H)\n        &amp; (neighbors[:, 1] &gt;= 0)\n        &amp; (neighbors[:, 1] &lt; W)\n    )\n\n    clipped = xp.clip(neighbors, xp.array([0, 0]), xp.array([H - 1, W - 1]))\n    types = object_type_map[clipped[:, 0], clipped[:, 1]]\n\n    return (in_bounds &amp; (types == counter_type_id)).astype(xp.int32)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.next_to_pot_feature","title":"<code>next_to_pot_feature(agent_pos, agent_idx, object_type_map, pot_type_id, pot_positions, pot_contents, pot_timer, capacity=3)</code>","text":"<p>(16,) adjacency to pots, with status encoding.</p> <p>Layout: [empty(4), partial(4), cooking(4), ready(4)], indexed by direction. Fully vectorized over directions and pots \u2014 no Python control flow on traced values.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>def next_to_pot_feature(\n    agent_pos,\n    agent_idx,\n    object_type_map,\n    pot_type_id,\n    pot_positions,\n    pot_contents,\n    pot_timer,\n    capacity=3,\n):\n    \"\"\"(16,) adjacency to pots, with status encoding.\n\n    Layout: [empty(4), partial(4), cooking(4), ready(4)], indexed by direction.\n    Fully vectorized over directions and pots \u2014 no Python control flow on traced values.\n    \"\"\"\n    H, W = object_type_map.shape\n    deltas = xp.array([[0, 1], [0, -1], [1, 0], [-1, 0]], dtype=xp.int32)\n    pos = agent_pos[agent_idx]\n    neighbors = pos[None, :] + deltas  # (4, 2)\n\n    in_bounds = (\n        (neighbors[:, 0] &gt;= 0)\n        &amp; (neighbors[:, 0] &lt; H)\n        &amp; (neighbors[:, 1] &gt;= 0)\n        &amp; (neighbors[:, 1] &lt; W)\n    )\n\n    clipped = xp.clip(neighbors, xp.array([0, 0]), xp.array([H - 1, W - 1]))\n    types = object_type_map[clipped[:, 0], clipped[:, 1]]\n    is_pot = in_bounds &amp; (types == pot_type_id)  # (4,)\n\n    # For each direction, find which pot it matches (if any)\n    # neighbor_rc: (4, 1, 2) vs pot_positions: (1, n_pots, 2)\n    neighbor_rc = clipped[:, None, :]  # (4, 1, 2)\n    pot_rc = pot_positions[None, :, :]  # (1, n_pots, 2)\n    match = (neighbor_rc[:, :, 0] == pot_rc[:, :, 0]) &amp; (\n        neighbor_rc[:, :, 1] == pot_rc[:, :, 1]\n    )  # (4, n_pots)\n\n    # Count items per pot and get timer: (n_pots,)\n    items_per_pot = xp.sum(pot_contents &gt; 0, axis=1)  # (n_pots,)\n\n    # Pot status per pot: [empty, partial, cooking, ready]\n    is_empty = items_per_pot == 0  # (n_pots,)\n    is_partial = (items_per_pot &gt; 0) &amp; (items_per_pot &lt; capacity)  # (n_pots,)\n    is_cooking = (items_per_pot == capacity) &amp; (pot_timer &gt; 0)  # (n_pots,)\n    is_ready = (items_per_pot == capacity) &amp; (pot_timer == 0)  # (n_pots,)\n\n    # For each direction, check if any matched pot has each status\n    # match: (4, n_pots), is_empty: (n_pots,) -&gt; broadcast to (4, n_pots)\n    dir_empty = xp.any(match &amp; is_empty[None, :], axis=1)  # (4,)\n    dir_partial = xp.any(match &amp; is_partial[None, :], axis=1)  # (4,)\n    dir_cooking = xp.any(match &amp; is_cooking[None, :], axis=1)  # (4,)\n    dir_ready = xp.any(match &amp; is_ready[None, :], axis=1)  # (4,)\n\n    # Mask by is_pot\n    result = xp.concatenate(\n        [\n            (is_pot &amp; dir_empty).astype(xp.int32),\n            (is_pot &amp; dir_partial).astype(xp.int32),\n            (is_pot &amp; dir_cooking).astype(xp.int32),\n            (is_pot &amp; dir_ready).astype(xp.int32),\n        ]\n    )\n\n    return result\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.closest_obj_feature","title":"<code>closest_obj_feature(agent_pos, agent_idx, object_type_map, object_state_map, target_type_id, n, large_dist=9999)</code>","text":"<p>(2*n,) deltas (dy, dx) to the n closest instances of target_type_id.</p> <p>Searches both object_type_map (for placed objects like pots/stacks) and object_state_map (for items placed on counters). Fully vectorized \u2014 uses argsort with masked distances.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>def closest_obj_feature(\n    agent_pos, agent_idx, object_type_map, object_state_map, target_type_id, n, large_dist=9999\n):\n    \"\"\"(2*n,) deltas (dy, dx) to the n closest instances of target_type_id.\n\n    Searches both object_type_map (for placed objects like pots/stacks) and\n    object_state_map (for items placed on counters).\n    Fully vectorized \u2014 uses argsort with masked distances.\n    \"\"\"\n    H, W = object_type_map.shape\n    pos = agent_pos[agent_idx]  # (2,)\n\n    type_flat = object_type_map.ravel()  # (H*W,)\n    state_flat = object_state_map.ravel()  # (H*W,)\n    match = (type_flat == target_type_id) | (state_flat == target_type_id)\n\n    # Coordinate arrays\n    rows = xp.arange(H, dtype=xp.int32).repeat(W)\n    cols = xp.tile(xp.arange(W, dtype=xp.int32), H)\n\n    # Exclude agent's own position\n    agent_mask = ~((rows == pos[0]) &amp; (cols == pos[1]))\n    match = match &amp; agent_mask\n\n    # Deltas and manhattan distances\n    dys = pos[0] - rows  # (H*W,)\n    dxs = pos[1] - cols  # (H*W,)\n    dists = xp.abs(dys) + xp.abs(dxs)  # (H*W,)\n\n    # Mask non-matches with large distance so they sort last\n    masked_dists = xp.where(match, dists, large_dist)\n\n    # Sort and take top-n\n    sorted_indices = xp.argsort(masked_dists)\n    top_indices = sorted_indices[:n]  # (n,)\n\n    # Gather deltas; zero out entries where there was no match\n    top_dys = dys[top_indices]\n    top_dxs = dxs[top_indices]\n    top_valid = masked_dists[top_indices] &lt; large_dist\n\n    top_dys = xp.where(top_valid, top_dys, 0)\n    top_dxs = xp.where(top_valid, top_dxs, 0)\n\n    # Interleave (dy0, dx0, dy1, dx1, ...)\n    result = xp.zeros(2 * n, dtype=xp.int32)\n    for i in range(n):\n        result = (\n            result.at[2 * i].set(top_dys[i])\n            if hasattr(result, \"at\")\n            else _set_idx(result, 2 * i, top_dys[i])\n        )\n        result = (\n            result.at[2 * i + 1].set(top_dxs[i])\n            if hasattr(result, \"at\")\n            else _set_idx(result, 2 * i + 1, top_dxs[i])\n        )\n\n    return result\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.ordered_pot_features","title":"<code>ordered_pot_features(agent_pos, agent_idx, pot_positions, pot_contents, pot_timer, max_num_pots, onion_id, tomato_id, capacity=3)</code>","text":"<p>(12 * max_num_pots,) per-pot features in grid-scan order.</p> <p>Per pot: [reachable(1), status(4), contents(2), timer(1), distance(2), location(2)] = 12. Status one-hot: [ready, empty, full/cooking, partial] matching _calc_pot_features order. Fully vectorized \u2014 no Python control flow on traced values.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>def ordered_pot_features(\n    agent_pos,\n    agent_idx,\n    pot_positions,\n    pot_contents,\n    pot_timer,\n    max_num_pots,\n    onion_id,\n    tomato_id,\n    capacity=3,\n):\n    \"\"\"(12 * max_num_pots,) per-pot features in grid-scan order.\n\n    Per pot: [reachable(1), status(4), contents(2), timer(1), distance(2), location(2)] = 12.\n    Status one-hot: [ready, empty, full/cooking, partial] matching _calc_pot_features order.\n    Fully vectorized \u2014 no Python control flow on traced values.\n    \"\"\"\n    pos = agent_pos[agent_idx]  # (2,)\n\n    # Items per pot: (n_pots,)\n    n_items = xp.sum(pot_contents &gt; 0, axis=1)\n\n    # Status one-hot per pot: [ready, empty, full/cooking, partial]\n    is_ready = ((n_items == capacity) &amp; (pot_timer == 0)).astype(xp.float32)\n    is_empty = (n_items == 0).astype(xp.float32)\n    is_cooking = ((n_items == capacity) &amp; (pot_timer &gt; 0)).astype(xp.float32)\n    is_partial = ((n_items &gt; 0) &amp; (n_items &lt; capacity)).astype(xp.float32)\n\n    # Contents per pot: count of onion and tomato\n    n_onion = xp.sum(pot_contents == onion_id, axis=1).astype(xp.float32)  # (n_pots,)\n    n_tomato = xp.sum(pot_contents == tomato_id, axis=1).astype(xp.float32)  # (n_pots,)\n\n    # Timer: value if cooking, -1 if not\n    is_cooking_bool = (n_items == capacity) &amp; (pot_timer &gt; 0)\n    timer_val = xp.where(is_cooking_bool, pot_timer.astype(xp.float32), xp.float32(-1))\n\n    # Distance and location\n    dy = (pos[0] - pot_positions[:, 0]).astype(xp.float32)  # (n_pots,)\n    dx = (pos[1] - pot_positions[:, 1]).astype(xp.float32)  # (n_pots,)\n    pr = pot_positions[:, 0].astype(xp.float32)\n    pc = pot_positions[:, 1].astype(xp.float32)\n\n    # Reachable = 1 for all pots (matching Python impl)\n    reachable = xp.ones(pot_positions.shape[0], dtype=xp.float32)\n\n    # Per-pot feature vector: (n_pots, 12)\n    per_pot = xp.stack(\n        [\n            reachable,\n            is_ready,\n            is_empty,\n            is_cooking,\n            is_partial,\n            n_onion,\n            n_tomato,\n            timer_val,\n            dy,\n            dx,\n            pr,\n            pc,\n        ],\n        axis=1,\n    )  # (n_pots, 12)\n\n    # Pad to max_num_pots (if fewer pots than max)\n    n_pots = pot_positions.shape[0]\n    if n_pots &lt; max_num_pots:\n        pad = xp.zeros((max_num_pots - n_pots, 12), dtype=xp.float32)\n        per_pot = xp.concatenate([per_pot, pad], axis=0)\n\n    # Take only max_num_pots and flatten\n    return per_pot[:max_num_pots].ravel()\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.dist_to_other_players_feature","title":"<code>dist_to_other_players_feature(agent_pos, agent_idx, n_agents)</code>","text":"<p>(2 * (n_agents - 1),) distance to other agents.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>def dist_to_other_players_feature(agent_pos, agent_idx, n_agents):\n    \"\"\"(2 * (n_agents - 1),) distance to other agents.\"\"\"\n    pos = agent_pos[agent_idx]\n    result = xp.zeros(2 * (n_agents - 1), dtype=xp.int32)\n    out_idx = 0\n    for i in range(n_agents):\n        if i == agent_idx:  # agent_idx is a Python int, this is fine under JIT\n            continue\n        dy = pos[0] - agent_pos[i, 0]\n        dx = pos[1] - agent_pos[i, 1]\n        result = (\n            result.at[out_idx].set(dy) if hasattr(result, \"at\") else _set_idx(result, out_idx, dy)\n        )\n        result = (\n            result.at[out_idx + 1].set(dx)\n            if hasattr(result, \"at\")\n            else _set_idx(result, out_idx + 1, dx)\n        )\n        out_idx += 2\n    return result\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.layout_id_feature","title":"<code>layout_id_feature(layout_idx, num_layouts=5)</code>","text":"<p>(num_layouts,) one-hot layout identifier.</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>def layout_id_feature(layout_idx, num_layouts=5):\n    \"\"\"(num_layouts,) one-hot layout identifier.\"\"\"\n    return (xp.arange(num_layouts) == layout_idx).astype(xp.int32)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/features/#cogrid.envs.overcooked.features.environment_layout_feature","title":"<code>environment_layout_feature(object_type_map, layout_type_ids, max_shape)</code>","text":"<p>(6 * max_shape[0] * max_shape[1],) binary masks for each of 6 object types.</p> <p>Types: [counter, pot, onion, plate, onion_stack, plate_stack]. Uses the same (max_shape[0], max_shape[1]) convention and flat indexing as the Python <code>EnvironmentLayout</code> feature: <code>flat_index = row * max_shape[1] + col</code>. Vectorized using scatter-style indexing (no Python loops on traced values).</p> Source code in <code>cogrid/envs/overcooked/features.py</code> <pre><code>def environment_layout_feature(object_type_map, layout_type_ids, max_shape):\n    \"\"\"(6 * max_shape[0] * max_shape[1],) binary masks for each of 6 object types.\n\n    Types: [counter, pot, onion, plate, onion_stack, plate_stack].\n    Uses the same (max_shape[0], max_shape[1]) convention and flat indexing\n    as the Python ``EnvironmentLayout`` feature: ``flat_index = row * max_shape[1] + col``.\n    Vectorized using scatter-style indexing (no Python loops on traced values).\n    \"\"\"\n    H, W = object_type_map.shape\n    dim0, dim1 = max_shape\n    channel_size = dim0 * dim1\n    n_types = len(layout_type_ids)\n\n    # Build flat coordinate indices: flat_index[r, c] = r * dim1 + c\n    row_idx = xp.arange(H, dtype=xp.int32)[:, None] * dim1  # (H, 1)\n    col_idx = xp.arange(W, dtype=xp.int32)[None, :]  # (1, W)\n    flat_idx = (row_idx + col_idx).ravel()  # (H*W,)\n\n    otm_flat = object_type_map.ravel()  # (H*W,)\n\n    result = xp.zeros(n_types * channel_size, dtype=xp.int32)\n\n    for t_idx in range(n_types):\n        type_id = layout_type_ids[t_idx]\n        offset = t_idx * channel_size\n        is_match = (otm_flat == type_id).astype(xp.int32)  # (H*W,)\n        # Scatter matched positions into the result\n        target_indices = flat_idx + offset  # (H*W,)\n        if hasattr(result, \"at\"):  # JAX\n            result = result.at[target_indices].add(is_match)\n        else:\n            for j in range(len(target_indices)):\n                if is_match[j]:\n                    result[target_indices[j]] = 1\n\n    return result\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/","title":"overcooked_grid_objects","text":""},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects","title":"<code>cogrid.envs.overcooked.overcooked_grid_objects</code>","text":"<p>Overcooked grid object types (food, pots, plates, delivery zones).</p>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Onion","title":"<code>Onion</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A single onion ingredient.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@register_object_type(\"onion\", scope=\"overcooked\", can_pickup=True)\nclass Onion(grid_object.GridObj):\n    \"\"\"A single onion ingredient.\"\"\"\n\n    object_id = \"onion\"\n    color = constants.Colors.Yellow\n    char = \"o\"\n\n    def __init__(\n        self,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"Initialize with default state.\"\"\"\n        super().__init__(\n            state=0,\n            inventory_value=0.0,\n        )\n\n    def can_pickup(self, agent: grid_object.GridAgent) -&gt; bool:\n        \"\"\"Return True; onions are always pickable.\"\"\"\n        return True\n\n    def render(self, tile_img):\n        \"\"\"Draw a yellow circle.\"\"\"\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.3), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Onion.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize with default state.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    **kwargs,\n):\n    \"\"\"Initialize with default state.\"\"\"\n    super().__init__(\n        state=0,\n        inventory_value=0.0,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Onion.can_pickup","title":"<code>can_pickup(agent)</code>","text":"<p>Return True; onions are always pickable.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def can_pickup(self, agent: grid_object.GridAgent) -&gt; bool:\n    \"\"\"Return True; onions are always pickable.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Onion.render","title":"<code>render(tile_img)</code>","text":"<p>Draw a yellow circle.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw a yellow circle.\"\"\"\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.3), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Tomato","title":"<code>Tomato</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A single tomato ingredient.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@register_object_type(\"tomato\", scope=\"overcooked\", can_pickup=True)\nclass Tomato(grid_object.GridObj):\n    \"\"\"A single tomato ingredient.\"\"\"\n\n    object_id = \"tomato\"\n    color = constants.Colors.Red\n    char = \"t\"\n\n    def __init__(\n        self,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"Initialize with default state.\"\"\"\n        super().__init__(\n            state=0,\n            inventory_value=0.0,\n        )\n\n    def can_pickup(self, agent: grid_object.GridAgent) -&gt; bool:\n        \"\"\"Return True; tomatoes are always pickable.\"\"\"\n        return True\n\n    def render(self, tile_img):\n        \"\"\"Draw a red circle.\"\"\"\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.3), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Tomato.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize with default state.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    **kwargs,\n):\n    \"\"\"Initialize with default state.\"\"\"\n    super().__init__(\n        state=0,\n        inventory_value=0.0,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Tomato.can_pickup","title":"<code>can_pickup(agent)</code>","text":"<p>Return True; tomatoes are always pickable.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def can_pickup(self, agent: grid_object.GridAgent) -&gt; bool:\n    \"\"\"Return True; tomatoes are always pickable.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Tomato.render","title":"<code>render(tile_img)</code>","text":"<p>Draw a red circle.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw a red circle.\"\"\"\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.3), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.OnionStack","title":"<code>OnionStack</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>An OnionStack is just an (infinite) pile of onions.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@register_object_type(\"onion_stack\", scope=\"overcooked\", can_pickup_from=True)\nclass OnionStack(grid_object.GridObj):\n    \"\"\"An OnionStack is just an (infinite) pile of onions.\"\"\"\n\n    object_id = \"onion_stack\"\n    color = constants.Colors.Yellow\n    char = \"O\"\n\n    def can_pickup_from(self, agent: grid_object.GridAgent) -&gt; bool:\n        \"\"\"Return True; agents can always take an onion from the stack.\"\"\"\n        return True\n\n    def pick_up_from(self, agent: grid_object.GridAgent) -&gt; grid_object.GridObj:\n        \"\"\"Dispense a fresh Onion.\"\"\"\n        return Onion()\n\n    def render(self, tile_img: np.ndarray):\n        \"\"\"Draw three stacked yellow circles.\"\"\"\n        fill_coords(tile_img, point_in_circle(cx=0.25, cy=0.3, r=0.2), self.color)\n        fill_coords(tile_img, point_in_circle(cx=0.75, cy=0.3, r=0.2), self.color)\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.7, r=0.2), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.OnionStack.can_pickup_from","title":"<code>can_pickup_from(agent)</code>","text":"<p>Return True; agents can always take an onion from the stack.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def can_pickup_from(self, agent: grid_object.GridAgent) -&gt; bool:\n    \"\"\"Return True; agents can always take an onion from the stack.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.OnionStack.pick_up_from","title":"<code>pick_up_from(agent)</code>","text":"<p>Dispense a fresh Onion.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def pick_up_from(self, agent: grid_object.GridAgent) -&gt; grid_object.GridObj:\n    \"\"\"Dispense a fresh Onion.\"\"\"\n    return Onion()\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.OnionStack.render","title":"<code>render(tile_img)</code>","text":"<p>Draw three stacked yellow circles.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def render(self, tile_img: np.ndarray):\n    \"\"\"Draw three stacked yellow circles.\"\"\"\n    fill_coords(tile_img, point_in_circle(cx=0.25, cy=0.3, r=0.2), self.color)\n    fill_coords(tile_img, point_in_circle(cx=0.75, cy=0.3, r=0.2), self.color)\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.7, r=0.2), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.TomatoStack","title":"<code>TomatoStack</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A TomatoStack is just an (infinite) pile of tomatoes.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@register_object_type(\"tomato_stack\", scope=\"overcooked\", can_pickup_from=True)\nclass TomatoStack(grid_object.GridObj):\n    \"\"\"A TomatoStack is just an (infinite) pile of tomatoes.\"\"\"\n\n    object_id = \"tomato_stack\"\n    color = constants.Colors.Red\n    char = \"T\"\n\n    def can_pickup_from(self, agent: grid_object.GridAgent) -&gt; bool:\n        \"\"\"Return True; agents can always take a tomato from the stack.\"\"\"\n        return True\n\n    def pick_up_from(self, agent: grid_object.GridAgent) -&gt; grid_object.GridObj:\n        \"\"\"Dispense a fresh Tomato.\"\"\"\n        return Tomato()\n\n    def render(self, tile_img: np.ndarray):\n        \"\"\"Draw three stacked red circles.\"\"\"\n        fill_coords(tile_img, point_in_circle(cx=0.25, cy=0.3, r=0.2), self.color)\n        fill_coords(tile_img, point_in_circle(cx=0.75, cy=0.3, r=0.2), self.color)\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.7, r=0.2), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.TomatoStack.can_pickup_from","title":"<code>can_pickup_from(agent)</code>","text":"<p>Return True; agents can always take a tomato from the stack.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def can_pickup_from(self, agent: grid_object.GridAgent) -&gt; bool:\n    \"\"\"Return True; agents can always take a tomato from the stack.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.TomatoStack.pick_up_from","title":"<code>pick_up_from(agent)</code>","text":"<p>Dispense a fresh Tomato.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def pick_up_from(self, agent: grid_object.GridAgent) -&gt; grid_object.GridObj:\n    \"\"\"Dispense a fresh Tomato.\"\"\"\n    return Tomato()\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.TomatoStack.render","title":"<code>render(tile_img)</code>","text":"<p>Draw three stacked red circles.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def render(self, tile_img: np.ndarray):\n    \"\"\"Draw three stacked red circles.\"\"\"\n    fill_coords(tile_img, point_in_circle(cx=0.25, cy=0.3, r=0.2), self.color)\n    fill_coords(tile_img, point_in_circle(cx=0.75, cy=0.3, r=0.2), self.color)\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.7, r=0.2), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot","title":"<code>Pot</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A cooking pot that accepts ingredients and produces soup.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@register_object_type(\"pot\", scope=\"overcooked\", can_place_on=True, can_pickup_from=True)\nclass Pot(grid_object.GridObj):\n    \"\"\"A cooking pot that accepts ingredients and produces soup.\"\"\"\n\n    object_id = \"pot\"\n    color = constants.Colors.Grey\n    char = \"U\"\n    cooking_time: int = 30  # env steps to cook a soup\n\n    def __init__(\n        self,\n        state: int = 0,\n        capacity: int = 3,\n        legal_contents: list[grid_object.GridObj] = [Onion, Tomato],\n        *args,\n        **kwargs,\n    ):\n        \"\"\"Initialize pot with capacity and legal ingredient types.\"\"\"\n        super().__init__(state=state, picked_up_from_value=0.0, placed_on_value=0.0)\n\n        self.objects_in_pot: list[grid_object.GridObj] = []\n        self.capacity: int = capacity\n        self.cooking_timer: int = self.cooking_time\n        self.legal_contents: list[grid_object.GridObj] = legal_contents\n\n    def can_pickup_from(self, agent: grid_object.GridAgent) -&gt; bool:\n        \"\"\"True when dish is ready and agent holds a Plate.\"\"\"\n        return self.dish_ready and any(\n            [isinstance(grid_obj, Plate) for grid_obj in agent.inventory]\n        )\n\n    def pick_up_from(self, agent: grid_object.GridAgent) -&gt; grid_object.GridObj:\n        \"\"\"Remove soup from pot, consume agent's plate, return soup object.\"\"\"\n        # if all ingredients are tomatoes, return TomatoSoup\n        soup = OnionSoup()\n        if all([isinstance(grid_obj, Tomato) for grid_obj in self.objects_in_pot]):\n            soup = TomatoSoup()\n\n        self.objects_in_pot = []\n        self.cooking_timer = self.cooking_time\n        agent.inventory.pop(0)\n        return soup\n\n    def can_place_on(self, agent: grid_object.GridAgent, cell: grid_object.GridObj) -&gt; bool:\n        \"\"\"True when pot has room and cell is a legal same-type ingredient.\"\"\"\n        is_legal_ingredient = any([isinstance(cell, grid_obj) for grid_obj in self.legal_contents])\n\n        # return true if cell is the same ingredient type as other ingredients in the pot\n        is_same_type = all(\n            [isinstance(cell, type(grid_obj)) for grid_obj in self.objects_in_pot]\n        )  # return true even if pot is empty\n\n        return len(self.objects_in_pot) &lt; self.capacity and is_legal_ingredient and is_same_type\n\n    def place_on(self, agent: grid_object.GridAgent, cell: grid_object.GridObj) -&gt; None:\n        \"\"\"Add an ingredient to the pot.\"\"\"\n        self.objects_in_pot.append(cell)\n\n    @property\n    def is_cooking(self) -&gt; None:\n        \"\"\"True when pot is full and timer has not reached zero.\"\"\"\n        return len(self.objects_in_pot) == self.capacity and self.cooking_timer &gt; 0\n\n    def tick(self) -&gt; None:\n        \"\"\"Update cooking time if the pot is full.\"\"\"\n        if len(self.objects_in_pot) == self.capacity and self.cooking_timer &gt; 0:\n            self.cooking_timer -= 1\n            self.state += 100\n\n        self.state = len(self.objects_in_pot) + len(self.objects_in_pot) * self.cooking_timer\n\n    @property\n    def dish_ready(self) -&gt; bool:\n        \"\"\"True when cooking timer has reached zero.\"\"\"\n        return self.cooking_timer == 0\n\n    def render(self, tile_img):\n        \"\"\"Draw pot circle with ingredient dots and timer text.\"\"\"\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.5), self.color)\n\n        for i, grid_obj in enumerate(self.objects_in_pot):\n            fill_coords(\n                tile_img,\n                point_in_circle(cx=0.25 * (i + 1), cy=0.2, r=0.2),\n                grid_obj.color,\n            )\n\n        if len(self.objects_in_pot) == self.capacity:\n            add_text_to_image(tile_img, text=str(self.cooking_timer), position=(50, 75))\n\n    def encode(self, encode_char: bool = True, scope: str = \"global\"):\n        \"\"\"Allow encoding to account for the type of soup in the pot.\"\"\"\n        char, _, state = super().encode(encode_char=encode_char, scope=scope)\n        extra_state_encoding = int(any(isinstance(obj, Tomato) for obj in self.objects_in_pot))\n        return (char, extra_state_encoding, state)\n\n    @classmethod\n    def build_tick_fn(cls):\n        \"\"\"Return the overcooked tick-state function.\"\"\"\n        from cogrid.envs.overcooked.config import overcooked_tick_state\n\n        return overcooked_tick_state\n\n    @classmethod\n    def extra_state_schema(cls):\n        \"\"\"Return schema for pot-related extra state arrays.\"\"\"\n        return {\n            \"pot_contents\": {\"shape\": (\"n_pots\", 3), \"dtype\": \"int32\"},\n            \"pot_timer\": {\"shape\": (\"n_pots\",), \"dtype\": \"int32\"},\n            \"pot_positions\": {\"shape\": (\"n_pots\", 2), \"dtype\": \"int32\"},\n        }\n\n    @classmethod\n    def extra_state_builder(cls):\n        \"\"\"Return the function that builds overcooked extra state.\"\"\"\n        from cogrid.envs.overcooked.config import build_overcooked_extra_state\n\n        return build_overcooked_extra_state\n\n    @classmethod\n    def build_static_tables(cls):\n        \"\"\"Return pre-computed static tables for the overcooked scope.\"\"\"\n        from cogrid.envs.overcooked.config import (\n            _build_interaction_tables,\n            _build_static_tables,\n            _build_type_ids,\n        )\n\n        scope = \"overcooked\"\n        itables = _build_interaction_tables(scope)\n        type_ids = _build_type_ids(scope)\n        return _build_static_tables(scope, itables, type_ids)\n\n    @classmethod\n    def build_render_sync_fn(cls):\n        \"\"\"Return a render-sync callback that updates pot visuals from state.\"\"\"\n\n        def pot_render_sync(grid, env_state, scope):\n            \"\"\"Sync pot contents and cooking timer from extra_state.\"\"\"\n            from cogrid.core.grid_object import idx_to_object, make_object\n\n            extra = env_state.extra_state\n            prefix = f\"{scope}.\"\n            pc_key = f\"{prefix}pot_contents\"\n            pt_key = f\"{prefix}pot_timer\"\n            pp_key = f\"{prefix}pot_positions\"\n\n            if not all(k in extra for k in (pc_key, pt_key, pp_key)):\n                return\n\n            pot_contents = np.array(extra[pc_key])\n            pot_timer = np.array(extra[pt_key])\n            pot_positions = np.array(extra[pp_key])\n\n            for p in range(len(pot_positions)):\n                pr, pc = int(pot_positions[p, 0]), int(pot_positions[p, 1])\n                pot_obj = grid.get(pr, pc)\n                if pot_obj is not None and pot_obj.object_id == \"pot\":\n                    pot_obj.objects_in_pot = []\n                    for slot in range(pot_contents.shape[1]):\n                        item_id = int(pot_contents[p, slot])\n                        if item_id &gt; 0:\n                            item_name = idx_to_object(item_id, scope=scope)\n                            if item_name:\n                                pot_obj.objects_in_pot.append(make_object(item_name, scope=scope))\n                    pot_obj.cooking_timer = int(pot_timer[p])\n\n        return pot_render_sync\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.is_cooking","title":"<code>is_cooking</code>  <code>property</code>","text":"<p>True when pot is full and timer has not reached zero.</p>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.dish_ready","title":"<code>dish_ready</code>  <code>property</code>","text":"<p>True when cooking timer has reached zero.</p>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.__init__","title":"<code>__init__(state=0, capacity=3, legal_contents=[Onion, Tomato], *args, **kwargs)</code>","text":"<p>Initialize pot with capacity and legal ingredient types.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def __init__(\n    self,\n    state: int = 0,\n    capacity: int = 3,\n    legal_contents: list[grid_object.GridObj] = [Onion, Tomato],\n    *args,\n    **kwargs,\n):\n    \"\"\"Initialize pot with capacity and legal ingredient types.\"\"\"\n    super().__init__(state=state, picked_up_from_value=0.0, placed_on_value=0.0)\n\n    self.objects_in_pot: list[grid_object.GridObj] = []\n    self.capacity: int = capacity\n    self.cooking_timer: int = self.cooking_time\n    self.legal_contents: list[grid_object.GridObj] = legal_contents\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.can_pickup_from","title":"<code>can_pickup_from(agent)</code>","text":"<p>True when dish is ready and agent holds a Plate.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def can_pickup_from(self, agent: grid_object.GridAgent) -&gt; bool:\n    \"\"\"True when dish is ready and agent holds a Plate.\"\"\"\n    return self.dish_ready and any(\n        [isinstance(grid_obj, Plate) for grid_obj in agent.inventory]\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.pick_up_from","title":"<code>pick_up_from(agent)</code>","text":"<p>Remove soup from pot, consume agent's plate, return soup object.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def pick_up_from(self, agent: grid_object.GridAgent) -&gt; grid_object.GridObj:\n    \"\"\"Remove soup from pot, consume agent's plate, return soup object.\"\"\"\n    # if all ingredients are tomatoes, return TomatoSoup\n    soup = OnionSoup()\n    if all([isinstance(grid_obj, Tomato) for grid_obj in self.objects_in_pot]):\n        soup = TomatoSoup()\n\n    self.objects_in_pot = []\n    self.cooking_timer = self.cooking_time\n    agent.inventory.pop(0)\n    return soup\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.can_place_on","title":"<code>can_place_on(agent, cell)</code>","text":"<p>True when pot has room and cell is a legal same-type ingredient.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def can_place_on(self, agent: grid_object.GridAgent, cell: grid_object.GridObj) -&gt; bool:\n    \"\"\"True when pot has room and cell is a legal same-type ingredient.\"\"\"\n    is_legal_ingredient = any([isinstance(cell, grid_obj) for grid_obj in self.legal_contents])\n\n    # return true if cell is the same ingredient type as other ingredients in the pot\n    is_same_type = all(\n        [isinstance(cell, type(grid_obj)) for grid_obj in self.objects_in_pot]\n    )  # return true even if pot is empty\n\n    return len(self.objects_in_pot) &lt; self.capacity and is_legal_ingredient and is_same_type\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.place_on","title":"<code>place_on(agent, cell)</code>","text":"<p>Add an ingredient to the pot.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def place_on(self, agent: grid_object.GridAgent, cell: grid_object.GridObj) -&gt; None:\n    \"\"\"Add an ingredient to the pot.\"\"\"\n    self.objects_in_pot.append(cell)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.tick","title":"<code>tick()</code>","text":"<p>Update cooking time if the pot is full.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def tick(self) -&gt; None:\n    \"\"\"Update cooking time if the pot is full.\"\"\"\n    if len(self.objects_in_pot) == self.capacity and self.cooking_timer &gt; 0:\n        self.cooking_timer -= 1\n        self.state += 100\n\n    self.state = len(self.objects_in_pot) + len(self.objects_in_pot) * self.cooking_timer\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.render","title":"<code>render(tile_img)</code>","text":"<p>Draw pot circle with ingredient dots and timer text.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw pot circle with ingredient dots and timer text.\"\"\"\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.5), self.color)\n\n    for i, grid_obj in enumerate(self.objects_in_pot):\n        fill_coords(\n            tile_img,\n            point_in_circle(cx=0.25 * (i + 1), cy=0.2, r=0.2),\n            grid_obj.color,\n        )\n\n    if len(self.objects_in_pot) == self.capacity:\n        add_text_to_image(tile_img, text=str(self.cooking_timer), position=(50, 75))\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.encode","title":"<code>encode(encode_char=True, scope='global')</code>","text":"<p>Allow encoding to account for the type of soup in the pot.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def encode(self, encode_char: bool = True, scope: str = \"global\"):\n    \"\"\"Allow encoding to account for the type of soup in the pot.\"\"\"\n    char, _, state = super().encode(encode_char=encode_char, scope=scope)\n    extra_state_encoding = int(any(isinstance(obj, Tomato) for obj in self.objects_in_pot))\n    return (char, extra_state_encoding, state)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.build_tick_fn","title":"<code>build_tick_fn()</code>  <code>classmethod</code>","text":"<p>Return the overcooked tick-state function.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@classmethod\ndef build_tick_fn(cls):\n    \"\"\"Return the overcooked tick-state function.\"\"\"\n    from cogrid.envs.overcooked.config import overcooked_tick_state\n\n    return overcooked_tick_state\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.extra_state_schema","title":"<code>extra_state_schema()</code>  <code>classmethod</code>","text":"<p>Return schema for pot-related extra state arrays.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@classmethod\ndef extra_state_schema(cls):\n    \"\"\"Return schema for pot-related extra state arrays.\"\"\"\n    return {\n        \"pot_contents\": {\"shape\": (\"n_pots\", 3), \"dtype\": \"int32\"},\n        \"pot_timer\": {\"shape\": (\"n_pots\",), \"dtype\": \"int32\"},\n        \"pot_positions\": {\"shape\": (\"n_pots\", 2), \"dtype\": \"int32\"},\n    }\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.extra_state_builder","title":"<code>extra_state_builder()</code>  <code>classmethod</code>","text":"<p>Return the function that builds overcooked extra state.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@classmethod\ndef extra_state_builder(cls):\n    \"\"\"Return the function that builds overcooked extra state.\"\"\"\n    from cogrid.envs.overcooked.config import build_overcooked_extra_state\n\n    return build_overcooked_extra_state\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.build_static_tables","title":"<code>build_static_tables()</code>  <code>classmethod</code>","text":"<p>Return pre-computed static tables for the overcooked scope.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@classmethod\ndef build_static_tables(cls):\n    \"\"\"Return pre-computed static tables for the overcooked scope.\"\"\"\n    from cogrid.envs.overcooked.config import (\n        _build_interaction_tables,\n        _build_static_tables,\n        _build_type_ids,\n    )\n\n    scope = \"overcooked\"\n    itables = _build_interaction_tables(scope)\n    type_ids = _build_type_ids(scope)\n    return _build_static_tables(scope, itables, type_ids)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Pot.build_render_sync_fn","title":"<code>build_render_sync_fn()</code>  <code>classmethod</code>","text":"<p>Return a render-sync callback that updates pot visuals from state.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@classmethod\ndef build_render_sync_fn(cls):\n    \"\"\"Return a render-sync callback that updates pot visuals from state.\"\"\"\n\n    def pot_render_sync(grid, env_state, scope):\n        \"\"\"Sync pot contents and cooking timer from extra_state.\"\"\"\n        from cogrid.core.grid_object import idx_to_object, make_object\n\n        extra = env_state.extra_state\n        prefix = f\"{scope}.\"\n        pc_key = f\"{prefix}pot_contents\"\n        pt_key = f\"{prefix}pot_timer\"\n        pp_key = f\"{prefix}pot_positions\"\n\n        if not all(k in extra for k in (pc_key, pt_key, pp_key)):\n            return\n\n        pot_contents = np.array(extra[pc_key])\n        pot_timer = np.array(extra[pt_key])\n        pot_positions = np.array(extra[pp_key])\n\n        for p in range(len(pot_positions)):\n            pr, pc = int(pot_positions[p, 0]), int(pot_positions[p, 1])\n            pot_obj = grid.get(pr, pc)\n            if pot_obj is not None and pot_obj.object_id == \"pot\":\n                pot_obj.objects_in_pot = []\n                for slot in range(pot_contents.shape[1]):\n                    item_id = int(pot_contents[p, slot])\n                    if item_id &gt; 0:\n                        item_name = idx_to_object(item_id, scope=scope)\n                        if item_name:\n                            pot_obj.objects_in_pot.append(make_object(item_name, scope=scope))\n                pot_obj.cooking_timer = int(pot_timer[p])\n\n    return pot_render_sync\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.PlateStack","title":"<code>PlateStack</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>An infinite stack of plates for picking up soup.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@register_object_type(\"plate_stack\", scope=\"overcooked\", can_pickup_from=True)\nclass PlateStack(grid_object.GridObj):\n    \"\"\"An infinite stack of plates for picking up soup.\"\"\"\n\n    object_id = \"plate_stack\"\n    color = constants.Colors.White\n    char = \"=\"\n\n    def __init__(\n        self,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"Initialize with default state.\"\"\"\n        super().__init__(\n            state=0,\n            toggle_value=0,\n            inventory_value=0,\n            overlap_value=0,\n        )\n\n    def can_pickup_from(self, agent: grid_object.GridAgent) -&gt; bool:\n        \"\"\"Return True; agents can always take a plate from the stack.\"\"\"\n        return True\n\n    def pick_up_from(self, agent: grid_object.GridAgent) -&gt; grid_object.GridObj:\n        \"\"\"Dispense a fresh Plate.\"\"\"\n        return Plate()\n\n    def render(self, tile_img):\n        \"\"\"Draw three stacked white circles.\"\"\"\n        fill_coords(tile_img, point_in_circle(cx=0.25, cy=0.3, r=0.2), self.color)\n        fill_coords(tile_img, point_in_circle(cx=0.75, cy=0.3, r=0.2), self.color)\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.7, r=0.2), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.PlateStack.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize with default state.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    **kwargs,\n):\n    \"\"\"Initialize with default state.\"\"\"\n    super().__init__(\n        state=0,\n        toggle_value=0,\n        inventory_value=0,\n        overlap_value=0,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.PlateStack.can_pickup_from","title":"<code>can_pickup_from(agent)</code>","text":"<p>Return True; agents can always take a plate from the stack.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def can_pickup_from(self, agent: grid_object.GridAgent) -&gt; bool:\n    \"\"\"Return True; agents can always take a plate from the stack.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.PlateStack.pick_up_from","title":"<code>pick_up_from(agent)</code>","text":"<p>Dispense a fresh Plate.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def pick_up_from(self, agent: grid_object.GridAgent) -&gt; grid_object.GridObj:\n    \"\"\"Dispense a fresh Plate.\"\"\"\n    return Plate()\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.PlateStack.render","title":"<code>render(tile_img)</code>","text":"<p>Draw three stacked white circles.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw three stacked white circles.\"\"\"\n    fill_coords(tile_img, point_in_circle(cx=0.25, cy=0.3, r=0.2), self.color)\n    fill_coords(tile_img, point_in_circle(cx=0.75, cy=0.3, r=0.2), self.color)\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.7, r=0.2), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Plate","title":"<code>Plate</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A plate used to serve completed soups.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@register_object_type(\"plate\", scope=\"overcooked\", can_pickup=True)\nclass Plate(grid_object.GridObj):\n    \"\"\"A plate used to serve completed soups.\"\"\"\n\n    object_id = \"plate\"\n    color = constants.Colors.White\n    char = \"P\"\n\n    def __init__(\n        self,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"Initialize with default state.\"\"\"\n        super().__init__(\n            state=0,\n            toggle_value=0,\n            inventory_value=0.0,\n            overlap_value=0,\n        )\n\n    def can_pickup(self, agent: grid_object.GridAgent) -&gt; bool:\n        \"\"\"Return True; plates are always pickable.\"\"\"\n        return True\n\n    def render(self, tile_img):\n        \"\"\"Draw a white circle.\"\"\"\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.5), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Plate.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize with default state.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    **kwargs,\n):\n    \"\"\"Initialize with default state.\"\"\"\n    super().__init__(\n        state=0,\n        toggle_value=0,\n        inventory_value=0.0,\n        overlap_value=0,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Plate.can_pickup","title":"<code>can_pickup(agent)</code>","text":"<p>Return True; plates are always pickable.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def can_pickup(self, agent: grid_object.GridAgent) -&gt; bool:\n    \"\"\"Return True; plates are always pickable.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.Plate.render","title":"<code>render(tile_img)</code>","text":"<p>Draw a white circle.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw a white circle.\"\"\"\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.5), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.DeliveryZone","title":"<code>DeliveryZone</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A zone where agents deliver completed soups for reward.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@register_object_type(\"delivery_zone\", scope=\"overcooked\", can_place_on=True)\nclass DeliveryZone(grid_object.GridObj):\n    \"\"\"A zone where agents deliver completed soups for reward.\"\"\"\n\n    object_id = \"delivery_zone\"\n    color = constants.Colors.Green\n    char = \"@\"\n\n    def __init__(\n        self,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"Initialize with default state.\"\"\"\n        super().__init__(state=0, toggle_value=0.0, placed_on_value=0.0)\n\n    def can_place_on(self, agent: grid_object.GridAgent, cell: grid_object.GridObj) -&gt; bool:\n        \"\"\"True when the agent is holding a soup.\"\"\"\n        toggling_agent_has_soup = any(\n            [isinstance(grid_obj, (OnionSoup, TomatoSoup)) for grid_obj in agent.inventory]\n        )\n\n        if toggling_agent_has_soup:\n            return True\n\n        return False\n\n    def place_on(self, agent: grid_object.GridAgent, cell: grid_object.GridObj) -&gt; None:\n        \"\"\"Accept delivery (no-op; reward handled by reward system).\"\"\"\n        del cell\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.DeliveryZone.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize with default state.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    **kwargs,\n):\n    \"\"\"Initialize with default state.\"\"\"\n    super().__init__(state=0, toggle_value=0.0, placed_on_value=0.0)\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.DeliveryZone.can_place_on","title":"<code>can_place_on(agent, cell)</code>","text":"<p>True when the agent is holding a soup.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def can_place_on(self, agent: grid_object.GridAgent, cell: grid_object.GridObj) -&gt; bool:\n    \"\"\"True when the agent is holding a soup.\"\"\"\n    toggling_agent_has_soup = any(\n        [isinstance(grid_obj, (OnionSoup, TomatoSoup)) for grid_obj in agent.inventory]\n    )\n\n    if toggling_agent_has_soup:\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.DeliveryZone.place_on","title":"<code>place_on(agent, cell)</code>","text":"<p>Accept delivery (no-op; reward handled by reward system).</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def place_on(self, agent: grid_object.GridAgent, cell: grid_object.GridObj) -&gt; None:\n    \"\"\"Accept delivery (no-op; reward handled by reward system).\"\"\"\n    del cell\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.OnionSoup","title":"<code>OnionSoup</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A completed onion soup, ready for delivery.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@register_object_type(\"onion_soup\", scope=\"overcooked\", can_pickup=True)\nclass OnionSoup(grid_object.GridObj):\n    \"\"\"A completed onion soup, ready for delivery.\"\"\"\n\n    object_id = \"onion_soup\"\n    color = constants.Colors.LightBrown\n    char = \"S\"\n\n    def __init__(\n        self,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"Initialize with default state.\"\"\"\n        super().__init__(\n            state=0,\n            inventory_value=0.0,\n        )\n\n    def can_pickup(self, agent: grid_object.GridAgent) -&gt; bool:\n        \"\"\"Return True; soups are always pickable.\"\"\"\n        return True\n\n    def render(self, tile_img):\n        \"\"\"Draw a plate with soup inside.\"\"\"\n        # Draw plate\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.5), Plate.color)\n\n        # draw soup inside plate\n        fill_coords(\n            tile_img,\n            point_in_circle(cx=0.5, cy=0.5, r=0.3),\n            self.color,\n        )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.OnionSoup.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize with default state.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    **kwargs,\n):\n    \"\"\"Initialize with default state.\"\"\"\n    super().__init__(\n        state=0,\n        inventory_value=0.0,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.OnionSoup.can_pickup","title":"<code>can_pickup(agent)</code>","text":"<p>Return True; soups are always pickable.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def can_pickup(self, agent: grid_object.GridAgent) -&gt; bool:\n    \"\"\"Return True; soups are always pickable.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.OnionSoup.render","title":"<code>render(tile_img)</code>","text":"<p>Draw a plate with soup inside.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw a plate with soup inside.\"\"\"\n    # Draw plate\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.5), Plate.color)\n\n    # draw soup inside plate\n    fill_coords(\n        tile_img,\n        point_in_circle(cx=0.5, cy=0.5, r=0.3),\n        self.color,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.TomatoSoup","title":"<code>TomatoSoup</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A completed tomato soup, ready for delivery.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>@register_object_type(\"tomato_soup\", scope=\"overcooked\", can_pickup=True)\nclass TomatoSoup(grid_object.GridObj):\n    \"\"\"A completed tomato soup, ready for delivery.\"\"\"\n\n    object_id = \"tomato_soup\"\n    color = constants.Colors.Red\n    char = \"!\"\n\n    def __init__(\n        self,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"Initialize with default state.\"\"\"\n        super().__init__(\n            state=0,\n            inventory_value=0.0,\n        )\n\n    def can_pickup(self, agent: grid_object.GridAgent) -&gt; bool:\n        \"\"\"Return True; soups are always pickable.\"\"\"\n        return True\n\n    def render(self, tile_img):\n        \"\"\"Draw a plate with soup inside.\"\"\"\n        # Draw plate\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.5), Plate.color)\n\n        # draw soup inside plate\n        fill_coords(\n            tile_img,\n            point_in_circle(cx=0.5, cy=0.5, r=0.3),\n            self.color,\n        )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.TomatoSoup.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Initialize with default state.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    **kwargs,\n):\n    \"\"\"Initialize with default state.\"\"\"\n    super().__init__(\n        state=0,\n        inventory_value=0.0,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.TomatoSoup.can_pickup","title":"<code>can_pickup(agent)</code>","text":"<p>Return True; soups are always pickable.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def can_pickup(self, agent: grid_object.GridAgent) -&gt; bool:\n    \"\"\"Return True; soups are always pickable.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/overcooked_grid_objects/#cogrid.envs.overcooked.overcooked_grid_objects.TomatoSoup.render","title":"<code>render(tile_img)</code>","text":"<p>Draw a plate with soup inside.</p> Source code in <code>cogrid/envs/overcooked/overcooked_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw a plate with soup inside.\"\"\"\n    # Draw plate\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.5), Plate.color)\n\n    # draw soup inside plate\n    fill_coords(\n        tile_img,\n        point_in_circle(cx=0.5, cy=0.5, r=0.3),\n        self.color,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/rewards/","title":"rewards","text":""},{"location":"reference/cogrid/envs/overcooked/rewards/#cogrid.envs.overcooked.rewards","title":"<code>cogrid.envs.overcooked.rewards</code>","text":"<p>Overcooked-specific reward functions.</p> <p>These reward functions operate on state dictionaries instead of Grid objects. They are specific to the Overcooked environment because they reference Overcooked types: pot, onion_soup, delivery_zone, plate, onion.</p> Each reward function has the signature <p>reward_fn(prev_state, state, actions, type_ids, n_agents, ...) -&gt; ndarray of shape (n_agents,)</p> State dicts contain <p>agent_pos:        (n_agents, 2) int32 -- [row, col] agent_dir:        (n_agents,)   int32 -- direction enum (Right=0, Down=1, Left=2, Up=3) agent_inv:        (n_agents, 1) int32 -- inventory type_id, -1 = empty object_type_map:  (H, W) int32        -- type_id at each cell object_state_map: (H, W) int32        -- state value at each cell pot_contents:     (n_pots, 3) int32   -- ingredient type_ids, -1 = empty slot pot_timer:        (n_pots,)   int32   -- cooking timer (0 = ready) pot_positions:    (n_pots, 2) int32   -- pot locations</p> <p>All functions use <code>from cogrid.backend import xp</code> for backend-agnostic array operations. Fully vectorized across agents -- no Python loops, no int() casts.</p>"},{"location":"reference/cogrid/envs/overcooked/rewards/#cogrid.envs.overcooked.rewards.DeliveryReward","title":"<code>DeliveryReward</code>","text":"<p>               Bases: <code>Reward</code></p> <p>Reward for delivering soup to a delivery zone.</p> Source code in <code>cogrid/envs/overcooked/rewards.py</code> <pre><code>@register_reward_type(\"delivery\", scope=\"overcooked\")\nclass DeliveryReward(Reward):\n    \"\"\"Reward for delivering soup to a delivery zone.\"\"\"\n\n    def compute(self, prev_state, state, actions, reward_config):\n        \"\"\"Compute delivery reward for the current step.\"\"\"\n        return delivery_reward(\n            prev_state,\n            state,\n            actions,\n            reward_config[\"type_ids\"],\n            reward_config[\"n_agents\"],\n            coefficient=1.0,\n            common_reward=True,\n            action_pickup_drop_idx=reward_config[\"action_pickup_drop_idx\"],\n        )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/rewards/#cogrid.envs.overcooked.rewards.DeliveryReward.compute","title":"<code>compute(prev_state, state, actions, reward_config)</code>","text":"<p>Compute delivery reward for the current step.</p> Source code in <code>cogrid/envs/overcooked/rewards.py</code> <pre><code>def compute(self, prev_state, state, actions, reward_config):\n    \"\"\"Compute delivery reward for the current step.\"\"\"\n    return delivery_reward(\n        prev_state,\n        state,\n        actions,\n        reward_config[\"type_ids\"],\n        reward_config[\"n_agents\"],\n        coefficient=1.0,\n        common_reward=True,\n        action_pickup_drop_idx=reward_config[\"action_pickup_drop_idx\"],\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/rewards/#cogrid.envs.overcooked.rewards.OnionInPotReward","title":"<code>OnionInPotReward</code>","text":"<p>               Bases: <code>Reward</code></p> <p>Reward for placing an onion into a pot.</p> Source code in <code>cogrid/envs/overcooked/rewards.py</code> <pre><code>@register_reward_type(\"onion_in_pot\", scope=\"overcooked\")\nclass OnionInPotReward(Reward):\n    \"\"\"Reward for placing an onion into a pot.\"\"\"\n\n    def compute(self, prev_state, state, actions, reward_config):\n        \"\"\"Compute onion-in-pot reward for the current step.\"\"\"\n        return onion_in_pot_reward(\n            prev_state,\n            state,\n            actions,\n            reward_config[\"type_ids\"],\n            reward_config[\"n_agents\"],\n            coefficient=0.1,\n            common_reward=False,\n            action_pickup_drop_idx=reward_config[\"action_pickup_drop_idx\"],\n        )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/rewards/#cogrid.envs.overcooked.rewards.OnionInPotReward.compute","title":"<code>compute(prev_state, state, actions, reward_config)</code>","text":"<p>Compute onion-in-pot reward for the current step.</p> Source code in <code>cogrid/envs/overcooked/rewards.py</code> <pre><code>def compute(self, prev_state, state, actions, reward_config):\n    \"\"\"Compute onion-in-pot reward for the current step.\"\"\"\n    return onion_in_pot_reward(\n        prev_state,\n        state,\n        actions,\n        reward_config[\"type_ids\"],\n        reward_config[\"n_agents\"],\n        coefficient=0.1,\n        common_reward=False,\n        action_pickup_drop_idx=reward_config[\"action_pickup_drop_idx\"],\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/rewards/#cogrid.envs.overcooked.rewards.SoupInDishReward","title":"<code>SoupInDishReward</code>","text":"<p>               Bases: <code>Reward</code></p> <p>Reward for picking up completed soup from a pot.</p> Source code in <code>cogrid/envs/overcooked/rewards.py</code> <pre><code>@register_reward_type(\"soup_in_dish\", scope=\"overcooked\")\nclass SoupInDishReward(Reward):\n    \"\"\"Reward for picking up completed soup from a pot.\"\"\"\n\n    def compute(self, prev_state, state, actions, reward_config):\n        \"\"\"Compute soup-in-dish reward for the current step.\"\"\"\n        return soup_in_dish_reward(\n            prev_state,\n            state,\n            actions,\n            reward_config[\"type_ids\"],\n            reward_config[\"n_agents\"],\n            coefficient=0.3,\n            common_reward=False,\n            action_pickup_drop_idx=reward_config[\"action_pickup_drop_idx\"],\n        )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/rewards/#cogrid.envs.overcooked.rewards.SoupInDishReward.compute","title":"<code>compute(prev_state, state, actions, reward_config)</code>","text":"<p>Compute soup-in-dish reward for the current step.</p> Source code in <code>cogrid/envs/overcooked/rewards.py</code> <pre><code>def compute(self, prev_state, state, actions, reward_config):\n    \"\"\"Compute soup-in-dish reward for the current step.\"\"\"\n    return soup_in_dish_reward(\n        prev_state,\n        state,\n        actions,\n        reward_config[\"type_ids\"],\n        reward_config[\"n_agents\"],\n        coefficient=0.3,\n        common_reward=False,\n        action_pickup_drop_idx=reward_config[\"action_pickup_drop_idx\"],\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/rewards/#cogrid.envs.overcooked.rewards.delivery_reward","title":"<code>delivery_reward(prev_state, state, actions, type_ids, n_agents, coefficient=1.0, common_reward=True, action_pickup_drop_idx=4)</code>","text":"<p>Reward for delivering soup to a DeliveryZone. Fully vectorized.</p> Source code in <code>cogrid/envs/overcooked/rewards.py</code> <pre><code>def delivery_reward(\n    prev_state,\n    state,\n    actions,\n    type_ids,\n    n_agents,\n    coefficient=1.0,\n    common_reward=True,\n    action_pickup_drop_idx=4,\n):\n    \"\"\"Reward for delivering soup to a DeliveryZone. Fully vectorized.\"\"\"\n    fwd_pos, fwd_r, fwd_c, in_bounds, fwd_types = _compute_fwd_positions(prev_state)\n\n    is_interact = actions == action_pickup_drop_idx  # (n_agents,)\n    holds_soup = prev_state.agent_inv[:, 0] == type_ids[\"onion_soup\"]  # (n_agents,)\n    faces_delivery = fwd_types == type_ids[\"delivery_zone\"]  # (n_agents,)\n\n    earns_reward = is_interact &amp; holds_soup &amp; faces_delivery &amp; in_bounds  # (n_agents,)\n\n    # Apply reward: in common_reward mode, every earning agent adds coefficient\n    # to ALL agents. This matches: `rewards = rewards + coefficient` per earner.\n    if common_reward:\n        n_earners = xp.sum(earns_reward.astype(xp.float32))\n        rewards = xp.full(n_agents, n_earners * coefficient, dtype=xp.float32)\n    else:\n        rewards = earns_reward.astype(xp.float32) * coefficient\n\n    return rewards\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/rewards/#cogrid.envs.overcooked.rewards.onion_in_pot_reward","title":"<code>onion_in_pot_reward(prev_state, state, actions, type_ids, n_agents, coefficient=0.1, common_reward=False, action_pickup_drop_idx=4)</code>","text":"<p>Reward for placing an onion into a pot with capacity. Fully vectorized.</p> Source code in <code>cogrid/envs/overcooked/rewards.py</code> <pre><code>def onion_in_pot_reward(\n    prev_state,\n    state,\n    actions,\n    type_ids,\n    n_agents,\n    coefficient=0.1,\n    common_reward=False,\n    action_pickup_drop_idx=4,\n):\n    \"\"\"Reward for placing an onion into a pot with capacity. Fully vectorized.\"\"\"\n    fwd_pos, fwd_r, fwd_c, in_bounds, fwd_types = _compute_fwd_positions(prev_state)\n\n    is_interact = actions == action_pickup_drop_idx\n    holds_onion = prev_state.agent_inv[:, 0] == type_ids[\"onion\"]\n    faces_pot = fwd_types == type_ids[\"pot\"]\n\n    # Array-based pot position matching:\n    # For each agent, check which pot (if any) their forward position matches.\n    # fwd_pos[:, :] is (n_agents, 2), pot_positions is (n_pots, 2)\n    agent_fwd = xp.stack([fwd_r, fwd_c], axis=1)  # (n_agents, 2) clipped\n    pot_positions = prev_state.pot_positions  # (n_pots, 2)\n\n    # pos_match[i, j] = True iff agent i faces pot j\n    pos_match = xp.all(\n        pot_positions[None, :, :] == agent_fwd[:, None, :],\n        axis=2,\n    )  # (n_agents, n_pots)\n    facing_any_pot = xp.any(pos_match, axis=1)  # (n_agents,)\n    pot_idx = xp.argmax(pos_match, axis=1)  # (n_agents,) -- index of matched pot\n\n    # Check pot capacity and type compatibility for each agent's matched pot.\n    # pot_contents[pot_idx] gives (n_agents, 3) -- the contents of each agent's pot.\n    pot_row = prev_state.pot_contents[pot_idx]  # (n_agents, 3)\n    n_filled = xp.sum(pot_row != -1, axis=1)  # (n_agents,)\n    has_capacity = n_filled &lt; 3\n\n    # Same-type check: all non-empty slots must be onion (or empty)\n    is_onion_or_empty = (pot_row == -1) | (pot_row == type_ids[\"onion\"])\n    compatible = xp.all(is_onion_or_empty, axis=1)  # (n_agents,)\n\n    earns_reward = (\n        is_interact\n        &amp; holds_onion\n        &amp; faces_pot\n        &amp; in_bounds\n        &amp; facing_any_pot\n        &amp; has_capacity\n        &amp; compatible\n    )\n\n    if common_reward:\n        n_earners = xp.sum(earns_reward.astype(xp.float32))\n        rewards = xp.full(n_agents, n_earners * coefficient, dtype=xp.float32)\n    else:\n        rewards = earns_reward.astype(xp.float32) * coefficient\n\n    return rewards\n</code></pre>"},{"location":"reference/cogrid/envs/overcooked/rewards/#cogrid.envs.overcooked.rewards.soup_in_dish_reward","title":"<code>soup_in_dish_reward(prev_state, state, actions, type_ids, n_agents, coefficient=0.3, common_reward=False, action_pickup_drop_idx=4)</code>","text":"<p>Reward for picking up a ready soup from a pot with a plate. Fully vectorized.</p> Source code in <code>cogrid/envs/overcooked/rewards.py</code> <pre><code>def soup_in_dish_reward(\n    prev_state,\n    state,\n    actions,\n    type_ids,\n    n_agents,\n    coefficient=0.3,\n    common_reward=False,\n    action_pickup_drop_idx=4,\n):\n    \"\"\"Reward for picking up a ready soup from a pot with a plate. Fully vectorized.\"\"\"\n    fwd_pos, fwd_r, fwd_c, in_bounds, fwd_types = _compute_fwd_positions(prev_state)\n\n    is_interact = actions == action_pickup_drop_idx\n    holds_plate = prev_state.agent_inv[:, 0] == type_ids[\"plate\"]\n    faces_pot = fwd_types == type_ids[\"pot\"]\n\n    # Array-based pot position matching\n    agent_fwd = xp.stack([fwd_r, fwd_c], axis=1)  # (n_agents, 2)\n    pot_positions = prev_state.pot_positions  # (n_pots, 2)\n\n    pos_match = xp.all(\n        pot_positions[None, :, :] == agent_fwd[:, None, :],\n        axis=2,\n    )  # (n_agents, n_pots)\n    facing_any_pot = xp.any(pos_match, axis=1)  # (n_agents,)\n    pot_idx = xp.argmax(pos_match, axis=1)  # (n_agents,)\n\n    # Check pot is ready: timer == 0\n    pot_timer_vals = prev_state.pot_timer[pot_idx]  # (n_agents,)\n    pot_ready = pot_timer_vals == 0\n\n    earns_reward = is_interact &amp; holds_plate &amp; faces_pot &amp; in_bounds &amp; facing_any_pot &amp; pot_ready\n\n    if common_reward:\n        n_earners = xp.sum(earns_reward.astype(xp.float32))\n        rewards = xp.full(n_agents, n_earners * coefficient, dtype=xp.float32)\n    else:\n        rewards = earns_reward.astype(xp.float32) * coefficient\n\n    return rewards\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/","title":"search_rescue","text":""},{"location":"reference/cogrid/envs/search_rescue/#cogrid.envs.search_rescue","title":"<code>cogrid.envs.search_rescue</code>","text":"<p>Search-and-rescue environment.</p>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/","title":"search_rescue_grid_objects","text":""},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects","title":"<code>cogrid.envs.search_rescue.search_rescue_grid_objects</code>","text":"<p>Search-and-rescue grid object types (items, obstacles, victims).</p>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.MedKit","title":"<code>MedKit</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A medical kit that enables rescuing yellow victims.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>class MedKit(grid_object.GridObj):\n    \"\"\"A medical kit that enables rescuing yellow victims.\"\"\"\n\n    object_id = \"medkit\"\n    color = constants.Colors.LightPink\n    char = \"M\"\n\n    def __init__(self, state=0):\n        \"\"\"Initialize with default state.\"\"\"\n        super().__init__(\n            state=state,\n        )\n\n    def can_pickup(self, agent: grid_object.GridAgent):\n        \"\"\"Return True; medkits are always pickable.\"\"\"\n        return True\n\n    def render(self, tile_img):\n        \"\"\"Draw a red cross icon.\"\"\"\n        # red background with white cross\n        fill_coords(tile_img, point_in_rect(0.1, 0.9, 0.1, 0.9), (255, 0, 0))\n        fill_coords(tile_img, point_in_rect(0.4, 0.6, 0.2, 0.8), (255, 255, 255))\n        fill_coords(tile_img, point_in_rect(0.2, 0.8, 0.4, 0.6), (255, 255, 255))\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.MedKit.__init__","title":"<code>__init__(state=0)</code>","text":"<p>Initialize with default state.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def __init__(self, state=0):\n    \"\"\"Initialize with default state.\"\"\"\n    super().__init__(\n        state=state,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.MedKit.can_pickup","title":"<code>can_pickup(agent)</code>","text":"<p>Return True; medkits are always pickable.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def can_pickup(self, agent: grid_object.GridAgent):\n    \"\"\"Return True; medkits are always pickable.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.MedKit.render","title":"<code>render(tile_img)</code>","text":"<p>Draw a red cross icon.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw a red cross icon.\"\"\"\n    # red background with white cross\n    fill_coords(tile_img, point_in_rect(0.1, 0.9, 0.1, 0.9), (255, 0, 0))\n    fill_coords(tile_img, point_in_rect(0.4, 0.6, 0.2, 0.8), (255, 255, 255))\n    fill_coords(tile_img, point_in_rect(0.2, 0.8, 0.4, 0.6), (255, 255, 255))\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.Pickaxe","title":"<code>Pickaxe</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A tool that enables clearing rubble obstacles.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>class Pickaxe(grid_object.GridObj):\n    \"\"\"A tool that enables clearing rubble obstacles.\"\"\"\n\n    object_id = \"pickaxe\"\n    color = constants.Colors.Grey\n    char = \"T\"\n\n    def __init__(self, state=0):\n        \"\"\"Initialize with default state.\"\"\"\n        super().__init__(\n            state=state,\n        )\n\n    def can_pickup(self, agent: grid_object.GridAgent):\n        \"\"\"Return True; pickaxes are always pickable.\"\"\"\n        return True\n\n    def render(self, tile_img):\n        \"\"\"Draw a pickaxe with brown handle and grey head.\"\"\"\n        # Brown Handle\n        fill_coords(tile_img, point_in_rect(0.45, 0.55, 0.15, 0.9), constants.Colors.Brown)\n\n        # Use two triangles to make the pickaxe head\n        # These are of the specified color\n        tri_fn = point_in_triangle(\n            (0.5, 0.1),\n            (0.5, 0.3),\n            (0.9, 0.35),\n        )\n        fill_coords(tile_img, tri_fn, self.color)\n\n        tri_fn = point_in_triangle(\n            (0.5, 0.1),\n            (0.5, 0.3),\n            (0.1, 0.35),\n        )\n        fill_coords(tile_img, tri_fn, self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.Pickaxe.__init__","title":"<code>__init__(state=0)</code>","text":"<p>Initialize with default state.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def __init__(self, state=0):\n    \"\"\"Initialize with default state.\"\"\"\n    super().__init__(\n        state=state,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.Pickaxe.can_pickup","title":"<code>can_pickup(agent)</code>","text":"<p>Return True; pickaxes are always pickable.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def can_pickup(self, agent: grid_object.GridAgent):\n    \"\"\"Return True; pickaxes are always pickable.\"\"\"\n    return True\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.Pickaxe.render","title":"<code>render(tile_img)</code>","text":"<p>Draw a pickaxe with brown handle and grey head.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw a pickaxe with brown handle and grey head.\"\"\"\n    # Brown Handle\n    fill_coords(tile_img, point_in_rect(0.45, 0.55, 0.15, 0.9), constants.Colors.Brown)\n\n    # Use two triangles to make the pickaxe head\n    # These are of the specified color\n    tri_fn = point_in_triangle(\n        (0.5, 0.1),\n        (0.5, 0.3),\n        (0.9, 0.35),\n    )\n    fill_coords(tile_img, tri_fn, self.color)\n\n    tri_fn = point_in_triangle(\n        (0.5, 0.1),\n        (0.5, 0.3),\n        (0.1, 0.35),\n    )\n    fill_coords(tile_img, tri_fn, self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.Rubble","title":"<code>Rubble</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>An obstacle that can be cleared by an Engineer or agent with Pickaxe.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>class Rubble(grid_object.GridObj):\n    \"\"\"An obstacle that can be cleared by an Engineer or agent with Pickaxe.\"\"\"\n\n    object_id = \"rubble\"\n    color = constants.Colors.Brown\n    char = \"X\"\n\n    def __init__(self, state=0):\n        \"\"\"Initialize with toggle reward for clearing.\"\"\"\n        super().__init__(\n            state=state,\n            toggle_value=0.05,  # reward for clearing rubble\n        )\n\n    def see_behind(self) -&gt; bool:\n        \"\"\"Return False; rubble blocks visibility.\"\"\"\n        return False\n\n    def toggle(self, env, agent=None) -&gt; bool:\n        \"\"\"Clear rubble if the toggling agent is an Engineer or holds a Pickaxe.\"\"\"\n        assert agent\n        adj_positions = [*adjacent_positions(*self.pos)]\n        toggling_agent_is_adjacent = tuple(agent.pos) in adj_positions\n        toggling_agent_is_engineer = (\n            any([isinstance(obj, Pickaxe) for obj in agent.inventory])\n            or agent.role == Roles.Engineer\n        )\n\n        assert toggling_agent_is_adjacent, \"Rubble toggled by non-adjacent agent.\"\n\n        toggle_success = toggling_agent_is_engineer\n\n        if toggle_success:\n            self._remove_from_grid(env.grid)\n\n        return toggle_success\n\n    def render(self, tile_img):\n        \"\"\"Draw three brown circles representing rubble pile.\"\"\"\n        fill_coords(tile_img, point_in_circle(cx=0.25, cy=0.3, r=0.2), self.color)\n        fill_coords(tile_img, point_in_circle(cx=0.75, cy=0.3, r=0.2), self.color)\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.7, r=0.2), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.Rubble.__init__","title":"<code>__init__(state=0)</code>","text":"<p>Initialize with toggle reward for clearing.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def __init__(self, state=0):\n    \"\"\"Initialize with toggle reward for clearing.\"\"\"\n    super().__init__(\n        state=state,\n        toggle_value=0.05,  # reward for clearing rubble\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.Rubble.see_behind","title":"<code>see_behind()</code>","text":"<p>Return False; rubble blocks visibility.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def see_behind(self) -&gt; bool:\n    \"\"\"Return False; rubble blocks visibility.\"\"\"\n    return False\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.Rubble.toggle","title":"<code>toggle(env, agent=None)</code>","text":"<p>Clear rubble if the toggling agent is an Engineer or holds a Pickaxe.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def toggle(self, env, agent=None) -&gt; bool:\n    \"\"\"Clear rubble if the toggling agent is an Engineer or holds a Pickaxe.\"\"\"\n    assert agent\n    adj_positions = [*adjacent_positions(*self.pos)]\n    toggling_agent_is_adjacent = tuple(agent.pos) in adj_positions\n    toggling_agent_is_engineer = (\n        any([isinstance(obj, Pickaxe) for obj in agent.inventory])\n        or agent.role == Roles.Engineer\n    )\n\n    assert toggling_agent_is_adjacent, \"Rubble toggled by non-adjacent agent.\"\n\n    toggle_success = toggling_agent_is_engineer\n\n    if toggle_success:\n        self._remove_from_grid(env.grid)\n\n    return toggle_success\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.Rubble.render","title":"<code>render(tile_img)</code>","text":"<p>Draw three brown circles representing rubble pile.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw three brown circles representing rubble pile.\"\"\"\n    fill_coords(tile_img, point_in_circle(cx=0.25, cy=0.3, r=0.2), self.color)\n    fill_coords(tile_img, point_in_circle(cx=0.75, cy=0.3, r=0.2), self.color)\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.7, r=0.2), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.GreenVictim","title":"<code>GreenVictim</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A victim rescuable by any adjacent agent.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>class GreenVictim(grid_object.GridObj):\n    \"\"\"A victim rescuable by any adjacent agent.\"\"\"\n\n    object_id = \"green_victim\"\n    color = constants.Colors.Green\n    char = \"G\"\n\n    def __init__(self, state=0):\n        \"\"\"Initialize with toggle reward for rescuing.\"\"\"\n        super().__init__(\n            state=state,\n            toggle_value=0.1,  # 0.1 reward for rescuing\n        )\n\n    def toggle(self, env, agent=None) -&gt; bool:\n        \"\"\"Rescue the victim if any agent is adjacent.\"\"\"\n        assert agent\n        adj_positions = [*adjacent_positions(*self.pos)]\n        toggling_agent_is_adjacent = tuple(agent.pos) in adj_positions\n        assert toggling_agent_is_adjacent, \"GreenVictim toggled by non-adjacent agent.\"\n\n        self._remove_from_grid(env.grid)\n        return toggling_agent_is_adjacent\n\n    def render(self, tile_img):\n        \"\"\"Draw a green circle.\"\"\"\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.47, r=0.4), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.GreenVictim.__init__","title":"<code>__init__(state=0)</code>","text":"<p>Initialize with toggle reward for rescuing.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def __init__(self, state=0):\n    \"\"\"Initialize with toggle reward for rescuing.\"\"\"\n    super().__init__(\n        state=state,\n        toggle_value=0.1,  # 0.1 reward for rescuing\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.GreenVictim.toggle","title":"<code>toggle(env, agent=None)</code>","text":"<p>Rescue the victim if any agent is adjacent.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def toggle(self, env, agent=None) -&gt; bool:\n    \"\"\"Rescue the victim if any agent is adjacent.\"\"\"\n    assert agent\n    adj_positions = [*adjacent_positions(*self.pos)]\n    toggling_agent_is_adjacent = tuple(agent.pos) in adj_positions\n    assert toggling_agent_is_adjacent, \"GreenVictim toggled by non-adjacent agent.\"\n\n    self._remove_from_grid(env.grid)\n    return toggling_agent_is_adjacent\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.GreenVictim.render","title":"<code>render(tile_img)</code>","text":"<p>Draw a green circle.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw a green circle.\"\"\"\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.47, r=0.4), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.PurpleVictim","title":"<code>PurpleVictim</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A victim rescuable by any adjacent agent (higher reward).</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>class PurpleVictim(grid_object.GridObj):\n    \"\"\"A victim rescuable by any adjacent agent (higher reward).\"\"\"\n\n    object_id = \"purple_victim\"\n    color = constants.Colors.Purple\n    char = \"P\"\n\n    def __init__(self, state=0):\n        \"\"\"Initialize with toggle reward for rescuing.\"\"\"\n        super().__init__(\n            state=state,\n            toggle_value=0.2,\n        )\n\n    def toggle(self, env, agent=None) -&gt; bool:\n        \"\"\"Rescue the victim if any agent is adjacent.\"\"\"\n        assert agent\n        adj_positions = [*adjacent_positions(*self.pos)]\n        toggling_agent_is_adjacent = tuple(agent.pos) in adj_positions\n        assert toggling_agent_is_adjacent, \"PurpleVictim toggled by non-adjacent agent.\"\n\n        self._remove_from_grid(env.grid)\n        return toggling_agent_is_adjacent\n\n    def render(self, tile_img):\n        \"\"\"Draw a purple circle.\"\"\"\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.47, r=0.4), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.PurpleVictim.__init__","title":"<code>__init__(state=0)</code>","text":"<p>Initialize with toggle reward for rescuing.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def __init__(self, state=0):\n    \"\"\"Initialize with toggle reward for rescuing.\"\"\"\n    super().__init__(\n        state=state,\n        toggle_value=0.2,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.PurpleVictim.toggle","title":"<code>toggle(env, agent=None)</code>","text":"<p>Rescue the victim if any agent is adjacent.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def toggle(self, env, agent=None) -&gt; bool:\n    \"\"\"Rescue the victim if any agent is adjacent.\"\"\"\n    assert agent\n    adj_positions = [*adjacent_positions(*self.pos)]\n    toggling_agent_is_adjacent = tuple(agent.pos) in adj_positions\n    assert toggling_agent_is_adjacent, \"PurpleVictim toggled by non-adjacent agent.\"\n\n    self._remove_from_grid(env.grid)\n    return toggling_agent_is_adjacent\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.PurpleVictim.render","title":"<code>render(tile_img)</code>","text":"<p>Draw a purple circle.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw a purple circle.\"\"\"\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.47, r=0.4), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.YellowVictim","title":"<code>YellowVictim</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A victim rescuable only by a Medic or agent carrying a MedKit.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>class YellowVictim(grid_object.GridObj):\n    \"\"\"A victim rescuable only by a Medic or agent carrying a MedKit.\"\"\"\n\n    object_id = \"yellow_victim\"\n    color = constants.Colors.Yellow\n    char = \"Y\"\n\n    def __init__(self, state=0):\n        \"\"\"Initialize with toggle reward for rescuing.\"\"\"\n        super().__init__(\n            state=state,\n            toggle_value=0.2,\n        )\n\n    def toggle(self, env, agent=None) -&gt; bool:\n        \"\"\"Rescue the victim if a Medic or MedKit-holding agent is adjacent.\"\"\"\n        assert agent\n        adj_positions = [*adjacent_positions(*self.pos)]\n        toggling_agent_is_adjacent = tuple(agent.pos) in adj_positions\n        toggling_agent_is_medic = (\n            any([isinstance(obj, MedKit) for obj in agent.inventory]) or agent.role == Roles.Medic\n        )\n\n        assert toggling_agent_is_adjacent, \"YellowVictim toggled by non-adjacent agent.\"\n\n        toggle_success = toggling_agent_is_medic\n\n        if toggle_success:\n            self._remove_from_grid(env.grid)\n        return toggle_success\n\n    def render(self, tile_img):\n        \"\"\"Draw a yellow circle.\"\"\"\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.47, r=0.4), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.YellowVictim.__init__","title":"<code>__init__(state=0)</code>","text":"<p>Initialize with toggle reward for rescuing.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def __init__(self, state=0):\n    \"\"\"Initialize with toggle reward for rescuing.\"\"\"\n    super().__init__(\n        state=state,\n        toggle_value=0.2,\n    )\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.YellowVictim.toggle","title":"<code>toggle(env, agent=None)</code>","text":"<p>Rescue the victim if a Medic or MedKit-holding agent is adjacent.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def toggle(self, env, agent=None) -&gt; bool:\n    \"\"\"Rescue the victim if a Medic or MedKit-holding agent is adjacent.\"\"\"\n    assert agent\n    adj_positions = [*adjacent_positions(*self.pos)]\n    toggling_agent_is_adjacent = tuple(agent.pos) in adj_positions\n    toggling_agent_is_medic = (\n        any([isinstance(obj, MedKit) for obj in agent.inventory]) or agent.role == Roles.Medic\n    )\n\n    assert toggling_agent_is_adjacent, \"YellowVictim toggled by non-adjacent agent.\"\n\n    toggle_success = toggling_agent_is_medic\n\n    if toggle_success:\n        self._remove_from_grid(env.grid)\n    return toggle_success\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.YellowVictim.render","title":"<code>render(tile_img)</code>","text":"<p>Draw a yellow circle.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw a yellow circle.\"\"\"\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.47, r=0.4), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.RedVictim","title":"<code>RedVictim</code>","text":"<p>               Bases: <code>GridObj</code></p> <p>A victim requiring two-agent cooperative rescue within a time window.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>class RedVictim(grid_object.GridObj):\n    \"\"\"A victim requiring two-agent cooperative rescue within a time window.\"\"\"\n\n    object_id = \"red_victim\"\n    color = constants.Colors.Red\n    char = \"R\"\n\n    def __init__(self, state=0):\n        \"\"\"Initialize with countdown timer for cooperative rescue.\"\"\"\n        super().__init__(\n            state=state,\n        )\n        self.toggle_countdown = 0\n        self.first_toggle_agent_id: typing.AgentID = None\n\n    def tick(self):\n        \"\"\"Decrement toggle countdown each timestep and update state.\"\"\"\n        if self.toggle_countdown &gt; 0:\n            self.toggle_countdown -= 1\n        self.state = self.toggle_countdown\n\n    def toggle(self, env, agent) -&gt; bool:\n        \"\"\"Start or complete a cooperative rescue.\n\n        First toggle by a MedKit-holder starts a 30-step countdown.\n        A second toggle by a different agent within the window completes rescue.\n        \"\"\"\n        if self.toggle_countdown == 0:\n            toggling_agent_has_medkit = any([isinstance(obj, MedKit) for obj in agent.inventory])\n\n            if toggling_agent_has_medkit:\n                self.first_toggle_agent = agent.agent_id\n                self.toggle_countdown = 30\n\n            return True\n\n        if self.toggle_countdown &gt; 0 and agent.agent_id != self.first_toggle_agent:\n            self._remove_from_grid(env.grid)\n            return True\n\n        return False\n\n    def render(self, tile_img):\n        \"\"\"Draw a red circle.\"\"\"\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.47, r=0.4), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.RedVictim.__init__","title":"<code>__init__(state=0)</code>","text":"<p>Initialize with countdown timer for cooperative rescue.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def __init__(self, state=0):\n    \"\"\"Initialize with countdown timer for cooperative rescue.\"\"\"\n    super().__init__(\n        state=state,\n    )\n    self.toggle_countdown = 0\n    self.first_toggle_agent_id: typing.AgentID = None\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.RedVictim.tick","title":"<code>tick()</code>","text":"<p>Decrement toggle countdown each timestep and update state.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def tick(self):\n    \"\"\"Decrement toggle countdown each timestep and update state.\"\"\"\n    if self.toggle_countdown &gt; 0:\n        self.toggle_countdown -= 1\n    self.state = self.toggle_countdown\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.RedVictim.toggle","title":"<code>toggle(env, agent)</code>","text":"<p>Start or complete a cooperative rescue.</p> <p>First toggle by a MedKit-holder starts a 30-step countdown. A second toggle by a different agent within the window completes rescue.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def toggle(self, env, agent) -&gt; bool:\n    \"\"\"Start or complete a cooperative rescue.\n\n    First toggle by a MedKit-holder starts a 30-step countdown.\n    A second toggle by a different agent within the window completes rescue.\n    \"\"\"\n    if self.toggle_countdown == 0:\n        toggling_agent_has_medkit = any([isinstance(obj, MedKit) for obj in agent.inventory])\n\n        if toggling_agent_has_medkit:\n            self.first_toggle_agent = agent.agent_id\n            self.toggle_countdown = 30\n\n        return True\n\n    if self.toggle_countdown &gt; 0 and agent.agent_id != self.first_toggle_agent:\n        self._remove_from_grid(env.grid)\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/search_rescue_grid_objects/#cogrid.envs.search_rescue.search_rescue_grid_objects.RedVictim.render","title":"<code>render(tile_img)</code>","text":"<p>Draw a red circle.</p> Source code in <code>cogrid/envs/search_rescue/search_rescue_grid_objects.py</code> <pre><code>def render(self, tile_img):\n    \"\"\"Draw a red circle.\"\"\"\n    fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.47, r=0.4), self.color)\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/sr_utils/","title":"sr_utils","text":""},{"location":"reference/cogrid/envs/search_rescue/sr_utils/#cogrid.envs.search_rescue.sr_utils","title":"<code>cogrid.envs.search_rescue.sr_utils</code>","text":"<p>Search-and-rescue layout utilities.</p>"},{"location":"reference/cogrid/envs/search_rescue/sr_utils/#cogrid.envs.search_rescue.sr_utils.FixedGrids","title":"<code>FixedGrids</code>  <code>dataclass</code>","text":"<p>Pre-defined search-and-rescue grid layouts.</p> Source code in <code>cogrid/envs/search_rescue/sr_utils.py</code> <pre><code>@dataclasses.dataclass\nclass FixedGrids:\n    \"\"\"Pre-defined search-and-rescue grid layouts.\"\"\"\n\n    m3minimap = [\n        \"#############\",\n        \"#S  S#      #\",\n        \"#  X #      #\",\n        \"# XR #XYXG  #\",\n        \"#    # X  XY#\",\n        \"#   X#     X#\",\n        \"#  XY#      #\",\n        \"#    #  RX  #\",\n        \"##X###  X   #\",\n        \"#    #     X#\",\n        \"#    #G   XR#\",\n        \"#  X #     X#\",\n        \"# XYX#    # #\",\n        \"#    ###X# ##\",\n        \"#G   #    G #\",\n        \"#    X     G#\",\n        \"#    #X     #\",\n        \"#    #YXX # #\",\n        \"# X  #X RX ##\",\n        \"# RX #  #####\",\n        \"#   #########\",\n        \"#############\",\n    ]\n\n    m3minimap_reduced = [\n        \"#############\",\n        \"#S  S       #\",\n        \"#  X   X    #\",\n        \"# XRX XYXG  #\",\n        \"#  XG  X  XY#\",\n        \"#  XYX      #\",\n        \"#   X     XX#\",\n        \"#XX       XX#\",\n        \"#RX  X    XR#\",\n        \"#############\",\n    ]\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/sr_utils/#cogrid.envs.search_rescue.sr_utils.generate_sr_grid","title":"<code>generate_sr_grid(shape=None, load=None, num_green=4, num_yellow=3, num_red=2, num_agents=2, populate_rubble=True, np_random=None)</code>","text":"<p>Generate or load a search-and-rescue grid layout.</p> Source code in <code>cogrid/envs/search_rescue/sr_utils.py</code> <pre><code>def generate_sr_grid(\n    shape=None,\n    load=None,\n    num_green=4,\n    num_yellow=3,\n    num_red=2,\n    num_agents=2,\n    populate_rubble=True,\n    np_random=None,\n):\n    \"\"\"Generate or load a search-and-rescue grid layout.\"\"\"\n    if np_random is None:\n        np_random = np.random.RandomState(seed=42)\n\n    if load is not None:\n        return getattr(FixedGrids, load)\n\n    # First channel is characters, second channel is state\n    grid = np.full((*shape, 2), fill_value=constants.GridConstants.FreeSpace)\n    grid[:, :, 1] = 0\n\n    # Fill outside border with walls\n    grid[0, :] = grid_object.Wall.char\n    grid[-1, :] = grid_object.Wall.char\n    grid[:, 0] = grid_object.Wall.char\n    grid[:, -1] = grid_object.Wall.char\n\n    # Get free space indices\n    free_spaces = list(np.argwhere(grid[:, :, 0] == constants.GridConstants.FreeSpace))\n\n    objs_to_place = num_green + num_yellow + num_red + num_agents\n    assert len(free_spaces) &gt;= objs_to_place, (\n        \"Not enough free spaces for specified number of objects!\"\n    )\n\n    np_random.shuffle(free_spaces)\n\n    for _ in range(num_green):\n        r, c = free_spaces.pop()\n        grid[r, c, 0] = \"G\"\n\n    for _ in range(num_yellow):\n        r, c = free_spaces.pop()\n        grid[r, c, 0] = \"Y\"\n\n    for _ in range(num_red):\n        r, c = free_spaces.pop()\n        grid[r, c, 0] = \"R\"\n\n    # add spawns\n    for _ in range(num_agents):\n        r, c = free_spaces.pop()\n        grid[r, c, 0] = \"S\"\n\n    if populate_rubble:\n        # populate rubble around yellow and red\n        for r, c in np.argwhere(grid == \"Y\"):\n            grid[:, :, 0] = surround_by_rubble(grid[:, :, 0], r, c)\n        for r, c in np.argwhere(grid == \"R\"):\n            grid[:, :, 0] = surround_by_rubble(grid[:, :, 0], r, c)\n\n    return grid\n</code></pre>"},{"location":"reference/cogrid/envs/search_rescue/sr_utils/#cogrid.envs.search_rescue.sr_utils.surround_by_rubble","title":"<code>surround_by_rubble(grid, row, col)</code>","text":"<p>Place rubble in all free cardinal neighbors of a cell.</p> Source code in <code>cogrid/envs/search_rescue/sr_utils.py</code> <pre><code>def surround_by_rubble(grid, row, col):\n    \"\"\"Place rubble in all free cardinal neighbors of a cell.\"\"\"\n    for r, c in grid_utils.adjacent_positions(row, col):\n        if grid[r, c] == constants.GridConstants.FreeSpace:\n            grid[r, c] = constants.GridConstants.Rubble\n    return grid\n</code></pre>"},{"location":"reference/cogrid/feature_space/","title":"feature_space","text":""},{"location":"reference/cogrid/feature_space/#cogrid.feature_space","title":"<code>cogrid.feature_space</code>","text":"<p>Feature extraction for observations.</p>"},{"location":"reference/cogrid/feature_space/features/","title":"features","text":""},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features","title":"<code>cogrid.feature_space.features</code>","text":"<p>Feature extractors operating on state arrays.</p> <p>These functions operate directly on state arrays (agent_pos, agent_dir, object_type_map, etc.) produced by layout_to_state() and create_agent_arrays(), producing numerically identical observations to the existing feature system.</p> <p>Feature composition is handled by autowire via <code>compose_feature_fns()</code> in <code>cogrid/core/features.py</code>. Each Feature subclass provides a <code>build_feature_fn(cls, scope)</code> classmethod that returns a closure.</p> <p>All functions use <code>xp</code> (the backend-agnostic array namespace) so they work identically on both numpy and JAX backends. No <code>_jax</code> variants exist; a single implementation serves both paths.</p>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.AgentDir","title":"<code>AgentDir</code>","text":"<p>               Bases: <code>Feature</code></p> <p>One-hot agent direction feature.</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>@register_feature_type(\"agent_dir\", scope=\"global\")\nclass AgentDir(Feature):\n    \"\"\"One-hot agent direction feature.\"\"\"\n\n    per_agent = True\n    obs_dim = 4\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build the agent direction feature function.\"\"\"\n\n        def fn(state, agent_idx):\n            return agent_dir_feature(state.agent_dir, agent_idx)\n\n        return fn\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.AgentDir.build_feature_fn","title":"<code>build_feature_fn(scope)</code>  <code>classmethod</code>","text":"<p>Build the agent direction feature function.</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>@classmethod\ndef build_feature_fn(cls, scope):\n    \"\"\"Build the agent direction feature function.\"\"\"\n\n    def fn(state, agent_idx):\n        return agent_dir_feature(state.agent_dir, agent_idx)\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.AgentPosition","title":"<code>AgentPosition</code>","text":"<p>               Bases: <code>Feature</code></p> <p>Agent position feature.</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>@register_feature_type(\"agent_position\", scope=\"global\")\nclass AgentPosition(Feature):\n    \"\"\"Agent position feature.\"\"\"\n\n    per_agent = True\n    obs_dim = 2\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build the agent position feature function.\"\"\"\n\n        def fn(state, agent_idx):\n            return agent_pos_feature(state.agent_pos, agent_idx)\n\n        return fn\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.AgentPosition.build_feature_fn","title":"<code>build_feature_fn(scope)</code>  <code>classmethod</code>","text":"<p>Build the agent position feature function.</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>@classmethod\ndef build_feature_fn(cls, scope):\n    \"\"\"Build the agent position feature function.\"\"\"\n\n    def fn(state, agent_idx):\n        return agent_pos_feature(state.agent_pos, agent_idx)\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.CanMoveDirection","title":"<code>CanMoveDirection</code>","text":"<p>               Bases: <code>Feature</code></p> <p>Multi-hot encoding of walkable cardinal directions.</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>@register_feature_type(\"can_move_direction\", scope=\"global\")\nclass CanMoveDirection(Feature):\n    \"\"\"Multi-hot encoding of walkable cardinal directions.\"\"\"\n\n    per_agent = True\n    obs_dim = 4\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build the can-move-direction feature function.\"\"\"\n        from cogrid.core.grid_object import build_lookup_tables\n\n        tables = build_lookup_tables(scope=scope)\n        can_overlap_table = xp.array(tables[\"CAN_OVERLAP\"], dtype=xp.int32)\n\n        def fn(state, agent_idx):\n            return can_move_direction_feature(\n                state.agent_pos,\n                agent_idx,\n                state.wall_map,\n                state.object_type_map,\n                can_overlap_table,\n            )\n\n        return fn\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.CanMoveDirection.build_feature_fn","title":"<code>build_feature_fn(scope)</code>  <code>classmethod</code>","text":"<p>Build the can-move-direction feature function.</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>@classmethod\ndef build_feature_fn(cls, scope):\n    \"\"\"Build the can-move-direction feature function.\"\"\"\n    from cogrid.core.grid_object import build_lookup_tables\n\n    tables = build_lookup_tables(scope=scope)\n    can_overlap_table = xp.array(tables[\"CAN_OVERLAP\"], dtype=xp.int32)\n\n    def fn(state, agent_idx):\n        return can_move_direction_feature(\n            state.agent_pos,\n            agent_idx,\n            state.wall_map,\n            state.object_type_map,\n            can_overlap_table,\n        )\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.Inventory","title":"<code>Inventory</code>","text":"<p>               Bases: <code>Feature</code></p> <p>Agent inventory contents as a single integer feature.</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>@register_feature_type(\"inventory\", scope=\"global\")\nclass Inventory(Feature):\n    \"\"\"Agent inventory contents as a single integer feature.\"\"\"\n\n    per_agent = True\n    obs_dim = 1\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build the inventory feature function.\"\"\"\n\n        def fn(state, agent_idx):\n            return inventory_feature(state.agent_inv, agent_idx)\n\n        return fn\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.Inventory.build_feature_fn","title":"<code>build_feature_fn(scope)</code>  <code>classmethod</code>","text":"<p>Build the inventory feature function.</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>@classmethod\ndef build_feature_fn(cls, scope):\n    \"\"\"Build the inventory feature function.\"\"\"\n\n    def fn(state, agent_idx):\n        return inventory_feature(state.agent_inv, agent_idx)\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.agent_pos_feature","title":"<code>agent_pos_feature(agent_pos, agent_idx)</code>","text":"<p>Extract agent position as (2,) int32 array.</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>def agent_pos_feature(agent_pos, agent_idx):\n    \"\"\"Extract agent position as (2,) int32 array.\"\"\"\n    return agent_pos[agent_idx].astype(xp.int32)\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.agent_dir_feature","title":"<code>agent_dir_feature(agent_dir, agent_idx)</code>","text":"<p>One-hot encoding of agent direction as (4,) int32 array.</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>def agent_dir_feature(agent_dir, agent_idx):\n    \"\"\"One-hot encoding of agent direction as (4,) int32 array.\"\"\"\n    return (xp.arange(4) == agent_dir[agent_idx]).astype(xp.int32)\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.full_map_encoding_feature","title":"<code>full_map_encoding_feature(object_type_map, object_state_map, agent_pos, agent_dir, agent_inv, agent_type_ids, max_map_size=(12, 12))</code>","text":"<p>3-channel map encoding (max_H, max_W, 3) int8 with agent overlays.</p> <p>Channels: (0) type IDs, (1) extra state (zeros), (2) object state. <code>agent_type_ids</code> maps direction -&gt; global-scope agent type_id (pre-computed at init time).</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>def full_map_encoding_feature(\n    object_type_map,\n    object_state_map,\n    agent_pos,\n    agent_dir,\n    agent_inv,\n    agent_type_ids,\n    max_map_size=(12, 12),\n):\n    \"\"\"3-channel map encoding (max_H, max_W, 3) int8 with agent overlays.\n\n    Channels: (0) type IDs, (1) extra state (zeros), (2) object state.\n    ``agent_type_ids`` maps direction -&gt; global-scope agent type_id\n    (pre-computed at init time).\n    \"\"\"\n    from cogrid.backend.array_ops import set_at_2d\n\n    max_H, max_W = max_map_size\n    H, W = object_type_map.shape\n\n    # Build channels using xp.pad to avoid backend-specific slice assignment\n    pad_h = max_H - H\n    pad_w = max_W - W\n    ch0 = xp.pad(object_type_map.astype(xp.int8), ((0, pad_h), (0, pad_w)))\n    ch1 = xp.zeros((max_H, max_W), dtype=xp.int8)\n    ch2 = xp.pad(object_state_map.astype(xp.int8), ((0, pad_h), (0, pad_w)))\n\n    # Agent overlay: type_id per agent based on direction\n    agent_type = agent_type_ids[agent_dir]  # (n_agents,)\n    agent_state = xp.where(agent_inv[:, 0] == -1, 0, agent_inv[:, 0])  # (n_agents,)\n\n    rows = agent_pos[:, 0]\n    cols = agent_pos[:, 1]\n\n    # Scatter agents onto channels using set_at_2d (loop over n_agents which is\n    # static/tiny, typically 2). Uses array-valued indices, no int() casts.\n    for i_agent in range(agent_pos.shape[0]):\n        r, c = rows[i_agent], cols[i_agent]\n        ch0 = set_at_2d(ch0, r, c, agent_type[i_agent].astype(xp.int8))\n        ch1 = set_at_2d(ch1, r, c, xp.int8(0))\n        ch2 = set_at_2d(ch2, r, c, agent_state[i_agent].astype(xp.int8))\n\n    encoding = xp.stack([ch0, ch1, ch2], axis=-1)\n    return encoding\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.can_move_direction_feature","title":"<code>can_move_direction_feature(agent_pos, agent_idx, wall_map, object_type_map, can_overlap_table)</code>","text":"<p>Multi-hot (4,) encoding of movable directions (Right, Left, Down, Up).</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>def can_move_direction_feature(agent_pos, agent_idx, wall_map, object_type_map, can_overlap_table):\n    \"\"\"Multi-hot (4,) encoding of movable directions (Right, Left, Down, Up).\"\"\"\n    H, W = wall_map.shape\n\n    # 4 directions matching adjacent_positions order: Right, Left, Down, Up\n    deltas = xp.array([[0, 1], [0, -1], [1, 0], [-1, 0]], dtype=xp.int32)\n    pos = agent_pos[agent_idx]  # (2,)\n    neighbors = pos[None, :] + deltas  # (4, 2)\n\n    # Check bounds\n    in_bounds = (\n        (neighbors[:, 0] &gt;= 0)\n        &amp; (neighbors[:, 0] &lt; H)\n        &amp; (neighbors[:, 1] &gt;= 0)\n        &amp; (neighbors[:, 1] &lt; W)\n    )\n\n    # Clip to valid indices for safe array access (out-of-bounds masked by in_bounds)\n    clipped = xp.clip(neighbors, xp.array([0, 0]), xp.array([H - 1, W - 1]))\n    type_ids = object_type_map[clipped[:, 0], clipped[:, 1]]  # (4,)\n    can_overlap = can_overlap_table[type_ids]  # (4,)\n\n    return (in_bounds &amp; (can_overlap == 1)).astype(xp.int32)\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.inventory_feature","title":"<code>inventory_feature(agent_inv, agent_idx)</code>","text":"<p>Inventory as (1,) int32: 0 if empty, type_id+1 otherwise.</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>def inventory_feature(agent_inv, agent_idx):\n    \"\"\"Inventory as (1,) int32: 0 if empty, type_id+1 otherwise.\"\"\"\n    inv_val = agent_inv[agent_idx, 0]\n    feature_val = xp.where(inv_val == -1, 0, inv_val + 1)\n    return xp.array([feature_val], dtype=xp.int32)\n</code></pre>"},{"location":"reference/cogrid/feature_space/features/#cogrid.feature_space.features.get_all_agent_obs","title":"<code>get_all_agent_obs(feature_fn, state, n_agents)</code>","text":"<p>Stack per-agent observations into (n_agents, obs_dim) array.</p> Source code in <code>cogrid/feature_space/features.py</code> <pre><code>def get_all_agent_obs(feature_fn, state, n_agents):\n    \"\"\"Stack per-agent observations into (n_agents, obs_dim) array.\"\"\"\n    return xp.stack([feature_fn(state, i) for i in range(n_agents)])\n</code></pre>"},{"location":"reference/cogrid/rendering/","title":"rendering","text":""},{"location":"reference/cogrid/rendering/#cogrid.rendering","title":"<code>cogrid.rendering</code>","text":"<p>Rendering utilities and EnvRenderer.</p>"},{"location":"reference/cogrid/rendering/#cogrid.rendering.EnvRenderer","title":"<code>EnvRenderer</code>","text":"<p>Manages a PyGame window for human-mode rendering.</p>"},{"location":"reference/cogrid/rendering/#cogrid.rendering.EnvRenderer--parameters","title":"Parameters","text":"<p>name : str     Window title (passed to <code>pygame.display.set_caption</code>). screen_size : int     Width and height of the display window in pixels. render_fps : int     Target frames-per-second for <code>pygame.time.Clock.tick</code>.</p> Source code in <code>cogrid/rendering/env_renderer.py</code> <pre><code>class EnvRenderer:\n    \"\"\"Manages a PyGame window for human-mode rendering.\n\n    Parameters\n    ----------\n    name : str\n        Window title (passed to ``pygame.display.set_caption``).\n    screen_size : int\n        Width and height of the display window in pixels.\n    render_fps : int\n        Target frames-per-second for ``pygame.time.Clock.tick``.\n    \"\"\"\n\n    def __init__(self, name: str, screen_size: int, render_fps: int) -&gt; None:\n        \"\"\"Initialize the renderer with name, screen size, and FPS.\"\"\"\n        self.name = name\n        self.screen_size = screen_size\n        self.render_fps = render_fps\n\n        self.window = None\n        self.clock = None\n        self.render_size = None\n\n    def render_human(\n        self,\n        img: np.ndarray,\n        cumulative_score: float,\n        render_message: str,\n    ) -&gt; None:\n        \"\"\"Display a frame in the PyGame window.\n\n        Lazily initialises PyGame, the display window, and the clock on the\n        first call.  Subsequent calls blit the provided image, overlay score\n        and message text, and tick the clock.\n\n        Parameters\n        ----------\n        img : np.ndarray\n            RGB image array (H, W, 3) to display.\n        cumulative_score : float\n            Cumulative episode score shown in the overlay.\n        render_message : str\n            Additional message appended after the score text.\n        \"\"\"\n        if pygame is None:\n            raise ImportError(\"Must install pygame to use interactive mode.\")\n\n        if self.render_size is None:\n            self.render_size = img.shape[:2]\n        if self.window is None:\n            pygame.init()\n            pygame.display.init()\n            self.window = pygame.display.set_mode((self.screen_size, self.screen_size))\n            pygame.display.set_caption(self.name)\n        if self.clock is None:\n            self.clock = pygame.time.Clock()\n\n        surf = pygame.surfarray.make_surface(img)\n\n        # Correct orientation (pygame flips/rotates the array)\n        surf = pygame.transform.flip(surf, False, True)\n        surf = pygame.transform.rotate(surf, 270)\n\n        # Create background with score/message overlay\n        offset = surf.get_size()[0] * 0.1\n        bg = pygame.Surface(\n            (\n                int(surf.get_size()[0] + offset),\n                int(surf.get_size()[1] + offset),\n            )\n        )\n        bg.convert()\n        bg.fill((255, 255, 255))\n        bg.blit(surf, (offset / 2, 0))\n\n        bg = pygame.transform.smoothscale(bg, (self.screen_size, self.screen_size))\n\n        font_size = 22\n        text = f\"Score: {np.round(cumulative_score, 2)}\" + render_message\n\n        font = pygame.freetype.SysFont(pygame.font.get_default_font(), font_size)\n        text_rect = font.get_rect(text, size=font_size)\n        text_rect.center = bg.get_rect().center\n        text_rect.y = bg.get_height() - font_size * 1.5\n        font.render_to(bg, text_rect, text, size=font_size)\n\n        self.window.blit(bg, (0, 0))\n        pygame.event.pump()\n        self.clock.tick(self.render_fps)\n        pygame.display.update()\n\n    def close(self) -&gt; None:\n        \"\"\"Shut down the PyGame display and quit PyGame.\"\"\"\n        if self.window is not None:\n            pygame.display.quit()\n            pygame.quit()\n            self.window = None\n            self.clock = None\n            self.render_size = None\n</code></pre>"},{"location":"reference/cogrid/rendering/#cogrid.rendering.EnvRenderer.__init__","title":"<code>__init__(name, screen_size, render_fps)</code>","text":"<p>Initialize the renderer with name, screen size, and FPS.</p> Source code in <code>cogrid/rendering/env_renderer.py</code> <pre><code>def __init__(self, name: str, screen_size: int, render_fps: int) -&gt; None:\n    \"\"\"Initialize the renderer with name, screen size, and FPS.\"\"\"\n    self.name = name\n    self.screen_size = screen_size\n    self.render_fps = render_fps\n\n    self.window = None\n    self.clock = None\n    self.render_size = None\n</code></pre>"},{"location":"reference/cogrid/rendering/#cogrid.rendering.EnvRenderer.render_human","title":"<code>render_human(img, cumulative_score, render_message)</code>","text":"<p>Display a frame in the PyGame window.</p> <p>Lazily initialises PyGame, the display window, and the clock on the first call.  Subsequent calls blit the provided image, overlay score and message text, and tick the clock.</p>"},{"location":"reference/cogrid/rendering/#cogrid.rendering.EnvRenderer.render_human--parameters","title":"Parameters","text":"<p>img : np.ndarray     RGB image array (H, W, 3) to display. cumulative_score : float     Cumulative episode score shown in the overlay. render_message : str     Additional message appended after the score text.</p> Source code in <code>cogrid/rendering/env_renderer.py</code> <pre><code>def render_human(\n    self,\n    img: np.ndarray,\n    cumulative_score: float,\n    render_message: str,\n) -&gt; None:\n    \"\"\"Display a frame in the PyGame window.\n\n    Lazily initialises PyGame, the display window, and the clock on the\n    first call.  Subsequent calls blit the provided image, overlay score\n    and message text, and tick the clock.\n\n    Parameters\n    ----------\n    img : np.ndarray\n        RGB image array (H, W, 3) to display.\n    cumulative_score : float\n        Cumulative episode score shown in the overlay.\n    render_message : str\n        Additional message appended after the score text.\n    \"\"\"\n    if pygame is None:\n        raise ImportError(\"Must install pygame to use interactive mode.\")\n\n    if self.render_size is None:\n        self.render_size = img.shape[:2]\n    if self.window is None:\n        pygame.init()\n        pygame.display.init()\n        self.window = pygame.display.set_mode((self.screen_size, self.screen_size))\n        pygame.display.set_caption(self.name)\n    if self.clock is None:\n        self.clock = pygame.time.Clock()\n\n    surf = pygame.surfarray.make_surface(img)\n\n    # Correct orientation (pygame flips/rotates the array)\n    surf = pygame.transform.flip(surf, False, True)\n    surf = pygame.transform.rotate(surf, 270)\n\n    # Create background with score/message overlay\n    offset = surf.get_size()[0] * 0.1\n    bg = pygame.Surface(\n        (\n            int(surf.get_size()[0] + offset),\n            int(surf.get_size()[1] + offset),\n        )\n    )\n    bg.convert()\n    bg.fill((255, 255, 255))\n    bg.blit(surf, (offset / 2, 0))\n\n    bg = pygame.transform.smoothscale(bg, (self.screen_size, self.screen_size))\n\n    font_size = 22\n    text = f\"Score: {np.round(cumulative_score, 2)}\" + render_message\n\n    font = pygame.freetype.SysFont(pygame.font.get_default_font(), font_size)\n    text_rect = font.get_rect(text, size=font_size)\n    text_rect.center = bg.get_rect().center\n    text_rect.y = bg.get_height() - font_size * 1.5\n    font.render_to(bg, text_rect, text, size=font_size)\n\n    self.window.blit(bg, (0, 0))\n    pygame.event.pump()\n    self.clock.tick(self.render_fps)\n    pygame.display.update()\n</code></pre>"},{"location":"reference/cogrid/rendering/#cogrid.rendering.EnvRenderer.close","title":"<code>close()</code>","text":"<p>Shut down the PyGame display and quit PyGame.</p> Source code in <code>cogrid/rendering/env_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Shut down the PyGame display and quit PyGame.\"\"\"\n    if self.window is not None:\n        pygame.display.quit()\n        pygame.quit()\n        self.window = None\n        self.clock = None\n        self.render_size = None\n</code></pre>"},{"location":"reference/cogrid/rendering/env_renderer/","title":"env_renderer","text":""},{"location":"reference/cogrid/rendering/env_renderer/#cogrid.rendering.env_renderer","title":"<code>cogrid.rendering.env_renderer</code>","text":"<p>EnvRenderer: PyGame window management for CoGridEnv rendering.</p> <p>Encapsulates all PyGame-specific display logic (window creation, surface blitting, font rendering, event pumping) so that cogrid_env.py remains free of any PyGame dependency.</p>"},{"location":"reference/cogrid/rendering/env_renderer/#cogrid.rendering.env_renderer.EnvRenderer","title":"<code>EnvRenderer</code>","text":"<p>Manages a PyGame window for human-mode rendering.</p>"},{"location":"reference/cogrid/rendering/env_renderer/#cogrid.rendering.env_renderer.EnvRenderer--parameters","title":"Parameters","text":"<p>name : str     Window title (passed to <code>pygame.display.set_caption</code>). screen_size : int     Width and height of the display window in pixels. render_fps : int     Target frames-per-second for <code>pygame.time.Clock.tick</code>.</p> Source code in <code>cogrid/rendering/env_renderer.py</code> <pre><code>class EnvRenderer:\n    \"\"\"Manages a PyGame window for human-mode rendering.\n\n    Parameters\n    ----------\n    name : str\n        Window title (passed to ``pygame.display.set_caption``).\n    screen_size : int\n        Width and height of the display window in pixels.\n    render_fps : int\n        Target frames-per-second for ``pygame.time.Clock.tick``.\n    \"\"\"\n\n    def __init__(self, name: str, screen_size: int, render_fps: int) -&gt; None:\n        \"\"\"Initialize the renderer with name, screen size, and FPS.\"\"\"\n        self.name = name\n        self.screen_size = screen_size\n        self.render_fps = render_fps\n\n        self.window = None\n        self.clock = None\n        self.render_size = None\n\n    def render_human(\n        self,\n        img: np.ndarray,\n        cumulative_score: float,\n        render_message: str,\n    ) -&gt; None:\n        \"\"\"Display a frame in the PyGame window.\n\n        Lazily initialises PyGame, the display window, and the clock on the\n        first call.  Subsequent calls blit the provided image, overlay score\n        and message text, and tick the clock.\n\n        Parameters\n        ----------\n        img : np.ndarray\n            RGB image array (H, W, 3) to display.\n        cumulative_score : float\n            Cumulative episode score shown in the overlay.\n        render_message : str\n            Additional message appended after the score text.\n        \"\"\"\n        if pygame is None:\n            raise ImportError(\"Must install pygame to use interactive mode.\")\n\n        if self.render_size is None:\n            self.render_size = img.shape[:2]\n        if self.window is None:\n            pygame.init()\n            pygame.display.init()\n            self.window = pygame.display.set_mode((self.screen_size, self.screen_size))\n            pygame.display.set_caption(self.name)\n        if self.clock is None:\n            self.clock = pygame.time.Clock()\n\n        surf = pygame.surfarray.make_surface(img)\n\n        # Correct orientation (pygame flips/rotates the array)\n        surf = pygame.transform.flip(surf, False, True)\n        surf = pygame.transform.rotate(surf, 270)\n\n        # Create background with score/message overlay\n        offset = surf.get_size()[0] * 0.1\n        bg = pygame.Surface(\n            (\n                int(surf.get_size()[0] + offset),\n                int(surf.get_size()[1] + offset),\n            )\n        )\n        bg.convert()\n        bg.fill((255, 255, 255))\n        bg.blit(surf, (offset / 2, 0))\n\n        bg = pygame.transform.smoothscale(bg, (self.screen_size, self.screen_size))\n\n        font_size = 22\n        text = f\"Score: {np.round(cumulative_score, 2)}\" + render_message\n\n        font = pygame.freetype.SysFont(pygame.font.get_default_font(), font_size)\n        text_rect = font.get_rect(text, size=font_size)\n        text_rect.center = bg.get_rect().center\n        text_rect.y = bg.get_height() - font_size * 1.5\n        font.render_to(bg, text_rect, text, size=font_size)\n\n        self.window.blit(bg, (0, 0))\n        pygame.event.pump()\n        self.clock.tick(self.render_fps)\n        pygame.display.update()\n\n    def close(self) -&gt; None:\n        \"\"\"Shut down the PyGame display and quit PyGame.\"\"\"\n        if self.window is not None:\n            pygame.display.quit()\n            pygame.quit()\n            self.window = None\n            self.clock = None\n            self.render_size = None\n</code></pre>"},{"location":"reference/cogrid/rendering/env_renderer/#cogrid.rendering.env_renderer.EnvRenderer.__init__","title":"<code>__init__(name, screen_size, render_fps)</code>","text":"<p>Initialize the renderer with name, screen size, and FPS.</p> Source code in <code>cogrid/rendering/env_renderer.py</code> <pre><code>def __init__(self, name: str, screen_size: int, render_fps: int) -&gt; None:\n    \"\"\"Initialize the renderer with name, screen size, and FPS.\"\"\"\n    self.name = name\n    self.screen_size = screen_size\n    self.render_fps = render_fps\n\n    self.window = None\n    self.clock = None\n    self.render_size = None\n</code></pre>"},{"location":"reference/cogrid/rendering/env_renderer/#cogrid.rendering.env_renderer.EnvRenderer.render_human","title":"<code>render_human(img, cumulative_score, render_message)</code>","text":"<p>Display a frame in the PyGame window.</p> <p>Lazily initialises PyGame, the display window, and the clock on the first call.  Subsequent calls blit the provided image, overlay score and message text, and tick the clock.</p>"},{"location":"reference/cogrid/rendering/env_renderer/#cogrid.rendering.env_renderer.EnvRenderer.render_human--parameters","title":"Parameters","text":"<p>img : np.ndarray     RGB image array (H, W, 3) to display. cumulative_score : float     Cumulative episode score shown in the overlay. render_message : str     Additional message appended after the score text.</p> Source code in <code>cogrid/rendering/env_renderer.py</code> <pre><code>def render_human(\n    self,\n    img: np.ndarray,\n    cumulative_score: float,\n    render_message: str,\n) -&gt; None:\n    \"\"\"Display a frame in the PyGame window.\n\n    Lazily initialises PyGame, the display window, and the clock on the\n    first call.  Subsequent calls blit the provided image, overlay score\n    and message text, and tick the clock.\n\n    Parameters\n    ----------\n    img : np.ndarray\n        RGB image array (H, W, 3) to display.\n    cumulative_score : float\n        Cumulative episode score shown in the overlay.\n    render_message : str\n        Additional message appended after the score text.\n    \"\"\"\n    if pygame is None:\n        raise ImportError(\"Must install pygame to use interactive mode.\")\n\n    if self.render_size is None:\n        self.render_size = img.shape[:2]\n    if self.window is None:\n        pygame.init()\n        pygame.display.init()\n        self.window = pygame.display.set_mode((self.screen_size, self.screen_size))\n        pygame.display.set_caption(self.name)\n    if self.clock is None:\n        self.clock = pygame.time.Clock()\n\n    surf = pygame.surfarray.make_surface(img)\n\n    # Correct orientation (pygame flips/rotates the array)\n    surf = pygame.transform.flip(surf, False, True)\n    surf = pygame.transform.rotate(surf, 270)\n\n    # Create background with score/message overlay\n    offset = surf.get_size()[0] * 0.1\n    bg = pygame.Surface(\n        (\n            int(surf.get_size()[0] + offset),\n            int(surf.get_size()[1] + offset),\n        )\n    )\n    bg.convert()\n    bg.fill((255, 255, 255))\n    bg.blit(surf, (offset / 2, 0))\n\n    bg = pygame.transform.smoothscale(bg, (self.screen_size, self.screen_size))\n\n    font_size = 22\n    text = f\"Score: {np.round(cumulative_score, 2)}\" + render_message\n\n    font = pygame.freetype.SysFont(pygame.font.get_default_font(), font_size)\n    text_rect = font.get_rect(text, size=font_size)\n    text_rect.center = bg.get_rect().center\n    text_rect.y = bg.get_height() - font_size * 1.5\n    font.render_to(bg, text_rect, text, size=font_size)\n\n    self.window.blit(bg, (0, 0))\n    pygame.event.pump()\n    self.clock.tick(self.render_fps)\n    pygame.display.update()\n</code></pre>"},{"location":"reference/cogrid/rendering/env_renderer/#cogrid.rendering.env_renderer.EnvRenderer.close","title":"<code>close()</code>","text":"<p>Shut down the PyGame display and quit PyGame.</p> Source code in <code>cogrid/rendering/env_renderer.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Shut down the PyGame display and quit PyGame.\"\"\"\n    if self.window is not None:\n        pygame.display.quit()\n        pygame.quit()\n        self.window = None\n        self.clock = None\n        self.render_size = None\n</code></pre>"},{"location":"reference/cogrid/visualization/","title":"visualization","text":""},{"location":"reference/cogrid/visualization/#cogrid.visualization","title":"<code>cogrid.visualization</code>","text":"<p>Visualization and image drawing utilities.</p>"},{"location":"reference/cogrid/visualization/rendering/","title":"rendering","text":""},{"location":"reference/cogrid/visualization/rendering/#cogrid.visualization.rendering","title":"<code>cogrid.visualization.rendering</code>","text":"<p>Low-level image drawing primitives for tile rendering.</p>"},{"location":"reference/cogrid/visualization/rendering/#cogrid.visualization.rendering.downsample","title":"<code>downsample(img, factor)</code>","text":"<p>Downsample an image along both dimensions by some factor.</p> Source code in <code>cogrid/visualization/rendering.py</code> <pre><code>def downsample(img, factor):\n    \"\"\"Downsample an image along both dimensions by some factor.\"\"\"\n    assert img.shape[0] % factor == 0\n    assert img.shape[1] % factor == 0\n\n    img = img.reshape([img.shape[0] // factor, factor, img.shape[1] // factor, factor, 3])\n    img = img.mean(axis=3)\n    img = img.mean(axis=1)\n\n    return img\n</code></pre>"},{"location":"reference/cogrid/visualization/rendering/#cogrid.visualization.rendering.fill_coords","title":"<code>fill_coords(img, fn, color)</code>","text":"<p>Fill pixels of an image with coordinates matching a filter function.</p> Source code in <code>cogrid/visualization/rendering.py</code> <pre><code>def fill_coords(img, fn, color):\n    \"\"\"Fill pixels of an image with coordinates matching a filter function.\"\"\"\n    for y in range(img.shape[0]):\n        for x in range(img.shape[1]):\n            yf = (y + 0.5) / img.shape[0]\n            xf = (x + 0.5) / img.shape[1]\n            if fn(xf, yf):\n                img[y, x] = color\n\n    return img\n</code></pre>"},{"location":"reference/cogrid/visualization/rendering/#cogrid.visualization.rendering.rotate_fn","title":"<code>rotate_fn(fin, cx, cy, theta)</code>","text":"<p>Return a rotation-transformed coordinate filter function.</p> Source code in <code>cogrid/visualization/rendering.py</code> <pre><code>def rotate_fn(fin, cx, cy, theta):\n    \"\"\"Return a rotation-transformed coordinate filter function.\"\"\"\n\n    def fout(x, y):\n        x = x - cx\n        y = y - cy\n\n        x2 = cx + x * math.cos(-theta) - y * math.sin(-theta)\n        y2 = cy + y * math.cos(-theta) + x * math.sin(-theta)\n\n        return fin(x2, y2)\n\n    return fout\n</code></pre>"},{"location":"reference/cogrid/visualization/rendering/#cogrid.visualization.rendering.point_in_line","title":"<code>point_in_line(x0, y0, x1, y1, r)</code>","text":"<p>Return a filter for points within distance r of a line segment.</p> Source code in <code>cogrid/visualization/rendering.py</code> <pre><code>def point_in_line(x0, y0, x1, y1, r):\n    \"\"\"Return a filter for points within distance r of a line segment.\"\"\"\n    p0 = np.array([x0, y0], dtype=np.float32)\n    p1 = np.array([x1, y1], dtype=np.float32)\n    dir = p1 - p0\n    dist = np.linalg.norm(dir)\n    dir = dir / dist\n\n    xmin = min(x0, x1) - r\n    xmax = max(x0, x1) + r\n    ymin = min(y0, y1) - r\n    ymax = max(y0, y1) + r\n\n    def fn(x, y):\n        # Fast, early escape test\n        if x &lt; xmin or x &gt; xmax or y &lt; ymin or y &gt; ymax:\n            return False\n\n        q = np.array([x, y])\n        pq = q - p0\n\n        # Closest point on line\n        a = np.dot(pq, dir)\n        a = np.clip(a, 0, dist)\n        p = p0 + a * dir\n\n        dist_to_line = np.linalg.norm(q - p)\n        return dist_to_line &lt;= r\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/visualization/rendering/#cogrid.visualization.rendering.point_in_circle","title":"<code>point_in_circle(cx, cy, r)</code>","text":"<p>Return a filter for points inside a circle.</p> Source code in <code>cogrid/visualization/rendering.py</code> <pre><code>def point_in_circle(cx, cy, r):\n    \"\"\"Return a filter for points inside a circle.\"\"\"\n\n    def fn(x, y):\n        return (x - cx) * (x - cx) + (y - cy) * (y - cy) &lt;= r * r\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/visualization/rendering/#cogrid.visualization.rendering.point_in_rect","title":"<code>point_in_rect(xmin, xmax, ymin, ymax)</code>","text":"<p>Return a filter for points inside a rectangle.</p> Source code in <code>cogrid/visualization/rendering.py</code> <pre><code>def point_in_rect(xmin, xmax, ymin, ymax):\n    \"\"\"Return a filter for points inside a rectangle.\"\"\"\n\n    def fn(x, y):\n        return x &gt;= xmin and x &lt;= xmax and y &gt;= ymin and y &lt;= ymax\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/visualization/rendering/#cogrid.visualization.rendering.point_in_triangle","title":"<code>point_in_triangle(a, b, c)</code>","text":"<p>Return a filter for points inside a triangle.</p> Source code in <code>cogrid/visualization/rendering.py</code> <pre><code>def point_in_triangle(a, b, c):\n    \"\"\"Return a filter for points inside a triangle.\"\"\"\n    a = np.array(a, dtype=np.float32)\n    b = np.array(b, dtype=np.float32)\n    c = np.array(c, dtype=np.float32)\n\n    def fn(x, y):\n        v0 = c - a\n        v1 = b - a\n        v2 = np.array((x, y)) - a\n\n        # Compute dot products\n        dot00 = np.dot(v0, v0)\n        dot01 = np.dot(v0, v1)\n        dot02 = np.dot(v0, v2)\n        dot11 = np.dot(v1, v1)\n        dot12 = np.dot(v1, v2)\n\n        # Compute barycentric coordinates\n        inv_denom = 1 / (dot00 * dot11 - dot01 * dot01)\n        u = (dot11 * dot02 - dot01 * dot12) * inv_denom\n        v = (dot00 * dot12 - dot01 * dot02) * inv_denom\n\n        # Check if point is in triangle\n        return (u &gt;= 0) and (v &gt;= 0) and (u + v) &lt; 1\n\n    return fn\n</code></pre>"},{"location":"reference/cogrid/visualization/rendering/#cogrid.visualization.rendering.highlight_img","title":"<code>highlight_img(img, color=(255, 255, 255), alpha=0.3)</code>","text":"<p>Add highlighting to an image.</p> Source code in <code>cogrid/visualization/rendering.py</code> <pre><code>def highlight_img(img, color=(255, 255, 255), alpha=0.30):\n    \"\"\"Add highlighting to an image.\"\"\"\n    blend_img = img + alpha * (np.array(color, dtype=np.uint8) - img)\n    blend_img = blend_img.clip(0, 255).astype(np.uint8)\n    img[:, :, :] = blend_img\n</code></pre>"},{"location":"reference/cogrid/visualization/rendering/#cogrid.visualization.rendering.add_text_to_image","title":"<code>add_text_to_image(image, text, position, font=cv2.FONT_HERSHEY_SIMPLEX if cv2 else None, font_scale=1, color=(255, 255, 255), thickness=2)</code>","text":"<p>Add text to an RGB image using OpenCV.</p> Source code in <code>cogrid/visualization/rendering.py</code> <pre><code>def add_text_to_image(\n    image,\n    text,\n    position,\n    font=cv2.FONT_HERSHEY_SIMPLEX if cv2 else None,\n    font_scale=1,\n    color=(255, 255, 255),\n    thickness=2,\n):\n    \"\"\"Add text to an RGB image using OpenCV.\"\"\"\n    assert cv2 is not None, \"Must have cv2 installed to add text. Try `pip install opencv-python`.\"\n\n    # Add the text to the image\n    cv2.putText(image, text, position, font, font_scale, color, thickness)\n\n    return image\n</code></pre>"},{"location":"tutorials/custom-environment/","title":"Implementing a New Environment","text":"<p>This guide walks through every step required to implement a new environment with CoGrid, using the built-in Overcooked environment as a concrete reference. By the end you will have:</p> <ul> <li>Grid objects with interaction properties</li> <li>A tick function for per-step state updates</li> <li>Custom interaction logic</li> <li>Reward functions</li> <li>Feature extractors for observations</li> <li>Layouts and environment registration</li> </ul>"},{"location":"tutorials/custom-environment/#architecture-overview","title":"Architecture Overview","text":"<p>Every CoGrid environment is assembled from four kinds of registered components:</p> <pre><code>+-----------------------------+\n|        CoGridEnv            |   Stateful wrapper (PettingZoo API)\n+-----------------------------+\n| config dict                 |   Declares scope, features, rewards, layout\n+----+------------------------+\n     |\n     v\n+----+------------------------+\n|      Autowire Layer         |   Composes registered components into\n|  build_scope_config()       |   a scope_config dict at init time\n|  build_reward_config()      |\n|  build_feature_config()     |\n+----+------------------------+\n     |\n     v\n+----+------------------------+\n|      Step Pipeline          |   Pure function: (state, actions) -&gt; (state, obs, rewards, ...)\n|  tick -&gt; move -&gt; interact   |\n|  -&gt; observe -&gt; reward       |\n+-----------------------------+\n</code></pre> <p>Components are registered via decorators and discovered automatically by the autowire layer. All custom behavior lives in your own project code and is injected into the engine through decorators and config entries. The decorators register your components into CoGrid's global registries at import time, so the engine can discover them without any changes to CoGrid's source.</p>"},{"location":"tutorials/custom-environment/#step-1-create-your-project-structure","title":"Step 1: Create Your Project Structure","text":"<p>After installing CoGrid (<code>pip install cogrid</code>), create a Python package for your environment in your own project:</p> <pre><code>my_project/\n    my_env/\n        __init__.py               # Triggers decorator registration\n        grid_objects.py           # Grid objects (@register_object_type)\n        config.py           # Interaction fn, tick fn, extra state builders\n        rewards.py                # Reward functions (@register_reward_type)\n        features.py               # Feature extractors (@register_feature_type)\n        agent.py                  # Custom Agent subclass (optional)\n    train.py                      # Your training script\n</code></pre> <p>The <code>__init__.py</code> must import every module that contains <code>@register_*</code> decorators so they execute at import time. This is what makes your components visible to the CoGrid engine:</p> <pre><code># my_env/__init__.py\nfrom my_env import grid_objects  # noqa: F401 -- triggers @register_object_type\nfrom my_env import rewards       # noqa: F401 -- triggers @register_reward_type\nfrom my_env import features      # noqa: F401 -- triggers @register_feature_type\n</code></pre> <p>Note</p> <p>You must <code>import my_env</code> (or the individual submodules) somewhere in your code before calling <code>registry.make()</code>. The decorators register components into CoGrid's global registries as a side effect of import.</p>"},{"location":"tutorials/custom-environment/#step-2-define-grid-objects","title":"Step 2: Define Grid Objects","text":"<p>Each object on the grid is a <code>GridObj</code> subclass registered with the <code>@register_object_type</code> decorator.</p> <p>Required attributes:</p> <ul> <li><code>object_id</code>: Unique string identifier (e.g., <code>\"onion\"</code>).</li> <li><code>color</code>: Rendering color (RGB tuple or <code>constants.Colors</code> enum).</li> <li><code>char</code>: Single ASCII character for layout strings. Must be unique within   the scope.</li> </ul> <p>Decorator parameters declare static interaction properties that the engine uses to build lookup tables:</p> <pre><code>@register_object_type(\n    object_id: str,\n    scope: str = \"global\",       # Namespace for this object\n    can_pickup: bool = False,     # Agent can pick this up (removes from grid)\n    can_overlap: bool = False,    # Agent can walk onto this cell\n    can_place_on: bool = False,   # Agent can place held item onto this\n    can_pickup_from: bool = False,# Agent can take an item from this (it stays)\n    is_wall: bool = False,        # Blocks movement\n)\n</code></pre> <p>The <code>scope</code> parameter namespaces your objects so their <code>char</code> and <code>object_id</code> values don't collide with objects from other environments. Choose a unique scope string for your environment (e.g., <code>\"my_env\"</code>).</p> <p>Overcooked example -- a simple pickupable object:</p> <pre><code># my_env/grid_objects.py\nfrom cogrid.core import grid_object, constants\nfrom cogrid.core.grid_object import register_object_type\nfrom cogrid.visualization.rendering import fill_coords, point_in_circle\n\n@register_object_type(\"onion\", scope=\"overcooked\", can_pickup=True)\nclass Onion(grid_object.GridObj):\n    object_id = \"onion\"\n    color = constants.Colors.Yellow\n    char = \"o\"\n\n    def render(self, tile_img):\n        fill_coords(tile_img, point_in_circle(cx=0.5, cy=0.5, r=0.3), self.color)\n</code></pre> <p>Overcooked example -- an infinite dispenser (stays on the grid, agent receives a new item):</p> <pre><code>@register_object_type(\"onion_stack\", scope=\"overcooked\", can_pickup_from=True)\nclass OnionStack(grid_object.GridObj):\n    object_id = \"onion_stack\"\n    color = constants.Colors.Yellow\n    char = \"O\"\n\n    def can_pickup_from(self, agent):\n        return True\n\n    def pick_up_from(self, agent):\n        return Onion()  # Creates a new Onion each time\n\n    def render(self, tile_img):\n        ...\n</code></pre> <p>Overcooked example -- a complex stateful object with component classmethods (the Pot). This is the most advanced pattern; see Steps 3-5 for what each classmethod does:</p> <pre><code>@register_object_type(\"pot\", scope=\"overcooked\", can_place_on=True, can_pickup_from=True)\nclass Pot(grid_object.GridObj):\n    object_id = \"pot\"\n    color = constants.Colors.Grey\n    char = \"U\"\n\n    # ... OOP methods for rendering, can_place_on, etc. ...\n\n    @classmethod\n    def build_tick_fn(cls):\n        \"\"\"Return a (state, scope_config) -&gt; state function for per-step updates.\"\"\"\n        from my_env.config import my_tick_fn\n        return my_tick_fn\n\n    @classmethod\n    def extra_state_schema(cls):\n        \"\"\"Declare extra state arrays this object needs.\"\"\"\n        return {\n            \"pot_contents\": {\"shape\": (\"n_pots\", 3), \"dtype\": \"int32\"},\n            \"pot_timer\":    {\"shape\": (\"n_pots\",),    \"dtype\": \"int32\"},\n            \"pot_positions\": {\"shape\": (\"n_pots\", 2), \"dtype\": \"int32\"},\n        }\n\n    @classmethod\n    def extra_state_builder(cls):\n        \"\"\"Return a function that initializes extra state from the parsed layout.\"\"\"\n        from my_env.config import build_extra_state\n        return build_extra_state\n\n    @classmethod\n    def build_static_tables(cls):\n        \"\"\"Return dict of additional lookup arrays for interaction logic.\"\"\"\n        from my_env.config import build_static_tables\n        return build_static_tables()\n\n    @classmethod\n    def build_render_sync_fn(cls):\n        \"\"\"Return a function that syncs array state back to GridObj for rendering.\"\"\"\n        ...\n</code></pre>"},{"location":"tutorials/custom-environment/#step-3-declare-extra-state-if-needed","title":"Step 3: Declare Extra State (if needed)","text":"<p>The core <code>EnvState</code> tracks six standard arrays:</p> <pre><code>agent_pos          (n_agents, 2)  int32   -- [row, col] per agent\nagent_dir          (n_agents,)    int32   -- direction enum per agent\nagent_inv          (n_agents, 1)  int32   -- held item type_id, -1 = empty\nwall_map           (H, W)        int32   -- wall positions\nobject_type_map    (H, W)        int32   -- type_id at each cell\nobject_state_map   (H, W)        int32   -- object state at each cell\n</code></pre> <p>If your environment needs additional state (e.g., cooking timers, health points), declare it via two classmethods on the relevant grid object:</p> <p>extra_state_schema returns a dict of <code>{key: {\"shape\": tuple, \"dtype\": str}}</code>. Shape elements can be strings like <code>\"n_pots\"</code> -- these are resolved at init time by counting objects in the layout.</p> <p>extra_state_builder returns a function that receives the parsed grid arrays and initializes the extra state. It runs once at <code>reset()</code> time.</p> <p>Extra state arrays are stored in <code>state.extra_state</code> with scope-prefixed keys. The prefix is <code>\"&lt;scope&gt;.\"</code> and is added automatically:</p> <pre><code># If your scope is \"my_env\" and you declared \"timer\" in the schema:\nstate.extra_state[\"my_env.timer\"]   # (n_objects,) int32\n</code></pre>"},{"location":"tutorials/custom-environment/#step-4-write-the-tick-function-if-needed","title":"Step 4: Write the Tick Function (if needed)","text":"<p>The tick function runs once per step before movement and interactions. Use it for time-based state machine logic (e.g., cooking timers, decay).</p> <p>Signature: <code>(state: EnvState, scope_config: dict) -&gt; EnvState</code></p> <pre><code># my_env/config.py\nimport dataclasses\nfrom cogrid.backend import xp\n\ndef my_tick_fn(state, scope_config):\n    # Read extra state\n    timer = state.extra_state[\"my_env.timer\"]\n\n    # Update (branchless for JAX compatibility)\n    new_timer = xp.where(timer &gt; 0, timer - 1, timer)\n\n    # Return updated state\n    new_extra = {**state.extra_state, \"my_env.timer\": new_timer}\n    return dataclasses.replace(state, extra_state=new_extra)\n</code></pre> <p>Register it by returning it from <code>build_tick_fn</code> on a grid object class (Step 2). Only one tick function per scope is supported -- if multiple objects define <code>build_tick_fn</code>, the last one discovered wins.</p>"},{"location":"tutorials/custom-environment/#step-5-write-the-interaction-function-if-needed","title":"Step 5: Write the Interaction Function (if needed)","text":"<p>The generic engine handles basic interactions automatically:</p> <ul> <li>pickup: Agent picks up an object from the cell ahead (if <code>can_pickup</code>).</li> <li>pickup_from: Agent receives an item from a dispenser (if <code>can_pickup_from</code>).</li> <li>drop: Agent drops held item onto an empty cell.</li> <li>place_on: Agent places held item onto a target (if <code>can_place_on</code>).</li> </ul> <p>If your environment needs custom interaction logic beyond these four (e.g., conditional placement, state machine transitions, item transformation), write a custom interaction function.</p> <p>Signature:</p> <pre><code>def my_interaction_fn(state, agent_idx, fwd_r, fwd_c, base_ok, scope_config):\n    \"\"\"\n    Called once per agent per step (lower index = higher priority).\n\n    Parameters\n    ----------\n    state : EnvState\n        Current environment state.\n    agent_idx : int\n        Index of the acting agent.\n    fwd_r, fwd_c : int\n        Row and column of the cell the agent is facing.\n    base_ok : bool\n        True if no other agent occupies the forward cell.\n    scope_config : dict\n        Contains \"type_ids\", \"static_tables\", etc.\n\n    Returns\n    -------\n    EnvState\n        Updated state after the interaction.\n    \"\"\"\n    ...\n</code></pre> <p>Overcooked example -- the Overcooked interaction function dispatches to 7 branches:</p> <pre><code>Agent presses PickupDrop while facing a cell\n|\n+-- Agent has empty inventory?\n|   +-- Cell has a pickupable object?      -&gt; PICKUP (remove from grid)\n|   +-- Cell is a stack/dispenser?          -&gt; PICKUP_FROM (get new item)\n|   +-- Cell is a pot with cooked soup      -&gt; (rejected: needs plate)\n|       and agent has plate?\n|\n+-- Agent is holding an item?\n    +-- Cell is empty?                      -&gt; DROP (place on grid)\n    +-- Cell is a pot with capacity?        -&gt; PLACE_ON_POT (add ingredient)\n    +-- Cell is a delivery zone?            -&gt; PLACE_ON_DELIVERY (deliver soup)\n    +-- Cell is an empty counter?           -&gt; PLACE_ON_COUNTER (store item)\n</code></pre> <p>The interaction function is passed directly in the config dict (Step 8), not discovered from a classmethod. This keeps scope-wide orchestration logic explicit and separate from individual object definitions.</p> <p>JAX compatibility: All branches must compute results unconditionally using <code>xp.where(condition, branch_result, fallback)</code> -- no Python <code>if/else</code> on traced values. This allows JAX to compile the function.</p>"},{"location":"tutorials/custom-environment/#step-6-define-reward-functions","title":"Step 6: Define Reward Functions","text":"<p>Reward functions are <code>Reward</code> subclasses registered with <code>@register_reward_type</code>. Each computes a <code>(n_agents,)</code> float32 array.</p> <pre><code># my_env/rewards.py\nfrom cogrid.backend import xp\nfrom cogrid.core.rewards import Reward, register_reward_type\n\n@register_reward_type(\"delivery\", scope=\"my_env\")\nclass DeliveryReward(Reward):\n    def compute(self, prev_state, state, actions, reward_config):\n        \"\"\"\n        Parameters\n        ----------\n        prev_state : StateView\n            State before the step. Dot-access for core fields\n            (agent_pos, agent_inv, object_type_map, ...) and\n            __getattr__ fallthrough for extra state (e.g., pot_timer).\n        state : StateView\n            State after the step.\n        actions : ndarray\n            (n_agents,) int32 action indices.\n        reward_config : dict\n            Contains \"type_ids\", \"n_agents\", \"action_pickup_drop_idx\".\n\n        Returns\n        -------\n        ndarray\n            (n_agents,) float32 final rewards.\n        \"\"\"\n        type_ids = reward_config[\"type_ids\"]\n        n_agents = reward_config[\"n_agents\"]\n\n        # Check which agents delivered soup\n        holds_soup = prev_state.agent_inv[:, 0] == type_ids[\"onion_soup\"]\n        # ... compute forward positions, check delivery zone ...\n\n        # Shared reward: broadcast sum to all agents\n        n_earners = xp.sum(earns_reward.astype(xp.float32))\n        return xp.full(n_agents, n_earners * 1.0, dtype=xp.float32)\n</code></pre> <p>Key details:</p> <ul> <li><code>compute()</code> returns final <code>(n_agents,)</code> rewards. Apply any scaling or   broadcasting (e.g., shared reward across all agents) inside <code>compute()</code>.</li> <li><code>prev_state</code> and <code>state</code> are <code>StateView</code> objects, not <code>EnvState</code>.   <code>StateView</code> provides dot-access with scope-stripped extra state keys   (e.g., <code>prev_state.pot_timer</code> instead of   <code>prev_state.extra_state[\"my_env.pot_timer\"]</code>).</li> <li>Multiple rewards can be registered per scope. They are summed at step time.</li> </ul>"},{"location":"tutorials/custom-environment/#step-7-define-feature-extractors","title":"Step 7: Define Feature Extractors","text":"<p>Features define the observation space. Each is a <code>Feature</code> subclass registered with <code>@register_feature_type</code>.</p> <pre><code># my_env/features.py\nfrom cogrid.backend import xp\nfrom cogrid.core.features import Feature, register_feature_type\n\n@register_feature_type(\"my_inventory\", scope=\"my_env\")\nclass MyInventory(Feature):\n    per_agent = True   # True: fn(state, agent_idx), False: fn(state)\n    obs_dim = 5        # Output size after ravel()\n\n    @classmethod\n    def build_feature_fn(cls, scope):\n        \"\"\"Build and return a pure feature function.\n\n        Called once at init time. The returned function is called every\n        step for every agent.\n        \"\"\"\n        # Pre-compute constants at build time (not per-call)\n        from cogrid.core.grid_object import object_to_idx\n        item_type_ids = xp.array([\n            object_to_idx(\"item_a\", scope=scope),\n            object_to_idx(\"item_b\", scope=scope),\n            object_to_idx(\"item_c\", scope=scope),\n            object_to_idx(\"item_d\", scope=scope),\n            object_to_idx(\"item_e\", scope=scope),\n        ], dtype=xp.int32)\n\n        def fn(state, agent_idx):\n            held = state.agent_inv[agent_idx, 0]\n            return (item_type_ids == held).astype(xp.int32)\n\n        return fn\n</code></pre> <p>Two types of features:</p> <ol> <li> <p>Per-agent (<code>per_agent = True</code>): Function signature is    <code>fn(state, agent_idx) -&gt; (obs_dim,) array</code>. Composed in ego-centric    order: focal agent first, then other agents in ascending index.</p> </li> <li> <p>Global (<code>per_agent = False</code>): Function signature is    <code>fn(state) -&gt; (obs_dim,) array</code>. Appended once after all per-agent blocks.</p> </li> </ol> <p>Composition order (automatic):</p> <pre><code>[focal per-agent feats] [agent_1 per-agent feats] ... [global feats]\n</code></pre> <p>State access: Like rewards, the <code>state</code> parameter in feature functions is a <code>StateView</code>, so extra state is accessible via dot notation (<code>state.pot_timer</code>).</p> <p>Layout hooks (optional): If features depend on a layout index (e.g., one-hot layout encoding), register layout indices and a pre-compose hook:</p> <pre><code>from cogrid.core.component_registry import (\n    register_layout_indices,\n    register_pre_compose_hook,\n)\n\nregister_layout_indices(\"my_env\", {\n    \"my_layout_v0\": 0,\n    \"my_layout_v1\": 1,\n})\n\ndef _pre_compose_hook(layout_idx, scope):\n    \"\"\"Called before feature composition with the current layout index.\"\"\"\n    ...\n\nregister_pre_compose_hook(\"my_env\", _pre_compose_hook)\n</code></pre>"},{"location":"tutorials/custom-environment/#step-8-register-layouts-and-environments","title":"Step 8: Register Layouts and Environments","text":"<p>Layouts are ASCII strings where each character maps to a registered grid object via its <code>char</code> attribute. Special characters:</p> <pre><code>#   Wall (global scope)\n+   Agent spawn point\nC   Counter (global scope)\n    (space) Empty / free space\n</code></pre> <p>All other characters are resolved from the scope you specify in the config.</p> <p>Register a layout:</p> <pre><code>from cogrid.core import layouts\n\nlayouts.register_layout(\n    \"my_layout_v0\",\n    [\n        \"#######\",\n        \"#++  G#\",\n        \"#     #\",\n        \"#  X  #\",\n        \"#G   G#\",\n        \"#######\",\n    ],\n)\n</code></pre> <p>Environment config dict -- declares everything the engine needs:</p> <pre><code>from my_env.config import my_interaction_fn\n\nmy_config = {\n    \"name\": \"my_env\",                        # Human-readable name\n    \"num_agents\": 2,                          # Number of agents\n    \"action_set\": \"cardinal_actions\",         # \"cardinal_actions\" or \"rotation_actions\"\n    \"features\": [                             # Feature names to compose into obs\n        \"agent_dir\",                          # Built-in feature (global scope)\n        \"agent_position\",                     # Built-in feature (global scope)\n        \"my_inventory\",                       # Your custom feature (Step 7)\n    ],\n    \"grid\": {\"layout\": \"my_layout_v0\"},       # Layout to use\n    \"max_steps\": 1000,                        # Truncation limit\n    \"scope\": \"my_env\",                        # Scope for component lookup\n    \"interaction_fn\": my_interaction_fn,       # Custom interaction (optional)\n}\n</code></pre> <p>Config keys reference:</p> Key Description <code>name</code> Human-readable environment name. <code>num_agents</code> Number of agents to place in the environment. <code>action_set</code> <code>\"cardinal_actions\"</code> (up/down/left/right + pickup/toggle/noop) or <code>\"rotation_actions\"</code> (forward + rotate + pickup/toggle/noop). <code>features</code> List of registered feature names to compose into observations. <code>grid</code> Either <code>{\"layout\": \"name\"}</code> or <code>{\"layout_fn\": callable}</code>. <code>max_steps</code> Steps before truncation. <code>scope</code> Scope string for all component lookups. <code>interaction_fn</code> Custom interaction function (optional, see Step 5). <code>terminated_fn</code> Custom termination function (optional, see below). <p>Register the environment:</p> <pre><code>import functools\nfrom cogrid.cogrid_env import CoGridEnv\nfrom cogrid.envs import registry\nfrom my_env.agent import MyAgent  # Your custom agent class (optional)\n\nregistry.register(\n    \"MyEnv-V0\",\n    functools.partial(\n        CoGridEnv,\n        config=my_config,\n        agent_class=MyAgent,  # Omit to use the default Agent class\n    ),\n)\n</code></pre> <p>Multiple layouts can share the same config via <code>copy.deepcopy</code>:</p> <pre><code>import copy\n\nalt_config = copy.deepcopy(my_config)\nalt_config[\"grid\"][\"layout\"] = \"my_layout_v1\"\n\nregistry.register(\n    \"MyEnv-AltLayout-V0\",\n    functools.partial(CoGridEnv, config=alt_config, agent_class=MyAgent),\n)\n</code></pre> <p>You can put all layout and registration code in your <code>my_env/__init__.py</code> or in a dedicated setup module -- just make sure it runs before you call <code>registry.make()</code>.</p>"},{"location":"tutorials/custom-environment/#step-9-custom-agent-class-optional","title":"Step 9: Custom Agent Class (optional)","text":"<p>The base <code>Agent</code> class handles movement, inventory, and direction. Subclass it only if you need custom <code>can_pickup</code> logic or additional agent state.</p> <pre><code># my_env/agent.py\nfrom cogrid.core.agent import Agent\nfrom my_env import grid_objects\n\nclass MyAgent(Agent):\n    def can_pickup(self, grid_object):\n        # Example: can only pick up from a Pot if holding a Plate\n        if isinstance(grid_object, grid_objects.Pot) and any(\n            isinstance(inv_obj, grid_objects.Plate)\n            for inv_obj in self.inventory\n        ):\n            return True\n\n        return len(self.inventory) &lt; self.inventory_capacity\n</code></pre> <p>Pass the custom agent class via the <code>agent_class</code> parameter when registering the environment (Step 8).</p>"},{"location":"tutorials/custom-environment/#step-10-custom-termination-optional","title":"Step 10: Custom Termination (optional)","text":"<p>By default, episodes end when <code>max_steps</code> is reached (truncation). For custom termination conditions (e.g., all targets collected), pass a <code>terminated_fn</code> in the config:</p> <pre><code>from cogrid.backend import xp\n\ndef my_terminated_fn(prev_state, state, reward_config):\n    \"\"\"\n    Returns (n_agents,) bool array. True = agent is terminated.\n    \"\"\"\n    # Example: terminate when no targets remain on the grid\n    type_ids = reward_config[\"type_ids\"]\n    targets_remaining = xp.any(state.object_type_map == type_ids[\"target\"])\n    all_done = ~targets_remaining\n    return xp.full(state.n_agents, all_done, dtype=xp.bool_)\n\nmy_config[\"terminated_fn\"] = my_terminated_fn\n</code></pre>"},{"location":"tutorials/custom-environment/#step-11-use-the-environment","title":"Step 11: Use the Environment","text":"<pre><code># train.py\nfrom cogrid.envs import registry\n\nimport my_env  # Triggers all @register_* decorators in your package\n\nenv = registry.make(\"MyEnv-V0\")\nobs, info = env.reset()\n\nwhile env.agents:\n    actions = {agent: env.action_space(agent).sample() for agent in env.agents}\n    obs, rewards, terminateds, truncateds, info = env.step(actions)\n</code></pre> <p>The critical line is <code>import my_env</code> -- this executes your <code>__init__.py</code> which imports the submodules, which triggers all the <code>@register_*</code> decorators that register your grid objects, rewards, and features into CoGrid's engine.</p>"},{"location":"tutorials/custom-environment/#complete-checklist","title":"Complete Checklist","text":"<pre><code>[ ] 1. pip install cogrid\n[ ] 2. Create my_env/ package in your project\n[ ] 3. Write __init__.py with imports that trigger all @register_* decorators\n[ ] 4. Define grid objects with @register_object_type (unique chars per scope)\n[ ] 5. If needed: declare extra_state_schema + extra_state_builder on a grid object\n[ ] 6. If needed: write tick function and register via build_tick_fn classmethod\n[ ] 7. If needed: write interaction function, pass via config[\"interaction_fn\"]\n[ ] 8. Define rewards with @register_reward_type\n[ ] 9. Define features with @register_feature_type\n[ ] 10. Register layouts with layouts.register_layout()\n[ ] 11. Build config dict and register environment with registry.register()\n[ ] 12. If needed: subclass Agent for custom can_pickup logic\n[ ] 13. If needed: add terminated_fn to config for custom episode termination\n[ ] 14. import my_env before calling registry.make()\n[ ] 15. Test: env = registry.make(\"MyEnv-V0\"); env.reset()\n</code></pre>"},{"location":"tutorials/custom-environment/#component-classmethod-reference","title":"Component Classmethod Reference","text":"<p>These classmethods can be defined on any <code>@register_object_type</code> class. They are discovered automatically by the decorator and wired into the step pipeline.</p> Classmethod Signature of returned value Purpose <code>build_tick_fn</code> <code>(state, scope_config) -&gt; state</code> Per-step state updates <code>extra_state_schema</code> <code>-&gt; dict</code> Declare extra state arrays <code>extra_state_builder</code> <code>-&gt; fn(parsed, scope) -&gt; dict</code> Initialize extra state <code>build_static_tables</code> <code>-&gt; dict</code> Additional lookup arrays <code>build_render_sync_fn</code> <code>-&gt; fn(grid, state, scope) -&gt; None</code> Sync arrays to GridObj for rendering"},{"location":"tutorials/jax-backend/","title":"JAX Backend","text":"<p>This tutorial covers CoGrid's JAX backend: the functional API, JIT compilation, and vmap batching for high-performance training. By the end you will be able to run thousands of environments in parallel on a single GPU.</p>"},{"location":"tutorials/jax-backend/#prerequisites","title":"Prerequisites","text":"<p>Install CoGrid with JAX support:</p> <pre><code>pip install cogrid[jax]\n</code></pre> <p>Switch to the JAX backend before creating any environment:</p> <pre><code>from cogrid.backend import set_backend\n\nset_backend(\"jax\")\n</code></pre> <p>Backend must be set first</p> <p><code>set_backend(\"jax\")</code> must be called before any call to <code>registry.make()</code>. The first environment created locks the backend for the entire process. Attempting to mix backends raises a <code>RuntimeError</code>.</p>"},{"location":"tutorials/jax-backend/#functional-api","title":"Functional API","text":"<p>CoGrid provides two APIs for interacting with environments:</p> <ol> <li>PettingZoo API (stateful wrapper) -- identical to NumPy usage</li> <li>Functional API -- pure functions on <code>EnvState</code>, designed for JIT/vmap</li> </ol> <p>The functional API exposes two methods on the environment object:</p> Method Signature Description <code>env.jax_reset</code> <code>(rng_key) -&gt; (EnvState, obs)</code> Initialize state from a JAX PRNG key <code>env.jax_step</code> <code>(EnvState, actions) -&gt; (EnvState, obs, rew, terms, truncs, info)</code> Advance one timestep <p>Both are pure functions: they take state in, return new state out, with no side effects. This makes them compatible with JAX's transformation system.</p>"},{"location":"tutorials/jax-backend/#basic-usage","title":"Basic Usage","text":"<pre><code>import jax\nimport jax.numpy as jnp\nfrom cogrid.backend import set_backend\nfrom cogrid.envs import registry\nimport cogrid.envs.overcooked  # register components\n\nset_backend(\"jax\")\nenv = registry.make(\"Overcooked-CrampedRoom-V0\")\n\n# Must call reset() once to build the pipeline\nobs, info = env.reset(seed=42)\n\n# Access the functional API\nreset_fn = env.jax_reset\nstep_fn = env.jax_step\n\n# Reset with a JAX PRNG key\nkey = jax.random.key(0)\nstate, obs = reset_fn(key)\n\n# Step with an action array (one int per agent)\nactions = jnp.array([0, 3], dtype=jnp.int32)  # Agent 0: Up, Agent 1: Right\nstate, obs, rew, terminateds, truncateds, info = step_fn(state, actions)\n</code></pre> <p>PettingZoo API still works</p> <p>You can use the standard <code>env.step(actions_dict)</code> and <code>env.reset()</code> on the JAX backend too. The stateful wrapper calls the functional pipeline internally and converts between dict and array formats. The functional API is for when you need direct control over state for JIT/vmap.</p>"},{"location":"tutorials/jax-backend/#contrast-with-numpy","title":"Contrast with NumPy","text":"NumPy (stateful)JAX (functional) <pre><code># Dict-based, stateful\nenv = registry.make(\"Overcooked-CrampedRoom-V0\")\nobs, info = env.reset(seed=42)\n\nactions = {0: 0, 1: 3}\nobs, rewards, terminateds, truncateds, info = env.step(actions)\n</code></pre> <pre><code># Array-based, pure functional\nstate, obs = env.jax_reset(jax.random.key(0))\n\nactions = jnp.array([0, 3], dtype=jnp.int32)\nstate, obs, rew, terms, truncs, info = env.jax_step(state, actions)\n</code></pre> <p>The functional API uses arrays instead of dicts: actions are <code>(n_agents,)</code> int32 arrays, observations are <code>(n_agents, obs_dim)</code> arrays, and rewards are <code>(n_agents,)</code> float32 arrays.</p>"},{"location":"tutorials/jax-backend/#jit-compilation","title":"JIT Compilation","text":"<p>The functional step and reset functions are automatically JIT-compiled when the JAX backend is active. The first call triggers XLA compilation; subsequent calls execute the compiled code.</p> <pre><code>import time\n\nstate, obs = reset_fn(jax.random.key(0))\nactions = jnp.array([0, 3], dtype=jnp.int32)\n\n# First call: includes compilation time\nt0 = time.time()\nstate, obs, rew, terms, truncs, info = step_fn(state, actions)\nprint(f\"First call (compile + execute): {time.time() - t0:.3f}s\")\n\n# Subsequent calls: fast\nt0 = time.time()\nfor _ in range(1000):\n    state, obs, rew, terms, truncs, info = step_fn(state, actions)\nprint(f\"1000 steps: {time.time() - t0:.3f}s\")\n</code></pre> Without JITWith JIT (default) <pre><code># If you need to disable auto-JIT (debugging):\nfrom cogrid.core.step_pipeline import build_step_fn\n\nstep_fn = build_step_fn(..., jit_compile=False)\n</code></pre> <pre><code># Auto-JIT is the default on JAX backend.\n# env.jax_step is already JIT-compiled.\nstep_fn = env.jax_step\n</code></pre> <p>Warmup in benchmarks</p> <p>Always call the function once before timing to exclude compilation. JIT compilation happens once per unique combination of static arguments (like <code>n_agents</code>, <code>height</code>, <code>width</code>). Recompilation only occurs if you create an environment with different static dimensions.</p>"},{"location":"tutorials/jax-backend/#vmap-batching","title":"vmap Batching","text":"<p><code>jax.vmap</code> lets you run many environments in parallel with a single function call. This is the key to high-throughput training -- thousands of environments execute simultaneously on GPU/TPU.</p>"},{"location":"tutorials/jax-backend/#basic-pattern","title":"Basic Pattern","text":"<pre><code>import jax\nimport jax.numpy as jnp\nfrom cogrid.backend import set_backend\nfrom cogrid.envs import registry\nimport cogrid.envs.overcooked\n\nset_backend(\"jax\")\nenv = registry.make(\"Overcooked-CrampedRoom-V0\")\nobs, info = env.reset(seed=42)\n\nn_envs = 1024\n\n# Split one key into n_envs independent keys\nkeys = jax.random.split(jax.random.key(0), n_envs)\n\n# Batch reset: returns (n_envs, ...) arrays\nbatched_reset = jax.jit(jax.vmap(env.jax_reset))\nstates, obs = batched_reset(keys)\n\n# Batch step: actions shape is (n_envs, n_agents)\nbatched_step = jax.jit(jax.vmap(env.jax_step))\nactions = jnp.zeros((n_envs, 2), dtype=jnp.int32)\nstates, obs, rew, terms, truncs, info = batched_step(states, actions)\n</code></pre>"},{"location":"tutorials/jax-backend/#rollout-loop","title":"Rollout Loop","text":"<p>Run multiple steps across all batched environments:</p> <pre><code>n_steps = 50\naction_key = jax.random.key(42)\ntotal_reward = jnp.float32(0.0)\n\nfor step_i in range(n_steps):\n    action_key, subkey = jax.random.split(action_key)\n    actions = jax.random.randint(subkey, (n_envs, 2), 0, 4)\n    states, obs, rew, terms, truncs, info = batched_step(states, actions)\n    total_reward += rew.sum()\n\navg_reward = total_reward / n_envs\nprint(f\"Average reward over {n_steps} steps: {float(avg_reward):.1f}\")\n</code></pre> <p>Key splitting</p> <p>Each environment needs an independent PRNG key for reproducible randomization. Use <code>jax.random.split(key, n_envs)</code> to create a batch of keys from a single root key.</p>"},{"location":"tutorials/jax-backend/#full-example","title":"Full Example","text":"<p>The <code>examples/goal_finding.py</code> script demonstrates the complete pattern: single environment on NumPy, single environment on JAX, and vmap over 1024 environments. Run it with:</p> <pre><code>python examples/goal_finding.py\n</code></pre>"},{"location":"tutorials/jax-backend/#training-example","title":"Training Example","text":"<p>The <code>examples/train_overcooked_jax.py</code> script demonstrates a complete shared-parameter IPPO training loop on Overcooked using CoGrid's JAX backend. Key features:</p> <ul> <li><code>jax.vmap</code> for parallel environment rollouts</li> <li><code>jax.lax.scan</code> for the training loop (no Python for-loop overhead)</li> <li>Auto-reset on episode completion</li> <li>The entire training loop compiles as a single XLA computation</li> </ul> <p>The script is based on JaxMARL and adapted for CoGrid. Run it with:</p> <pre><code>python examples/train_overcooked_jax.py\n</code></pre> <p>The key takeaway is that CoGrid's pure functional step pipeline integrates naturally with JAX's transformation primitives. The step function is just a function -- it works with <code>jit</code>, <code>vmap</code>, <code>scan</code>, <code>grad</code>, and any other JAX transformation.</p>"},{"location":"tutorials/jax-backend/#jax-compatibility-rules","title":"JAX Compatibility Rules","text":"<p>When writing components (tick functions, interaction functions, rewards, features) that will run on the JAX backend, follow these rules:</p> <p>No Python control flow on traced values</p> <p>JAX traces through your code at compile time. Python <code>if/else</code> statements on array values will fail because the array value is not known at trace time.</p> <pre><code># WRONG -- fails under JIT\nif state.agent_inv[0, 0] &gt; 0:\n    result = do_something()\n\n# RIGHT -- works on both backends\nresult = xp.where(state.agent_inv[0, 0] &gt; 0, do_something(), default)\n</code></pre> <p>Static array shapes</p> <p>All array shapes must be known at compile time. You cannot create arrays whose size depends on runtime values.</p> <pre><code># WRONG -- dynamic shape\nmask = xp.nonzero(state.object_type_map == target_id)\n\n# RIGHT -- static shape, boolean indexing\nmask = (state.object_type_map == target_id)\ncount = xp.sum(mask)\n</code></pre> <p>No side effects in JIT</p> <p>JIT-compiled code cannot perform I/O, modify global variables, or have any Python-level side effects. All state changes must go through the returned <code>EnvState</code>.</p> <pre><code># WRONG -- side effect\ndef tick(state, scope_config):\n    print(f\"Step {state.time}\")  # This runs at compile time, not runtime\n    ...\n\n# RIGHT -- pure function\ndef tick(state, scope_config):\n    timer = state.extra_state[\"my_env.timer\"]\n    new_timer = xp.where(timer &gt; 0, timer - 1, timer)\n    new_extra = {**state.extra_state, \"my_env.timer\": new_timer}\n    return dataclasses.replace(state, extra_state=new_extra)\n</code></pre> <p>Use dataclasses.replace for state updates</p> <p><code>EnvState</code> is a frozen dataclass. Use <code>dataclasses.replace()</code> to create a new state with updated fields. Direct attribute assignment is forbidden.</p> <pre><code>import dataclasses\n\n# WRONG -- mutation\nstate.time = state.time + 1\n\n# RIGHT -- immutable update\nstate = dataclasses.replace(state, time=state.time + 1)\n</code></pre> <p>Summary of rules:</p> Rule Pattern No <code>if/else</code> on arrays Use <code>xp.where(cond, a, b)</code> Static shapes All shapes known at compile time No side effects No print, no globals, no I/O in JIT Immutable state Use <code>dataclasses.replace()</code> PRNG keys Split keys explicitly, never reuse"}]}